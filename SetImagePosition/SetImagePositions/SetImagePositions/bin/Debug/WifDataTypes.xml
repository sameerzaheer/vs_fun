<?xml version="1.0"?>
<doc>
    <assembly>
        <name>WifDataTypes</name>
    </assembly>
    <members>
        <member name="T:Claron.WIF.BitImage">
            <summary>
            A class representing a 1 bit/pixel (binary) 2D image.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitImage.BitSet(System.Drawing.Point,System.Boolean)">
            <summary>
            Sets the given bit
            </summary>
        </member>
        <member name="M:Claron.WIF.BitImage.BitSet(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Sets the given bit
            </summary>
        </member>
        <member name="M:Claron.WIF.BitImage.IsLineEmpty(System.Int32)">
            <summary>
            Indicates whether a given line is empty (no 1-bits)
            </summary>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.BitImage.BitSet(System.Int32,System.Int32)">
            <summary>
            Sets the given bit
            </summary>
            <param name="offset"></param>
            <param name="NewValue"></param>
        </member>
        <member name="M:Claron.WIF.BitImage.BitsCount">
            <summary>
            Computes and returns the number of 1-bits in the image
            </summary>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.BitImage.ClearPadding(System.UInt32)">
             <summary>
            
             </summary>
             <param name="clearMask"> Default value = 0</param>
             <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitImage.ConnectedRunMask(System.UInt32@,System.UInt32)">
            <summary>
            Expands the first bitword to contain the full run mask starting from the source mask
            </summary>
            <param name="startRunMask"></param>
            <param name="onInSrcMask"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitImage.FindConnectedComponent(System.Int32,System.Int32)">
            <summary>
            finds the connected component that contains a seed location
            </summary>
        </member>
        <member name="M:Claron.WIF.BitImage.FindConnectedComponents(System.Drawing.Point[],Claron.WIF.BitImage)">
            <summary>
            finds all connected components that contain any of the given seed points
            </summary>
            <param name="seeds">the array of seed point coordinates</param>
            <param name="src">the bit mask in which to identify the connected components</param>
            <remarks>finds a single connected component if the seeds array contains only one entry</remarks>
        </member>
        <member name="M:Claron.WIF.BitImage.FillHoles">
            <summary>
            Fills the empty regions that are fully closed by full region, ie, not
            connected to the boundary of the image.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitImage.Erode(System.Boolean)">
            <summary>
            Erodes the bitmap by one layer in place 
            </summary>
            <param name="UseDiagonals"> If true, 8-neighbors erosion. Otherwise, 4-neighbors</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitImage.Dilate(System.Boolean)">
            <summary>
            Single discrete layer dilation in place for 4 or 8 neighborhood
            </summary>
            <param name="UseDiagonals"> Default value = true</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitImage.FillX">
            <summary>
            fills any 0-runs in X, i.e. 001001110011101100011110000 -> 001111111111111111111110000
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitImage.ToImageU12(System.Int16)">
            <summary>
            Returns an ImageU12 equivalent.
            </summary>
            <param name="ValueWhere1">The value to write where the bits are 1</param>
        </member>
        <member name="P:Claron.WIF.BitImage.Values">
            <summary>
            Returns a reference to the bits array itself: caution!
            </summary>
        </member>
        <member name="T:Claron.WIF.IndexRun">
            <summary>
            As simple helper structure describing a run in a 1D array.
            </summary>
        </member>
        <member name="T:Claron.WIF.BitVol">
             <summary>
             A volume of 1-bit (binary) voxels.
            
             A bit volume stored in bricks of 4x4x4 cubes, each containing 4x4x4 bits,
             ie, 64 bits/cube and 4096 bits/brick).
             Each cube is stored in a single UI64 word. The bits in the cube work are stored from ls to ms,
             in dimension order (X, Y, Z).
             To enable fast operations without special attention to boundary bits, the bitvol contents
             are padded with a layer of empty bricks on all sides.
             For example, a 512x512x512 Bitvol, will be organized in a 34x34x34 = 39304 bricks. In each
             dimension there would 32 bricks (512/16) plus two for padding, one on each side.
            
             Bricks are stored in an array of 66 U64 words. The first 64 contain the cubes, in x,y,z order.
             The last two are "summary" words, in which each bit represents the state of the corresponding
             cube (in order ls to ms). The bits in the BitVol.CubesFull summary word are 1 iff the cube is all 1s.
             Similarly, the bits in BitVol.CubesEmpty are 1 iff the cube is all 0s. The summary bits help take
             computation "shortcuts" during processing.
            
             Since typically many bricks are all empty (eg, all the ones in the boundary) or all full,
             two shared bricks are set aside to represent them. All the entries in the BitBricks array
             that represent an empty (or full) brick point to the same shared brick. This saves a large
             amount of storage space. For example, a 512x512x512 BitVol has a storage overhead of only a
             single array of ~40K pointers (160KB on XP32, 320KB on XP64), which is less than a single
             CT Slice.
            
             Accessing individual bits using the Bit property is very inefficient and should be reserved
             for only random-access to bits, since it requires a full traversal of the storage hierarchy.
             When traversing the bitvol or a section of it, it is far more efficient to use a
             suitable iterator object, which has a memory of its last brick/cube/bit location,
             and can thus move to the next location more efficiently and in a more efficient
             order than by linear coordinate increments.
             
             Only the 6 immediate neighbors of each voxel are considered in operations involving
             neighborhoods - dilations, erosions and region growing.
             </summary>
        </member>
        <member name="F:Claron.WIF.BitVol.BrickLength">
            <summary>
            A brick represents 4x4x4 (64) cubes, each cube stored in a single U64 word.
            </summary>
            <remarks>To improve efficiency, the brick is directly represented by an array, rather than
            by an object containing an array. The array contains two addition U64 words after the
            cubes, representing additional properties of the brick.
            </remarks>
        </member>
        <member name="F:Claron.WIF.BitVol.CubesFullI">
            <summary>
            BitVol.CubesFullI is the index of a U64 word containing one bit per 4x4x4 sub cube
            set to 1 iff all bits in the corresponding cube are set to 1.
            </summary>>
        </member>
        <member name="F:Claron.WIF.BitVol.CubesEmptyI">
            <summary>
            CubeEmptyI is the index of a U64 word containing one bit per 4x4x4 sub cube
            set to 1 iff all bits in the corresponding cube are set to 0.
            </summary>>
        </member>
        <member name="F:Claron.WIF.BitVol._brickOffsetDeltaX">
            <summary>
            Index offset to the next brick in the bit volume.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickNewCopy(System.UInt64[])">
            <summary>
            "Dumb" copy that always generates a new brick array with a copy of the source contents.
            </summary>
            <param name="Src"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickCopy(System.UInt64[]@,System.UInt64[])">
            <summary>
            A "smart" copy between two bricks than takes into account whether the bricks are shared or not.
            May change the destination's reference!
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickIsFull(System.UInt64[])">
            <summary></summary>
            <param name="B"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.BitVol.CubesFull(System.UInt64[])">
            <summary>
            Returns a "brick summary" word in which each bit is 1 iff the corresponding cube is full (all 1s).
            </summary>
            <param name="B">The brick</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.CubesEmpty(System.UInt64[])">
            <summary>
            Returns a "brick summary" word in which each bit is 1 iff the corresponding cube is empty (all 0s).
            </summary>
            <param name="B">The brick</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickSetCube(System.UInt64[]@,System.Int32,System.UInt64)">
            <summary>
            Sets the cube word to the given value. May modify the array reference if the cube
            was initially shared, but the result cannot be shared.
            </summary>
            <param name="B">The reference to the brick array (may be modified)</param>
            <param name="index">The cube's index in the array</param>
            <param name="NewCube">New bitword for the cube</param>
            <remarks>This is where all the memory allocation happens!</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickUpdateSummaries(System.UInt64[])">
            <summary>
            Computes the summary cube mask values for the brick
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickClear(System.UInt64[]@)">
            <summary>
            A function that clears the contents of a brick (but usually it's better to simply assign it to EmptyBrick!)
            </summary>
            <param name="B"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickInvert(System.UInt64[]@)">
            <summary>
            Inverts the contents of the brick, potentially changing its reference to a shared brick
            </summary>
            <param name="B"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickInvertInMask(System.UInt64[]@,System.UInt64[])">
            <summary>
            Inverts the contents of the brick, potentially changing its reference to a shared brick
            </summary>
            <param name="B"></param>
            <param name="mask"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickBitwiseAndNot(System.UInt64[]@,System.UInt64[])">
            <summary>
            Subtract the operand from the target.
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickGetImageValuesInMask(System.UInt64[]@,Claron.WIF.ImageU12[],System.Int32,System.Int32,System.Int32,System.Int16[],System.Int32@)">
            <summary>
            Returns all the image values in the brick in locations corresponding to 1 voxel locations
            </summary>
            <param name="Brick"></param>
            <param name="sliceImages">The image data array</param>
            <param name="x0">X coordinate of the brick's origin</param>
            <param name="y0"></param>
            <param name="z0"></param>
            <param name="outValues">Pre-allocated array into which to write the values. Must be at least 16*16*16 in length.</param>
            <param name="outValuesCount">An output value: the number of valid entries in outValues</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickGetImageValuesAtMaskSubSampled(System.UInt64[]@,Claron.WIF.ImageU12[],System.Int32,System.Int32,System.Int32,System.Int16[],System.Int32@)">
            <summary>
            Returns all the image values in the brick in locations corresponding to 1 voxel locations
            </summary>
            <param name="Brick"></param>
            <param name="sliceImages">The image data array</param>
            <param name="x0">X coordinate of the brick's origin</param>
            <param name="y0"></param>
            <param name="z0"></param>
            <param name="outValues">Pre-allocated array into which to write the values. Must be at least 16*16*16 in length.</param>
            <param name="outValuesCount">An output value: the number of valid entries in outValues</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickGetMaxValue(Claron.WIF.SliceStack,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the maximum value in a brick of the given slice stack.
            </summary>
            <param name="ss">The input slice stack.</param>
            <param name="x0">The x-index of the brick. Must be integer multiple of 16.</param>
            <param name="y0">The y-index of the brick. Must be integer multiple of 16.</param>
            <param name="z0">The z-index of the brick. Must be integer multiple of 16.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickThresholdInMask(System.UInt64[]@,System.Int16,Claron.WIF.SliceStack,System.Int32,System.Int32,System.Int32,System.UInt64[])">
            <summary>
            Only thresholds where the mask is set to 1, and clears the rest.
            Assumes the mask is NEVER set to 1 outside valid SliceStack bounds
            </summary>
            <param name="Brick"></param>
            <param name="thresholdCt">raw CT value threshold</param>
            <param name="ss">The SliceStack to threshold in.</param>
            <param name="x0"></param>
            <param name="y0"></param>
            <param name="z0"></param>
            <param name="brickWhereThresholdIsAllowed">A brick with 1 in the locations in which to apply threshold</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickLocalMinAtMask(System.UInt64[]@,Claron.WIF.ImageU12[],System.Int32,System.Int32,System.Int32,System.UInt64[])">
            <summary>
            Turns on all bits that are at local intensity minima in the SliceStack.
            A minimum is present if along any of the major axes the center value is below those of the two neighbors.
            Note: the MaskBrick MUST be turned off outside the volume and at x=0, x=Max, y=0, y=Max
            </summary>
            <param name="Brick"></param>
            <param name="sliceImages"></param>
            <param name="x0"></param>
            <param name="y0"></param>
            <param name="z0"></param>
            <param name="MaskBrick"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickSetStoredValAtMask(System.UInt64[],System.Int16,Claron.WIF.ImageU12[],System.Int32,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="Brick"></param>
            <param name="replaceValueRawCt">The Stored value to write</param>
            <param name="sliceImages"></param>
            <param name="x0">Base x of the brick</param>
            <param name="y0"></param>
            <param name="z0"></param>
            <returns>Whether any pixel was updated in that brick</returns>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickDilate(System.UInt64[]@,System.UInt64[],System.UInt64[],System.UInt64[],System.UInt64[],System.UInt64[],System.UInt64[],System.UInt64[])">
            <summary>
            Dilate in 6 directions where brickMaskWhereDilateIsAllowed is 1 and write the result to 
            brickDest
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickErode(System.UInt64[]@,System.UInt64[],System.UInt64[],System.UInt64[],System.UInt64[],System.UInt64[],System.UInt64[],System.UInt64[])">
            <summary>
            Erode where brickMaskWhereErodeIsAllowed is 1 and write the result to brickDest
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickDilateXy(System.UInt64[]@,System.UInt64[],System.UInt64[],System.UInt64[],System.UInt64[],System.UInt64[])">
            <summary>
            Dilate in X and Y only where brickMaskWhereDilateIsAllowed is 1 and write the result to brickDest
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickErodeXy(System.UInt64[]@,System.UInt64[],System.UInt64[],System.UInt64[],System.UInt64[],System.UInt64[])">
            <summary>
            Erode in X and Y only where brickMaskWhereErodeIsAllowed is 1 and write the result to brickDest
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickDilateX(System.UInt64[]@,System.UInt64[],System.UInt64[],System.UInt64[])">
            <summary>
            Dilate in X only where brickMaskWhereDilateIsAllowed is 1 and write the result to brickDest
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickDilateY(System.UInt64[]@,System.UInt64[],System.UInt64[],System.UInt64[])">
            <summary>
            Dilate in Y only where brickMaskWhereDilateIsAllowed is 1 and write the result to brickDest
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickErodeX(System.UInt64[]@,System.UInt64[],System.UInt64[],System.UInt64[])">
            <summary>
            Erode in X only where brickMaskWhereErodeIsAllowed is 1 and write the result to brickDest
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickDilateZ(System.UInt64[]@,System.UInt64[],System.UInt64[],System.UInt64[])">
            <summary>
            Dilate in Z only where brickMaskWhereDilateIsAllowed is 1 and write the result to brickDest
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickErodeZ(System.UInt64[]@,System.UInt64[],System.UInt64[],System.UInt64[])">
            <summary>
            Erode in Z only where brickMaskWhereErodeIsAllowed is 1 and write the result to brickDest
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickDilateInMask(System.UInt64[]@,System.UInt64[],System.UInt64[],System.UInt64[],System.UInt64[],System.UInt64[],System.UInt64[],System.UInt64[],System.UInt64[])">
            <summary>
            Dilate where brickMaskWhereDilateIsAllowed is 1 and write the result to brickDest
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickErodeInMask(System.UInt64[]@,System.UInt64[],System.UInt64[],System.UInt64[],System.UInt64[],System.UInt64[],System.UInt64[],System.UInt64[],System.UInt64[])">
            <summary>
            Erodes where brickMaskWhereErodeIsAllowed is 1 and write the result to brickDest
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickDilateXyInMask(System.UInt64[]@,System.UInt64[],System.UInt64[],System.UInt64[],System.UInt64[],System.UInt64[],System.UInt64[])">
            <summary>
            Dilate in X and Y only where brickMaskWhereDilateIsAllowed is 1 and write the result to brickDest
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickErodeXyInMask(System.UInt64[]@,System.UInt64[],System.UInt64[],System.UInt64[],System.UInt64[],System.UInt64[],System.UInt64[])">
            <summary>
            Erodes in X and Y only where brickMaskWhereErodeIsAllowed is 1 and write the result to brickDest
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickDilateXInMask(System.UInt64[]@,System.UInt64[],System.UInt64[],System.UInt64[],System.UInt64[])">
            <summary>
            Dilate in X only where brickMaskWhereDilateIsAllowed is 1 and write the result to brickDest
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickErodeXInMask(System.UInt64[]@,System.UInt64[],System.UInt64[],System.UInt64[],System.UInt64[])">
            <summary>
            Erodes in X only where brickMaskWhereErodeIsAllowed is 1 and write the result to brickDest
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickDilateZInMask(System.UInt64[]@,System.UInt64[],System.UInt64[],System.UInt64[],System.UInt64[])">
            <summary>
            Dilate in Z only where brickMaskWhereDilateIsAllowed is 1 and write the result to brickDest
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickErodeZInMask(System.UInt64[]@,System.UInt64[],System.UInt64[],System.UInt64[],System.UInt64[])">
            <summary>
            Erodes in Z only where brickMaskWhereErodeIsAllowed is 1 and write the result to brickDest
            </summary>
        </member>
        <member name="F:Claron.WIF.BitVol._numBricksX">
            <summary>
            The number of bricks in the x-direction.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.BitVol._numBricksPaddedX">
            <summary>
            The number of bricks in the x-direction including padding bricks.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.BitVol._numBricksY">
            <summary>
            The number of bricks in the y-direction.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.BitVol._numBricksPaddedY">
            <summary>
            The number of bricks in the y-direction including padding bricks.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.BitVol._numBricksZ">
            <summary>
            The number of bricks in the z-direction.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.BitVol._numBricksPaddedZ">
            <summary>
            The number of bricks in the z-direction including padding bricks.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.BitVol._brickOffsetDeltaY">
            <summary>
            The number of bricks in the x-direction (including padding bricks).
            Equal to the offset needed to move to the next y-position in the bit
            volume.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.BitVol._brickOffsetDeltaZ">
            <summary>
            The number of bricks in the x-y plane of voxels (including padding
            bricks). Equal to the offset needed to move to the next z-position
            in the bit volume.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.BitVol._brickOffset000">
            <summary>
            Offset to the first real brick (i.e. not a padding brick) in the bit
            volume.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.FillInExtrudedCurve(Claron.WIF.Curve,Claron.WIF.GridBox,Claron.WIF.BoxI32,System.Boolean)">
            <summary>
            Fills in the bit volume interior to the surface generated by
            extruding the (closed) curve in its GridBox Z direction (ie, perpendicular to its XY plane).
            </summary>
            <param name="Crv">The curve to be extruded, with point coordinates in grid INDEX coordinates.</param>
            <param name="CrvGrid">The grid on which the curve was drawn (eg, viewport or camera).
            Should be mapped to a PatientScanRcs shared with this BitVol</param>
            <param name="ClipBoxVi">An optional clipping bounding box in Bitvol index coordinates
            limiting the range of coordinates in which the bits are modified.
            If Nothing, it is ignored, ie, the full bitvol is used.</param>
            <param name="CloseCrv">If set to false and the Crv is not closed, only
            the curve itself will be extruded (not its interior)</param>
            <remarks>Uses a Manhattan distance map calculated from the curve to
            efficiently skip over bricks in the bit volume which need not be filled
            in. Also uses multiple threads on a multi-processor system.
            </remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.FillInExtrudedCurveWorkerThread(System.Int32,System.Int32,System.Object,System.Exception@)">
            <summary>
            Helper function to fill in an extruded curve
            </summary>
        </member>
        <member name="F:Claron.WIF.BitVol._brickOffsetPaddingGapXy">
            <summary>
            The number of bricks needed to move from the end of one row to the
            beginning of the next row in the bit volume.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.BitVol._brickOffsetPaddingGapYz">
            <summary>
            _brickOffsetPaddingGapYz + _brickOffsetPaddingGapXy = The number of
            bricks needed to move from the end of one plane to the beginning of the
            next plane in the bit volume.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.BitVol._brickOffsetLastInsideIdx">
            <summary>
            Offset to the last real brick (i.e. not a padding brick) in the bit
            volume.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.BitVol._brickOffsetLastPaddedIdx">
            <summary>
            Offset to the last brick (which is a padding brick) in the bit volume.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.DeriveUtilityFields">
            <summary>
            Sets the utility fields from the base fields
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.SwapMe(Claron.WIF.BitVol)">
            <summary>
            Swaps the content of this bitvol with the argument bitvol.
            </summary>
            <param name="vol">The BitVol to swap with.</param>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.BitVol._debugBvIdx">
            <summary> Global value for enabling debug serialization of BitVols (even in release mode, but turned off by default) </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.SerializeNameIdxStr(Claron.WIF.SliceStack,System.String)">
            <summary>
            saves the current bit vol in "d:/tmp/{patientName}_{DebugBvIdx}_{str}.bv"
            Set BitVol.DebugBvIdx to a value > 0 to enable this function
            Once enabled, thin function will autoincrement BitVol.DebugBvIdx such that consecutive calls yield new .bv files
            </summary>
            <param name="ss">the corresponding slicestack to get the patient name from</param>
            <param name="str">The BitVol state indicating comment strnig that will become part of the filename</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Serialize(System.String)">
            <summary>
            Serializes the bitvol to the specified file in a binary format
            </summary>
            <param name="filePath">Full path at which to serialize</param>
        </member>
        <member name="M:Claron.WIF.BitVol.DeSerialize(System.String)">
            <summary>
            DeSerializes from a file (binary format)
            </summary>
            <param name="filename">Full path from which to deserialize</param>
            <returns>The deserialized object</returns>
        </member>
        <member name="M:Claron.WIF.BitVol.LoadFromPmsDicomFiles(System.String,Claron.WIF.SliceStack)">
            <summary>
            Returns a dictionary of bitvols from the DICOM files stored in the
            given directory. The key of the dictionary is the name of the
            bitvol and the value of the dictionary is the bitvol.
            </summary>
            <param name="dirPath">The directory to search for bitvols.</param>
            <param name="ss">The slice stack associated with the bitvols.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.LoadFromPmsDicomFile(System.String,Claron.WIF.SliceStack,System.String@,Claron.WIF.BitVol@)">
            <summary>
            Loads a bitvol from a Philips DICOM file.
            </summary>
            <param name="filePath">The file to load the DICOM file from.</param>
            <param name="ss">The slice stack associated with the bitvol.</param>
            <param name="name">The name of the bitvol.</param>
            <param name="bv">The bitvol to load into.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.#ctor(Claron.WIF.GridBox)">
            <summary>
            Creates a new bit volume of the given size.
            </summary>
            <param name="grid">A GridBox describing the BitVol's dimension and (if set) its SpaceMapper to the PatientScanRCS.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new bit volume of the given size. The voxel spacing is set to default 1mm isotropic.
            </summary>
            <param name="dimX">The desired x dimension (Number of voxels).</param>
            <param name="dimY">The desired y dimension (Number of voxels).</param>
            <param name="dimZ">The desired z dimension (Number of voxels).</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.#ctor(Claron.WIF.Vector3_I32)">
            <summary>
            Creates a new bit volume of the given size. The voxel spacing is set to default 1mm isotropic.
            </summary>
            <param name="dims">The desired BitVol dimensions</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.#ctor(Claron.WIF.Vector3_I32,Claron.WIF.Vector3)">
            <summary>
            Creates a new bit volume of the give size and voxel spacing. The Grid is set to default values.
            </summary>
            <param name="dims">The BitVol dims.</param>
            <param name="spacingMm">The spacing between voxels in mm</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.#ctor(Claron.WIF.BitVol)">
            <summary>
            Creates a new empty bit volume by copying the state parameters from the
            given bit volume (bits are not copied).
            </summary>
            <param name="other">The bit volume to copy the state parameters
            from.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.#ctor(Claron.WIF.SliceStack)">
            <summary>
            Creates a new empty bit volume by copying state parameters from the given
            slice stack.
            </summary>
            <param name="ss">The slice stack to copy the state parameters from.
            </param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.#ctor(Claron.WIF.SliceStack,System.Double)">
            <summary>
            Creates a new bit volume by thresholding all the voxels in a given slice stack.
            If you need to threshold within a region, it is more efficient to first set the region,
            then call Threshold() for that region only.
            </summary>
            <param name="ss">The slice stack to be thresholded </param>
            <param name="thresholdModality">The threshold, as a modality value (not stored pixel value), 
            the lowest value at which the mask will be set to 1.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.#ctor(Claron.WIF.ImageU12,System.Double)">
            <summary>
            Creates a new single-plane (2D) bit volume by thresholding all the pixels in a 
            given image.
            </summary>
            <param name="image">The image to be thresholded </param>
            <param name="thresholdModality">The threshold, as a modality value (not stored pixel value), 
            the lowest value at which the mask will be set to 1.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.Init">
            <summary>
            Initializes the bit volume.
            </summary>
            <remarks>Calculates number of padding bricks needed, offsets, and
            sets all bricks to 0.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Clone">
            <summary>
            Returns an exact copy of this BitVol (with no sharing)
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.CopyFrom(Claron.WIF.BitVol)">
            <summary>
            copies the bits from another BitVol of the exact same dimensions
            </summary>
            <param name="src">the copy source</param>
        </member>
        <member name="M:Claron.WIF.BitVol.CopyFromSrcInBox(Claron.WIF.BitVol,Claron.WIF.BoxI32)">
            <summary>
            copies the bits from another BitVol,
            but only inside the provided box
            </summary>
            <param name="boxSi">The box inside which to do the copying, will copy the padding area outside the volume boundaries, if the box is that large.</param>
            <param name="src">the copy source</param>
        </member>
        <member name="M:Claron.WIF.BitVol.InitPlane(Claron.WIF.BitVol,Claron.WIF.BitVol.AxisEnum,System.Int32)">
            <summary>
            Assumes This object is empty, inits in This object the bitmask of section mask by plane
            orthogonal to axis defined by "axis" parameter, cutting it at the "axisValue"
            </summary>
            <param name="mask"></param>
            <param name="axis"></param>
            <param name="axisValue">Default value = 0</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.InitPlaneRegion(Claron.WIF.Vector3_I32,Claron.WIF.BitVol.AxisEnum,System.Int32)">
            <summary>
            Assumes This object is empty, inits in This object the bitmask in plane orthogonal to axis
            and containing centerRegion voxel. Voxels in that plane at distance smaller than radRegion
            from centerRegion are turned to true.
            </summary>
            <param name="centerRegion"></param>
            <param name="axis"></param>
            <param name="radRegion"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ProjectToXYPlane(Claron.WIF.BitVol,System.Int32)">
            <summary>
            Projects mask bitvol to me, which is plane BitVol at z = 0
            </summary>
            <param name="mask"></param>
            <param name="zPlane">Default value = 0</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ProjectToXYPlaneLimits(Claron.WIF.BitVol,System.Int32,System.Int32,System.Int32)">
             <summary>
            
             </summary>
             <param name="mask"></param>
             <param name="bgnZ"></param>
             <param name="endZ"></param>
             <param name="zPlane">Default value = 0</param>
             <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ClearPlane(Claron.WIF.BitVol.AxisEnum,System.Int32)">
            <summary>
            Clears the bits in a plane, defined by axis and axisValue
            </summary>
            <param name="axis">The axis perpendicular to the plane</param>
            <param name="axisValue">The coordinate value along that axis</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.CopyPlane(Claron.WIF.BitVol.AxisEnum,System.Int32,Claron.WIF.BitVol)">
            <summary>
            Copies the bits in a plane, defined by axis and axisValue, from another bitvol of identical dimensions
            </summary>
            <param name="axis">The axis perpendicular to the plane</param>
            <param name="axisValue">The 0-based coordinate value along that axis.</param>
            <param name="OtherBvSameDims"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.CopyAboveXZSurface(Claron.WIF.BitVol,Claron.WIF.ImageU12,System.Int32[],System.Int32[],Claron.WIF.BoxI32)">
            <summary>
            Copies the srcMask into This mask only in the surfaceBox above surface, defined by ImageU12
            in XZ coordinates. The pixel (X, Y, Z) is considered above the surface while
            Y > surface(X, Z). For the performance purposes the precomputed limits of the surface
            per brick surfaceMin and surfaceMax are used.
            </summary>
            <param name="srcMask"></param> mask to be copied
            <param name="surface"></param> cutting surface
            <param name="surfaceMin"></param> the Lower limit of surface per brick
            <param name="surfaceMax"></param> the Upper limit of surface per brick
            <param name="surfaceBox"> In case Default value = null is passed
            the surfaceBox is computed as Box comprising the whole srcMask </param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.CopyBelowXZSurface(Claron.WIF.BitVol,Claron.WIF.ImageU12,System.Int32[],System.Int32[],Claron.WIF.BoxI32)">
            <summary>
            Copies the srcMask into This mask only in the surfaceBox below surface, defined by ImageU12
            in XZ coordinates. The pixel (X, Y, Z) is considered below the surface while
            Y smaller than surface(X, Z). For the performance purposes the precomputed limits of the
            surface per brick surfaceMin and surfaceMax are used.
            </summary>
            <param name="srcMask"></param> mask to be copied
            <param name="surface"></param> cutting surface
            <param name="surfaceMin"></param> the Lower limit of surface per brick
            <param name="surfaceMax"></param> the Upper limit of surface per brick
            <param name="surfaceBox"> In case Default value = null is passed
            the surfaceBox is computed as Box comprising the whole srcMask </param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.CopyAboveYZSurface(Claron.WIF.BitVol,Claron.WIF.ImageU12,System.Int32[],System.Int32[],Claron.WIF.BoxI32)">
            <summary>
            Copies the srcMask into This mask only in the surfaceBox above surface, defined by ImageU12
            in YZ coordinates. The pixel (X, Y, Z) is considered above the surface while
            X > surface(X, Z). For the performance purposes the precomputed limits of the surface
            per brick surfaceMin and surfaceMax are used.
            </summary>
            <param name="srcMask"></param> mask to be copied
            <param name="surface"></param> cutting surface
            <param name="surfaceMin"></param> the Lower limit of surface per brick
            <param name="surfaceMax"></param> the Upper limit of surface per brick
            <param name="surfaceBox"> In case Default value = null is passed
            the surfaceBox is computed as Box comprising the whole srcMask </param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.CopyBelowYZSurface(Claron.WIF.BitVol,Claron.WIF.ImageU12,System.Int32[],System.Int32[],Claron.WIF.BoxI32)">
             <summary>
             Copies the srcMask into This mask only in the surfaceBox below surface, defined by ImageU12
             in YZ coordinates. The pixel (X, Y, Z) is considered above the surface while
             X smaller than surface(X, Z). For the performance purposes the precomputed limits of
             the surface per brick surfaceMin and surfaceMax are used.
             </summary>
             <param name="srcMask"></param> mask to be copied
             <param name="surface"></param> cutting surface
             <param name="surfaceMin"></param> the Lower limit of surface per brick
             <param name="surfaceMax"></param> the Upper limit of surface per brick
             <param name="surfaceBox"> In case Default value = null is passed
             the surfaceBox is computed as Box comprising the whole srcMask </param>
             <remarks></remarks>
            
        </member>
        <member name="M:Claron.WIF.BitVol.ClearBricksPlane(Claron.WIF.BitVol.AxisEnum,System.Int32)">
             <summary>
            
             </summary>
             <param name="axis"></param>
             <param name="axisValue">Default value = 0</param>
             <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.GetPosFromOffsets(Claron.WIF.I28BrickCubeVoxel)">
            <summary>
            Returns the x-, y-, z-voxel coordinate values given the brick, cube,
            and voxel indices encoded as a Triple.
            </summary>
            <param name="offsets">The brick, cube and voxel indices encoded as
            a Triple.</param>
            <returns>The x-, y-, and z-voxel coordinate values as a Triple.</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.GetPosFromOffsets(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the x-, y-, z-voxel coordinate values given the brick, cube,
            and voxel indices.
            </summary>
            <param name="brickI">The brick index.</param>
            <param name="cubeI">The cube index.</param>
            <param name="bitI">The voxel index.</param>
            <returns>The x-, y-, and z-voxel coordinate values as a Triple.</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.PosFromLinearOffset(System.Int32)">
            <summary>
            Converts a linear memory offset into the corresponding Xyz position.
            </summary>
            <param name="offset">The linear memory offset where (0,0,0) is at offset 0.</param>
            <returns>The x,y,z-voxel coordinate as Vector3_I32.</returns>
        </member>
        <member name="M:Claron.WIF.BitVol.IsBrickAllOutsideVolume(System.Int32)">
            <summary>
            Indicates whether the given brick is completely outside the volume bounds.
            </summary>
            <param name="idx">Brick index</param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.BitVol.IsBrickInsideVolume(System.Int32)">
            <summary>
            True if brick is fully or partially overlapping with volume grid
            </summary>
            <param name="idx">Brick index</param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.BitVol.IsBrickAllInsideVolume(System.Int32)">
            <summary>
            Indicates whether the given brick is completely inside the volume bounds.
            </summary>
            <param name="idx">Brick index</param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.BitVol.IsBrickAllOutsideBox(System.Int32,Claron.WIF.BoxI32)">
            <summary>
            Indicates whether the given brick is completely outside the given bounding box.
            </summary>
            <param name="idx">Brick index</param>
            <param name="bBox">The box to test against</param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.BitVol.IsBrickAllInsideBox(System.Int32,Claron.WIF.BoxI32)">
            <summary>
            Indicates whether the given brick is completely inside a given box.
            </summary>
            <param name="idx">Brick index</param>
            <param name="bBox">The box to test against</param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickPaddingClear(System.Int32)">
            <summary>
            If needed, clears (sets to 0) the voxels outside the volume bounds (or returns quickly if the
            brick is inside the bounds or empty).
            </summary>
            <param name="brickI">The brick's index</param>
        </member>
        <member name="M:Claron.WIF.BitVol.BitGet(Claron.WIF.Vector3)">
            <summary>
            Sets/gets the bit at the nearest integer grid index location to the vector coordinates.
            Will generate an exception if posIndex is outside the bitvol index coordinate range.
            </summary>
            <param name="posIndex"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.BitSet(Claron.WIF.Vector3,System.Boolean)">
            <summary>
            Sets/gets the bit at the nearest integer grid index location to the vector coordinates.
            Will generate an exception if posIndex is outside the bitvol index coordinate range.
            </summary>
            <param name="posIndex"></param>
            <param name="NewValue"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.BitSet(Claron.WIF.Vector3_I32)">
            <summary>
            Sets the bit to true (or 1)
            </summary>
            <param name="pos"></param>
        </member>
        <member name="M:Claron.WIF.BitVol.BitsGet(Claron.WIF.I28BrickCubeVoxel[])">
            <summary>
            Returns an array of values at input locations (eg, seeds). The values match the locations by index
            of course.
            </summary>
            <param name="ibcvs"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.BitVol.Clear">
            <summary>
            clears all bricks ( inside and padding )
            </summary>
            <remarks> 4ms for 511 slice dataset </remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ClearInBox(Claron.WIF.BoxI32)">
            <summary>
            Clears the bits inside the box.
            </summary>
            <param name="boxSi">The box inside which to do the clearing, will clear the padding area outside the volume boundaries, if the box is that large.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.ClearOutsideBox(Claron.WIF.BoxI32)">
            <summary>
            Clears the bits outside the box.
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.ClearOutermostVoxelLayer">
            <summary>
            Clears one layer of voxels on all 6 sides of the BitVol
            </summary>
            <remarks>Can become private if VolOps becomes a Partial BitVol class</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Invert">
            <summary>
            Inverts the bits (keeping the padding layers clear)
            </summary>
            <returns>This BitVol</returns>
            <remarks>
            511 slice; 4ms bone
            511 slice; 5ms body
            511 slice; 8ms muscle
            </remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Inverted">
            <summary>
            Returns an inverted copy of this BitVol, leaving this intact (unlike Invert).
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.InvertInBox(Claron.WIF.BoxI32)">
            <summary>
            Inverts the bits inside the box.
            </summary>
            <param name="boxSi">The box inside which to do the inverting, will invert the padding area outside the volume boundaries, if the box is that large.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.InvertIncludingPadding">
            <summary>
            inverts all bricks (inside AND the padding layers!!).
            In most cases, Invert is preferable.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Fill">
            <summary>
            Fills the entire BitVol, but not the padding.
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.FillInBox(Claron.WIF.BoxI32)">
            <summary>
            Fills the bits inside the box.
            </summary>
            <param name="boxSi">The box inside which to do the filling, will fill the padding area outside the volume boundaries, if the box is that large.</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.FillOutsideBox(Claron.WIF.BoxI32)">
            <summary>
            Fills the bits outside the box.
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.BoxSubBrickTraverseUnaryOp(Claron.WIF.BoxI32,Claron.WIF.BitVol.OperationOnFullBrick,Claron.WIF.BitVol.OperationOnBrickWithinMask)">
            <summary>
            Traverses the BitVol within the box.
            Pays efficient attention to the potentially sub-brick box boundary.
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.BoxSubBrickTraverseBinaryOp(Claron.WIF.BitVol,Claron.WIF.BoxI32,System.Int32,Claron.WIF.BitVol.OperationBinaryOnFullBrick,Claron.WIF.BitVol.OperationBinaryOnBrickWithinMask)">
            <summary>
            Traverses the BitVol within the box.
            Pays efficient attention to the potentially sub-brick box boundary.
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.BoxSubBrickTraverseOutside(Claron.WIF.BoxI32,Claron.WIF.BitVol.OperationOnFullBrick,Claron.WIF.BitVol.OperationOnBrickWithinMask)">
            <summary>
            Traverses the BitVol outside the box.
            Pays efficient attention to the potentially sub-brick box boundary.
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.OverlappingBricksRange(Claron.WIF.BitVol,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Computes the brick index range overlap and index offset between this and another bitvol based on
            the grid boxes Z positions in space.
            </summary>
            <param name="other"></param>
            <param name="inOutMeBrickBgnI">Set by the caller as the lower limit, modified as output</param>
            <param name="inOutMeBrickEndI">Set by the caller as the upper limit, modified as output</param>
            <param name="outBrickIOffsetFromMeToOther"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickBorderId(Claron.WIF.Vector3_I32,Claron.WIF.BoxI32,Claron.WIF.BoxI32)">
            <summary>
            Returns a border Id that indicates if we are in the center region of the boxes (inside both, ID=0)
            or at the border, within outer but outside inner box. The code is unique for each side/edge/corner border location.
            </summary>
            <param name="posSi">The minimum corner of the brick for which the border code should be generated.</param>
            <param name="boxOuter">The brick aligned outer box.</param>
            <param name="boxInner">The brick aligned inner box.</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.CalculateBrickFaceMinX">
            <summary>
            Returns a brick with a layer of bits turned on, starting at the MinX side.
            The argument specifies how many bits the layer is thick.
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.CalculateBrickFaceMaxX">
            <summary>
            Returns a brick with a layer of bits turned on, starting at the MaxX side.
            The argument specifies how many bits the layer is thick.
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.CalculateBrickFaceMinY">
            <summary>
            Returns a brick with a layer of bits turned on, starting at the MinY side.
            The argument specifies how many bits the layer is thick.
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.CalculateBrickFaceMaxY">
            <summary>
            Returns a brick with a layer of bits turned on, starting at the MaxY side.
            The argument specifies how many bits the layer is thick.
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.CalculateBrickFaceMinZ">
            <summary>
            Returns a brick with a layer of bits turned on, starting at the MinZ side.
            The argument specifies how many bits the layer is thick.
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.CalculateBrickFaceMaxZ">
            <summary>
            Returns a brick with a layer of bits turned on, starting at the MaxZ side.
            The argument specifies how many bits the layer is thick.
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.BitwiseAnd(Claron.WIF.BitVol)">
            <summary>
            This = This AND other
            AND of the bits from the other BitVol onto this-BitVol for all allocated BitVol bricks.
            The Me-BitVol is modified in place and for convenience also returned as function result.
            If this-BitVol and the other-BitVol are made for different (brick-aligned) sub-SliceStacks
            of the same source SliceStack, then the region of effect is automatically cropped to the
            overlapping range of both BitVols.
            </summary>
            <param name="otherBv">The operand BitVol.</param>
            <returns>this BitVol</returns>
        </member>
        <member name="M:Claron.WIF.BitVol.BitwiseAndInBox(Claron.WIF.BitVol,Claron.WIF.BoxI32)">
            <summary>
            this = this AND other
            AND of the bits from the other BitVol onto the this-BitVol but only inside the box.
            The this-BitVol is modified in place and for convenience also returned as function result.
            If the this-BitVol and the other-BitVol are made for different (brick-aligned) sub-SliceStacks
            of the same source SliceStack, then the region of effect is automatically cropped to the
            overlapping range of both BitVols.
            </summary>
            <param name="otherBv">The operand BitVol.</param>
            <param name="boxSi">The box inside which to do the AND, will AND the padding area outside the volume boundaries, if the box is that large.</param>
            <returns>this BitVol</returns>
        </member>
        <member name="M:Claron.WIF.BitVol.BitwiseOr(Claron.WIF.BitVol)">
            <summary>
            this = this OR other
            OR of the bits from the other BitVol onto the this-BitVol for all allocated BitVol bricks.
            The this-BitVol is modified in place and for convenience also returned as function result.
            If the this-BitVol and the other-BitVol are made for different (brick-aligned) sub-SliceStacks
            of the same source SliceStack, then the region of effect is automatically cropped to the
            overlapping range of both BitVols.
            </summary>
            <param name="otherBv">The operand BitVol.</param>
            <returns>this BitVol</returns>
        </member>
        <member name="M:Claron.WIF.BitVol.BitwiseOrInBox(Claron.WIF.BitVol,Claron.WIF.BoxI32)">
            <summary>
            this = this OR other
            OR of the bits from the other BitVol onto the this-BitVol but only inside the box.
            The this-BitVol is modified in place and for convenience also returned as function result.
            If the this-BitVol and the other-BitVol are made for different (brick-aligned) sub-SliceStacks
            of the same source SliceStack, then the region of effect is automatically cropped to the
            overlapping range of both BitVols.
            </summary>
            <param name="otherBv">The operand BitVol.</param>
            <param name="boxSi">The box inside which to do the OR, will OR the padding area outside the volume boundaries, if the box is that large.</param>
            <returns>this BitVol</returns>
        </member>
        <member name="M:Claron.WIF.BitVol.BitwiseXor(Claron.WIF.BitVol)">
            <summary>
            this = this XOR other
            XOR of the bits from the other BitVol onto the this-BitVol for all allocated BitVol bricks.
            The this-BitVol is modified in place and for convenience also returned as function result.
            If the this-BitVol and the other-BitVol are made for different (brick-aligned) sub-SliceStacks
            of the same source SliceStack, then the region of effect is automatically cropped to the
            overlapping range of both BitVols.
            </summary>
            <param name="otherBv">The operand BitVol.</param>
            <returns>this BitVol</returns>
        </member>
        <member name="M:Claron.WIF.BitVol.BitwiseXorInBox(Claron.WIF.BitVol,Claron.WIF.BoxI32)">
            <summary>
            this = this XOR other
            XOR of the bits from the other BitVol onto the this-BitVol but only inside the box.
            The this-BitVol is modified in place and for convenience also returned as function result.
            If the this-BitVol and the other-BitVol are made for different (brick-aligned) sub-SliceStacks
            of the same source SliceStack, then the region of effect is automatically cropped to the
            overlapping range of both BitVols.
            </summary>
            <param name="otherBv">The operand BitVol.</param>
            <param name="boxSi">The box inside which to do the XOR, will XOR the padding area outside the volume boundaries, if the box is that large.</param>
            <returns>this BitVol</returns>
        </member>
        <member name="M:Claron.WIF.BitVol.BitwiseAndNot(Claron.WIF.BitVol)">
            <summary>
            this = this AND (NOT other) (ie, subtract the other)
            AndNot of the bits from the other BitVol onto the this-BitVol for all allocated BitVol bricks.
            The this-BitVol is modified in place and for convenience also returned as function result.
            If the this-BitVol and the other-BitVol are made for different (brick-aligned) sub-SliceStacks
            of the same source SliceStack, then the region of effect is automatically cropped to the
            overlapping range of both BitVols.
            </summary>
            <param name="otherBv">The operand BitVol.</param>
            <returns>this BitVol</returns>
        </member>
        <member name="M:Claron.WIF.BitVol.Subtract(Claron.WIF.BitVol)">
            <summary>
            Subtract another bitvol from this one (same as BitwiseAndNot).
            The this-BitVol is modified in place and for convenience also returned as function result.
            If the this-BitVol and the other-BitVol are made for different (brick-aligned) sub-SliceStacks
            of the same source SliceStack, then the region of effect is automatically cropped to the
            overlapping range of both BitVols.
            </summary>
            <param name="otherBv">The operand BitVol.</param>
            <returns>this BitVol</returns>
        </member>
        <member name="M:Claron.WIF.BitVol.BitwiseAndNotInBox(Claron.WIF.BitVol,Claron.WIF.BoxI32)">
            <summary>
            this = this AND (NOT other)
            AndNot of the bits from the other BitVol onto the this-BitVol but only inside the box.
            The this-BitVol is modified in place and for convenience also returned as function result.
            If the this-BitVol and the other-BitVol are made for different (brick-aligned) sub-SliceStacks
            of the same source SliceStack, then the region of effect is automatically cropped to the
            overlapping range of both BitVols.
            </summary>
            <param name="otherBv">The operand BitVol.</param>
            <param name="boxSi">The box inside which to do the AND NOT, will AND NOT the padding area outside the volume boundaries, if the box is that large.</param>
            <returns>this BitVol</returns>
        </member>
        <member name="M:Claron.WIF.BitVol.op_BitwiseOr(Claron.WIF.BitVol,Claron.WIF.BitVol)">
            <summary>
            Performs Bitwise OR between the two BitVols. 
            The result is returned in a new BitVol.
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.op_BitwiseAnd(Claron.WIF.BitVol,Claron.WIF.BitVol)">
            <summary>
            Performs bitwise AND between the two BitVols
            The result is returned in a new BitVol.
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.op_ExclusiveOr(Claron.WIF.BitVol,Claron.WIF.BitVol)">
            <summary>
            Performs bitwise XOR between the two BitVols
            The result is returned in a new BitVol.
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.op_Addition(Claron.WIF.BitVol,Claron.WIF.BitVol)">
            <summary>
            Performs Bitwise OR between the two BitVols
            The result is returned in a new BitVol.
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.op_Subtraction(Claron.WIF.BitVol,Claron.WIF.BitVol)">
            <summary>
            Performs bitwise AndNot between the two BitVols
            The result is returned in a new BitVol.
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.Eliminate1VoxelHalo(Claron.WIF.BitVol)">
            <summary>
            Move voxels from this volume to otherVol if they are adjacent to otherVol and only one voxel thick
            </summary>
            <param name="otherVol">The volume to move the thin slivers on this to.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Eliminate1VoxelSlivers">
            <summary>
            Remove voxels from this volume if they are part of a one voxel thick sliver
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Eliminate1VoxelSlivers(Claron.WIF.BoxI32)">
            <summary>
            Remove voxels from this volume if they are part of a one voxel thick sliver
            </summary>
            <param name="boxOfChange">Default value = null</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.PaddingClear">
            <summary>
            Clears the extra bits beyond the boundaries of the bitvol. Currently very
            inefficient for X or Y dimensions that are not multiples of 16 !
            </summary>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.BitVol.Threshold(System.Double,Claron.WIF.SliceStack)">
            <summary>
            threshold the given SliceStack at given modailty value (set all mask pixels to 1 if modality value >= threshold)
            </summary>
            <param name="thresholdModality">The threshold, as a modality value (not stored pixel value), 
            the lowest value at which the mask will be set to 1.</param>
            <param name="ss">The SliceStack to threshold in.</param>
            <remarks>310ms for 1000 slice head and neck, 150Hu threshold, 2.7GHz i7-920 CPU</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Threshold(System.Double,System.Double,Claron.WIF.SliceStack)">
            <summary>
            Thresholds the given slice stack so that all voxels which have a value between
            minModality and maxModality (inclusive) have their corresponding bits turned on.
            </summary>
            <param name="minModality">The min modality value.</param>
            <param name="maxModality">The max modality value.</param>
            <param name="ss">The slice stack to threshold.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.ThresholdInBox(System.Double,Claron.WIF.SliceStack,Claron.WIF.BoxI32)">
            <summary>
            
            threshold the given SliceStack at given stored value (set all mask pixels to 1 if stored value >= threshold),
            but only inside the constraining ROI box.
            </summary>
            <param name="thresholdModality">The threshold, as a modality value (not stored pixel value), the lowest value at which the mask will be set to 1.</param>
            <param name="ss">The SliceStack to threshold in.</param>
            <param name="boxSi">The box inside which to do the thresholding, will be reduced to the intersection with the volume bounding box.</param>
            <remarks>310ms for 1000 slice head and neck, 150Hu threshold, 2.7GHz i7-920 CPU</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ThresholdInMask(System.Double,Claron.WIF.SliceStack,Claron.WIF.BitVol)">
            <summary>
            threshold the given SliceStack at given value (set all mask pixels to 1 if stored value >= threshold),
            but only at the turned on voxels of the constraining ROI bvMask.
            </summary>
            <param name="thresholdModality">The threshold, as a modality value (not stored pixel value), the lowest value at which the mask will be set to 1.</param>
            <param name="ss">The SliceStack to threshold in.</param>
            <param name="whereToThresholdMask">the BitVol constraining the thresholding (where thresholding is allowed).
            This can be the same BitVol as this BitVol, in which case this BitVol gets reduced to the voxels above the threshold.</param>
            <remarks>150ms for 1000 slice head and neck, 350Hu threshold, within 150Hu threshold mask, 2.7GHz i7-920 CPU</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ThresholdClearAbove(System.Double,Claron.WIF.SliceStack)">
            <summary>
            Resets bits with SliceStack modality value >= threshold. This function can be used in conjunction with Threshold*
            functions to perform (>=min, "less than" max) thresholding. Example: to threshold in the range (10, 100) use Threshold(10, ss); ThresholdClearAbove(100,ss).
            </summary>
            <param name="thresholdModality">The threshold, as a modality value (not stored pixel value), above which the mask bits will be reset to 0.</param>
            <param name="ss">The SliceStack to threshold in.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.LocalMinAtMask(Claron.WIF.SliceStack,Claron.WIF.BitVol)">
            <summary>
            Turns on all bits that are at local intensity minima in the SliceStack.
            A minimum is present if along any of the major axes the center value is below those of the two neighbors.
            Note: the whereToLookMask MUST be turned off outside the volume and at x=0, x=Max, y=0, y=Max, but not at z=0 or z=max
            </summary>
            <param name="ss"></param>
            <param name="whereToLookMask"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.SetModalityValAtMask(System.Double,Claron.WIF.SliceStack,System.Int32[])">
            <summary>
            replaces all voxel values at the places the mask is turned on.
            If the mask is not empty, the LastUpdateTicks of all slice images is updated.
            </summary>
            <param name="modalityVal">The replacement value in modality values, i.e. HU for CT.</param>
            <param name="ss">The SliceStack to modify</param>
            <param name="values">The values to set</param>
        </member>
        <member name="M:Claron.WIF.BitVol.SetStoredValAtMask(System.Int16,Claron.WIF.ImageU12[])">
            <summary>
            replaces all voxel values at the places the mask is turned on.
            If the mask is not empty, the LastUpdateTicks of all slice images is updated.
            </summary>
            <param name="StoredValue">replacement value in stored (not modality) units</param>
            <param name="sliceImages"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeMmPreserveStrongEdge(Claron.WIF.SliceStack,System.Double)">
            <summary>
            Erode at most as much as given in argument, preserving strong edges - see explanation in next function
            </summary>
            <param name="ss"></param>
            <param name="mm"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodePreserveStrongEdge(Claron.WIF.SliceStack)">
            <summary>
            Erode one layer of boundary voxels, preserving those, which are laying on strong edge coinciding with
            mask boundary. The edge is defined at those voxels where the following conditions hold:
            high CT-value gradient > 500 and value in current pos higher than in previous pos in gradient direction;
            If the edge coincides with the mask boundary the voxels on the both sides of the current pos on the line
            defined by direction of max gradient couldn't be inside the mask. Then, if this condition holds for certain
            boundary voxel, it can be eroded.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeLowContrastConnection(Claron.WIF.SliceStack)">
            <summary>
            Erode only voxels laying on the edge which doesn't coincide with mask boundary
            </summary>
            <param name="ss"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.DilateMmAccurate(System.Double)">
             <summary>
             Dilates this BitVol into the result BitVol by the given mm amount, defined as the
             the Euclidean distance to the nearest 1 voxel.
            
             This BitVol is not modified, and all voxels of this BitVol will be turned on in the result BitVol.
             
             Runs slower than DilateMm. For relatively compact shapes, execution time is usually 2-4X. For 
             large complex shapes, the ratio can grow up to 50X. For small dilations of 1-3 voxels, the two 
             functions produce nearly identical results, so DilateMm is preferable because of its higher
             performance.
             </summary>
             <param name="mm">How far to dilate away from the centers of the voxels on the outer
             Surface of the bitvol. In other words, all voxels in the bitvol with a Euclidean distance 
             equal or less than this value to a 1-voxel before the operation will be turned to 1 too.</param>
             <remarks>Uses a highly efficient front propagation ("grass fire") algorithm, with run time 
             proportional to the number of voxels being added.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.DilateMm(System.Double)">
            <summary>
            Dilates this BitVol into the result BitVol by the given mm amount using iterative discrete
            1-voxel dilations. This is very fast, but inaccurate, resulting in visible diamond-like patterns 
            when the dilation is more then 3-4 voxels thick.
            
            See DilateMmAccurate for a slower, but more accurate, alternative.
            </summary>
            <param name="mm">how far to dilate in L1 norm or Manhattan distance. Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.DilateMmInBox(System.Double,Claron.WIF.BoxI32)">
             <summary>
             Dilates this BitVol into the result BitVol by the given mm amount using iterative discrete
             1-voxel dilations. This is very fast, but inaccurate, resulting in visible diamond-like patterns 
             when the dilation is more then 3-4 voxels thick.
            
             New voxels are only added if they are inside the box whereDilateIsAllowedBoxSi.
             This BitVol is not modified, and all voxels of this BitVol will be turned on in the result BitVol,
             even if they are not inside the box whereDilateIsAllowedBoxSi.
             </summary>
             <param name="mm">how far to dilate in L1 norm or Manhattan distance. Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
             <param name="whereDilateIsAllowedBoxSi">where dilation to is allowed, affects only newly to be added voxels,
             so does not delete anything of the original bits.
             Regardless of box size, padding voxels will be turned off at the end of the operation.</param>
             <remarks>Not efficient for large mm values, i.e. greater than 10.  Does not handle voxel spacing x != y.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.DilateMmInMaskAccurate(System.Double,Claron.WIF.BitVol)">
             <summary>
             Dilates this BitVol into the result BitVol by the given mm amount, defined as the
             the distance to the nearest 1 voxel.
            
             This BitVol is not modified, and all voxels of this BitVol will be turned on in the result BitVol.
             
             Runs slower than DilateMmInMask. For relatively compact shapes, execution time is usually 2-4X. For 
             large complex shapes, the ratio can grow up to 50X. For small dilations of 1-3 voxels, the two 
             functions produce nearly identical results, so DilateMm is preferable because of its higher
             performance.
             </summary>
             <param name="mm">How far to dilate away from the centers of the voxels on the outer
             Surface of the bitvol. In other words, all voxels in the bitvol with a Euclidean distance 
             equal or less than this value to a 1-voxel before the operation will be turned to 1 too.</param>
             <param name="whereDilateIsAllowedMaskBv">Where dilation to is allowed. Affects 
             only newly to be added voxels, so does not delete anything of the original bits. If null, it is
             ignored.</param>
             <remarks>Uses an efficient front propagation ("grass fire") algorithm, with run time 
             proportional to the number of voxels being added.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.DilateMmInMask(System.Double,Claron.WIF.BitVol)">
             <summary>
             Dilates this BitVol into the result BitVol by the given mm amount.
             In case it is not a multiple of the voxel spacing, the closest matching multiple is used,
             since the implementation is a loop of discrete single layer dilations.
            
             New voxels are only added if they are already present in the mask whereDilateIsAllowedMaskBv.
             This BitVol is not modified, and all voxels of this BitVol will be turned on in the result BitVol,
             even if they are not turned on in the mask whereDilateIsAllowedMaskBv.
             </summary>
             <param name="mm">how far to dilate in L1 norm or Manhattan distance. Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
             <param name="whereDilateIsAllowedMaskBv">where dilation to is allowed, affects only newly to be added voxels,
             so does not delete anything of the original bits</param>
             <remarks>Not efficient for large mm values, i.e. greater than 10.  Does not handle voxel spacing x != y.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeMm(System.Double)">
             <summary>
             Erodes this BitVol into the result BitVol by the given mm amount.
             In case it is not a multiple of the voxel spacing, the closest matching multiple is used,
             since the implementation is a loop of discrete single layer erosions.
             However, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is not eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will keep its full height,
             but become one voxel layer slimmer.
            
             This BitVol is not modified.
             </summary>
             <param name="mm">how far to Erode in L1 norm or Manhattan distance. Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
             <remarks>Not efficient for large mm values, i.e. greater than 10.  Does not handle voxel spacing x != y.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeMmAccurate(System.Double)">
             <summary>
             Erodes this BitVol into the result BitVol by the given mm amount. This BitVol is not modified.
            
             Voxels are only removed if they do not touch the volume boundary. 
             
             Slower than ErodeMm. Since it produces very similar results for erosions of less than 
             5 voxels, use it only only when erosions are large and accuracy is important.
             </summary>
             <param name="mm">how far to Erode in mm.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeMmEatVolumeBoundary(System.Double)">
             <summary>
             Erodes this BitVol into the result BitVol by the given mm amount.
             In case it is not a multiple of the voxel spacing, the closest matching multiple is used,
             since the implementation is a loop of discrete single layer erosions.
             Note, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is also eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will shrink in height and thickness.
            
             This BitVol is not modified.
             </summary>
             <param name="mm">how far to Erode in L1 norm or Manhattan distance. Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
             <remarks>Not efficient for large mm values, i.e. greater than 10.  Does not handle voxel spacing x != y.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeMmInBox(System.Double,Claron.WIF.BoxI32)">
             <summary>
             Erodes this BitVol into the result BitVol by the given mm amount.
             In case it is not a multiple of the voxel spacing, the closest matching multiple is used,
             since the implementation is a loop of discrete single layer erosions.
             However, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is not eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will keep its full height,
             but become one voxel layer slimmer.
            
             Voxels are only removed if they are inside the box whereErodeIsAllowedBoxSi.
             This BitVol is not modified.
             Outside the box whereErodeIsAllowedBoxSi the operation is a straight copy.
             </summary>
             <param name="mm">how far to Erode in L1 norm or Manhattan distance. Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
             <param name="whereErodeIsAllowedBoxSi">where erosion is allowed.
             A voxel on in this BitVol must be inside whereErodeIsAllowedBoxSi so it can be turned off in the result.</param>
             <remarks>Not efficient for large mm values, i.e. greater than 10.  Does not handle voxel spacing x != y.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeMmInBoxEatVolumeBoundary(System.Double,Claron.WIF.BoxI32)">
             <summary>
             Erodes this BitVol into the result BitVol by the given mm amount.
             In case it is not a multiple of the voxel spacing, the closest matching multiple is used,
             since the implementation is a loop of discrete single layer erosions.
             Note, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is also eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will shrink in height and thickness.
            
             Voxels are only removed if they are inside the box whereErodeIsAllowedBoxSi.
             This BitVol is not modified.
             Outside the box whereErodeIsAllowedBoxSi the operation is a straight copy.
             </summary>
             <param name="mm">how far to Erode in L1 norm or Manhattan distance. Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
             <param name="whereErodeIsAllowedBoxSi">where erosion is allowed.
             A voxel on in this BitVol must be inside whereErodeIsAllowedBoxSi so it can be turned off in the result.</param>
             <remarks>Not efficient for large mm values, i.e. greater than 10.  Does not handle voxel spacing x != y.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeMmInMask(System.Double,Claron.WIF.BitVol)">
             <summary>
             Erodes this BitVol into the result BitVol by the given mm amount using iterative discrete
             layers erosions (in XY or in XYZ).
             In case it is not a multiple of the voxel spacing, the closest matching multiple is used,
             since the implementation is a loop of discrete single layer erosions.
             However, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is not eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will keep its full height,
             but become slimmer.
            
             Voxels are only removed if they are present in the mask whereErodeIsAllowedMaskBv.
             This BitVol is not modified.
             Outside the mask whereErodeIsAllowedMaskBv the operation is a straight copy.
             </summary>
             <param name="mm">how far to Erode in L1 norm or Manhattan distance. 
             Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
             <param name="whereErodeIsAllowedMaskBv">where erosion is allowed, needs to be on in 
             mask so it can be turned off in result.</param>
             <remarks>Does not handle voxel spacing x != y.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeMmInMaskAccurate(System.Double,Claron.WIF.BitVol)">
             <summary>
             Erodes this BitVol into the result BitVol by the given mm amount. This BitVol is not modified.
            
             Voxels are only removed if they are present in the mask whereErodeIsAllowedMaskBv and
             do not touch the volume boundary. Outside the mask whereErodeIsAllowedMaskBv the operation is a straight copy.
             
             Slower than ErodeMmInMask. Since it produces very similar results for erosions of less than 
             5 voxels, use it only only when erosions are large and accuracy is very important.
             </summary>
             <param name="mm">how far to Erode in mm.</param>
             <param name="whereErodeIsAllowedMaskBv">where erosion is allowed, needs to be on in 
             mask so it can be turned off in result.</param>
             <remarks>Does not handle voxel spacing x != y.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeMmInMaskEatVolumeBoundary(System.Double,Claron.WIF.BitVol)">
             <summary>
             Erodes this BitVol into the result BitVol by the given mm amount.
             In case it is not a multiple of the voxel spacing, the closest matching multiple is used,
             since the implementation is a loop of discrete single layer erosions.
             Note, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is also eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will shrink in height and thickness.
            
             Voxels are only removed if they are present in the mask whereErodeIsAllowedMaskBv.
             This BitVol is not modified.
             Outside the mask whereErodeIsAllowedMaskBv the operation is a straight copy.
             </summary>
             <param name="mm">how far to Erode in L1 norm or Manhattan distance. Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
             <param name="whereErodeIsAllowedMaskBv">where erosion is allowed, needs to be on in mask so it can be turned off in result.</param>
             <remarks>Not efficient for large mm values, i.e. greater than 10.  Does not handle voxel spacing x != y.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.DilateMmXy(System.Double)">
             <summary>
             Dilates in X and Y only this BitVol into the result BitVol by the given mm amount.
             In case it is not a multiple of the voxel spacing, the closest matching multiple is used,
             since the implementation is a loop of discrete single layer dilations.
            
             This BitVol is not modified, and all voxels of this BitVol will be turned on in the result BitVol.
             </summary>
             <param name="mm">how far to dilate in L1 norm or Manhattan distance. Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
             <remarks>Not efficient for large mm values, i.e. greater than 10.  Does not handle voxel spacing x != y.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeMmXy(System.Double)">
             <summary>
             Erodes in X and Y only this BitVol into the result BitVol by the given mm amount.
             In case it is not a multiple of the voxel spacing, the closest matching multiple is used,
             since the implementation is a loop of discrete single layer erosions.
             However, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is not eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will keep its full height,
             but become one voxel layer slimmer.
            
             This BitVol is not modified.
             </summary>
             <param name="mm">how far to Erode in L1 norm or Manhattan distance. Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
             <remarks>Not efficient for large mm values, i.e. greater than 10.  Does not handle voxel spacing x != y.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeMmXyEatVolumeBoundary(System.Double)">
             <summary>
             Erodes in X and Y only this BitVol into the result BitVol by the given mm amount.
             In case it is not a multiple of the voxel spacing, the closest matching multiple is used,
             since the implementation is a loop of discrete single layer erosions.
             Note, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is also eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will shrink in height and thickness.
            
             This BitVol is not modified.
             </summary>
             <param name="mm">how far to Erode in L1 norm or Manhattan distance. Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
             <remarks>Not efficient for large mm values, i.e. greater than 10.  Does not handle voxel spacing x != y.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.DilateMmXyInBox(System.Double,Claron.WIF.BoxI32)">
             <summary>
             Dilates in X and Y only this BitVol into the result BitVol by the given mm amount.
             In case it is not a multiple of the voxel spacing, the closest matching multiple is used,
             since the implementation is a loop of discrete single layer dilations.
            
             New voxels are only added if they are inside the box whereDilateIsAllowedBoxSi.
             This BitVol is not modified, and all voxels of this BitVol will be turned on in the result BitVol,
             even if they are not inside the box whereDilateIsAllowedBoxSi.
             </summary>
             <param name="mm">how far to dilate in L1 norm or Manhattan distance. Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
             <param name="whereDilateIsAllowedBoxSi">where dilation to is allowed, affects only newly to be added voxels,
             so does not delete anything of the original bits.
             Regardless of box size, padding voxels will be turned off at the end of the operation.</param>
             <remarks>Not efficient for large mm values, i.e. greater than 10.  Does not handle voxel spacing x != y.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeMmXyInBox(System.Double,Claron.WIF.BoxI32)">
             <summary>
             Erodes in X and Y only this BitVol into the result BitVol by the given mm amount.
             In case it is not a multiple of the voxel spacing, the closest matching multiple is used,
             since the implementation is a loop of discrete single layer erosions.
             However, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is not eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will keep its full height,
             but become one voxel layer slimmer.
            
             Voxels are only removed if they are inside the box whereErodeIsAllowedBoxSi.
             This BitVol is not modified.
             Outside the box whereErodeIsAllowedBoxSi the operation is a straight copy.
             </summary>
             <param name="mm">how far to Erode in L1 norm or Manhattan distance. Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
             <param name="whereErodeIsAllowedBoxSi">where erosion is allowed.
             A voxel on in this BitVol must be inside whereErodeIsAllowedBoxSi so it can be turned off in the result.</param>
             <remarks>Not efficient for large mm values, i.e. greater than 10.  Does not handle voxel spacing x != y.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeMmXyInBoxEatVolumeBoundary(System.Double,Claron.WIF.BoxI32)">
             <summary>
             Erodes in X and Y only this BitVol into the result BitVol by the given mm amount.
             In case it is not a multiple of the voxel spacing, the closest matching multiple is used,
             since the implementation is a loop of discrete single layer erosions.
             Note, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is also eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will shrink in height and thickness.
            
             Voxels are only removed if they are inside the box whereErodeIsAllowedBoxSi.
             This BitVol is not modified.
             Outside the box whereErodeIsAllowedBoxSi the operation is a straight copy.
             </summary>
             <param name="mm">how far to Erode in L1 norm or Manhattan distance. Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
             <param name="whereErodeIsAllowedBoxSi">where erosion is allowed.
             A voxel on in this BitVol must be inside whereErodeIsAllowedBoxSi so it can be turned off in the result.</param>
             <remarks>Not efficient for large mm values, i.e. greater than 10.  Does not handle voxel spacing x != y.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.DilateMmXyInMask(System.Double,Claron.WIF.BitVol)">
             <summary>
             Dilates in X and Y only this BitVol into the result BitVol by the given mm amount.
             In case it is not a multiple of the voxel spacing, the closest matching multiple is used,
             since the implementation is a loop of discrete single layer dilations.
            
             New voxels are only added if they are already present in the mask whereDilateIsAllowedMaskBv.
             This BitVol is not modified, and all voxels of this BitVol will be turned on in the result BitVol,
             even if they are not turned on in the mask whereDilateIsAllowedMaskBv.
             </summary>
             <param name="mm">how far to dilate in L1 norm or Manhattan distance. Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
             <param name="whereDilateIsAllowedMaskBv">where dilation to is allowed, affects only newly to be added voxels,
             so does not delete anything of the original bits</param>
             <remarks>Not efficient for large mm values, i.e. greater than 10.  Does not handle voxel spacing x != y.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeMmXyInMask(System.Double,Claron.WIF.BitVol)">
             <summary>
             Erodes in X and Y only this BitVol into the result BitVol by the given mm amount.
             In case it is not a multiple of the voxel spacing, the closest matching multiple is used,
             since the implementation is a loop of discrete single layer erosions.
             However, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is not eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will keep its full height,
             but become one voxel layer slimmer.
            
             Voxels are only removed if they are present in the mask whereErodeIsAllowedMaskBv.
             This BitVol is not modified.
             Outside the mask whereErodeIsAllowedMaskBv the operation is a straight copy.
             </summary>
             <param name="mm">how far to Erode in L1 norm or Manhattan distance. Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
             <param name="whereErodeIsAllowedMaskBv">where erosion is allowed, needs to be on in mask so it can be turned off in result.</param>
             <remarks>Not efficient for large mm values, i.e. greater than 10.  Does not handle voxel spacing x != y.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeMmXyInMaskEatVolumeBoundary(System.Double,Claron.WIF.BitVol)">
             <summary>
             Erodes in X and Y only this BitVol into the result BitVol by the given mm amount.
             In case it is not a multiple of the voxel spacing, the closest matching multiple is used,
             since the implementation is a loop of discrete single layer erosions.
             Note, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is also eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will shrink in height and thickness.
            
             Voxels are only removed if they are present in the mask whereErodeIsAllowedMaskBv.
             This BitVol is not modified.
             Outside the mask whereErodeIsAllowedMaskBv the operation is a straight copy.
             </summary>
             <param name="mm">how far to Erode in L1 norm or Manhattan distance. Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
             <param name="whereErodeIsAllowedMaskBv">where erosion is allowed, needs to be on in mask so it can be turned off in result.</param>
             <remarks>Not efficient for large mm values, i.e. greater than 10.  Does not handle voxel spacing x != y.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.DilateMmX(System.Double)">
             <summary>
             Dilates in X only this BitVol into the result BitVol by the given mm amount.
             In case it is not a multiple of the voxel spacing, the closest matching multiple is used,
             since the implementation is a loop of discrete single layer dilations.
            
             This BitVol is not modified, and all voxels of this BitVol will be turned on in the result BitVol.
             </summary>
             <param name="mm">how far to dilate in L1 norm or Manhattan distance. Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
             <remarks>Not efficient for large mm values, i.e. greater than 10.  Does not handle voxel spacing x != y.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeMmX(System.Double)">
             <summary>
             Erodes in X only this BitVol into the result BitVol by the given mm amount.
             In case it is not a multiple of the voxel spacing, the closest matching multiple is used,
             since the implementation is a loop of discrete single layer erosions.
             However, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is not eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will keep its full height,
             but become one voxel layer slimmer.
            
             This BitVol is not modified.
             </summary>
             <param name="mm">how far to Erode in L1 norm or Manhattan distance. Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
             <remarks>Not efficient for large mm values, i.e. greater than 10.  Does not handle voxel spacing x != y.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeMmXEatVolumeBoundary(System.Double)">
             <summary>
             Erodes in X only this BitVol into the result BitVol by the given mm amount.
             In case it is not a multiple of the voxel spacing, the closest matching multiple is used,
             since the implementation is a loop of discrete single layer erosions.
             Note, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is also eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will shrink in height and thickness.
            
             This BitVol is not modified.
             </summary>
             <param name="mm">how far to Erode in L1 norm or Manhattan distance. Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
             <remarks>Not efficient for large mm values, i.e. greater than 10.  Does not handle voxel spacing x != y.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.DilateMmXInBox(System.Double,Claron.WIF.BoxI32)">
             <summary>
             Dilates in X only this BitVol into the result BitVol by the given mm amount.
             In case it is not a multiple of the voxel spacing, the closest matching multiple is used,
             since the implementation is a loop of discrete single layer dilations.
            
             New voxels are only added if they are inside the box whereDilateIsAllowedBoxSi.
             This BitVol is not modified, and all voxels of this BitVol will be turned on in the result BitVol,
             even if they are not inside the box whereDilateIsAllowedBoxSi.
             </summary>
             <param name="mm">how far to dilate in L1 norm or Manhattan distance. Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
             <param name="whereDilateIsAllowedBoxSi">where dilation to is allowed, affects only newly to be added voxels,
             so does not delete anything of the original bits.
             Regardless of box size, padding voxels will be turned off at the end of the operation.</param>
             <remarks>Not efficient for large mm values, i.e. greater than 10.  Does not handle voxel spacing x != y.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeMmXInBox(System.Double,Claron.WIF.BoxI32)">
             <summary>
             Erodes in X only this BitVol into the result BitVol by the given mm amount.
             In case it is not a multiple of the voxel spacing, the closest matching multiple is used,
             since the implementation is a loop of discrete single layer erosions.
             However, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is not eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will keep its full height,
             but become one voxel layer slimmer.
            
             Voxels are only removed if they are inside the box whereErodeIsAllowedBoxSi.
             This BitVol is not modified.
             Outside the box whereErodeIsAllowedBoxSi the operation is a straight copy.
             </summary>
             <param name="mm">how far to Erode in L1 norm or Manhattan distance. Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
             <param name="whereErodeIsAllowedBoxSi">where erosion is allowed.
             A voxel on in this BitVol must be inside whereErodeIsAllowedBoxSi so it can be turned off in the result.</param>
             <remarks>Not efficient for large mm values, i.e. greater than 10.  Does not handle voxel spacing x != y.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeMmXInBoxEatVolumeBoundary(System.Double,Claron.WIF.BoxI32)">
             <summary>
             Erodes in X only this BitVol into the result BitVol by the given mm amount.
             In case it is not a multiple of the voxel spacing, the closest matching multiple is used,
             since the implementation is a loop of discrete single layer erosions.
             Note, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is also eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will shrink in height and thickness.
            
             Voxels are only removed if they are inside the box whereErodeIsAllowedBoxSi.
             This BitVol is not modified.
             Outside the box whereErodeIsAllowedBoxSi the operation is a straight copy.
             </summary>
             <param name="mm">how far to Erode in L1 norm or Manhattan distance. Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
             <param name="whereErodeIsAllowedBoxSi">where erosion is allowed.
             A voxel on in this BitVol must be inside whereErodeIsAllowedBoxSi so it can be turned off in the result.</param>
             <remarks>Not efficient for large mm values, i.e. greater than 10.  Does not handle voxel spacing x != y.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.DilateMmXInMask(System.Double,Claron.WIF.BitVol)">
             <summary>
             Dilates in X  only this BitVol into the result BitVol by the given mm amount.
             In case it is not a multiple of the voxel spacing, the closest matching multiple is used,
             since the implementation is a loop of discrete single layer dilations.
            
             New voxels are only added if they are already present in the mask whereDilateIsAllowedMaskBv.
             This BitVol is not modified, and all voxels of this BitVol will be turned on in the result BitVol,
             even if they are not turned on in the mask whereDilateIsAllowedMaskBv.
             </summary>
             <param name="mm">how far to dilate in L1 norm or Manhattan distance. Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
             <param name="whereDilateIsAllowedMaskBv">where dilation to is allowed, affects only newly to be added voxels,
             so does not delete anything of the original bits</param>
             <remarks>Not efficient for large mm values, i.e. greater than 10.  Does not handle voxel spacing x != y.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeMmXInMask(System.Double,Claron.WIF.BitVol)">
             <summary>
             Erodes in X only this BitVol into the result BitVol by the given mm amount.
             In case it is not a multiple of the voxel spacing, the closest matching multiple is used,
             since the implementation is a loop of discrete single layer erosions.
             However, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is not eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will keep its full height,
             but become one voxel layer slimmer.
            
             Voxels are only removed if they are present in the mask whereErodeIsAllowedMaskBv.
             This BitVol is not modified.
             Outside the mask whereErodeIsAllowedMaskBv the operation is a straight copy.
             </summary>
             <param name="mm">how far to Erode in L1 norm or Manhattan distance. Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
             <param name="whereErodeIsAllowedMaskBv">where erosion is allowed, needs to be on in mask so it can be turned off in result.</param>
             <remarks>Not efficient for large mm values, i.e. greater than 10.  Does not handle voxel spacing x != y.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeMmXInMaskEatVolumeBoundary(System.Double,Claron.WIF.BitVol)">
             <summary>
             Erodes in X  only this BitVol into the result BitVol by the given mm amount.
             In case it is not a multiple of the voxel spacing, the closest matching multiple is used,
             since the implementation is a loop of discrete single layer erosions.
             Note, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is also eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will shrink in height and thickness.
            
             Voxels are only removed if they are present in the mask whereErodeIsAllowedMaskBv.
             This BitVol is not modified.
             Outside the mask whereErodeIsAllowedMaskBv the operation is a straight copy.
             </summary>
             <param name="mm">how far to Erode in L1 norm or Manhattan distance. Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
             <param name="whereErodeIsAllowedMaskBv">where erosion is allowed, needs to be on in mask so it can be turned off in result.</param>
             <remarks>Not efficient for large mm values, i.e. greater than 10.  Does not handle voxel spacing x != y.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.DilateMmZ(System.Double)">
             <summary>
             Dilates in Z only this BitVol into the result BitVol by the given mm amount.
             In case it is not a multiple of the voxel spacing, the closest matching multiple is used,
             since the implementation is a loop of discrete single layer dilations.
            
             This BitVol is not modified, and all voxels of this BitVol will be turned on in the result BitVol.
             </summary>
             <param name="mm">how far to dilate in L1 norm or Manhattan distance. Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
             <remarks>Not efficient for large mm values, i.e. greater than 10.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeMmZ(System.Double)">
             <summary>
             Erodes in Z only this BitVol into the result BitVol by the given mm amount.
             In case it is not a multiple of the voxel spacing, the closest matching multiple is used,
             since the implementation is a loop of discrete single layer erosions.
             However, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is not eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will keep its full height,
             but become one voxel layer slimmer.
            
             This BitVol is not modified.
             </summary>
             <param name="mm">how far to Erode in L1 norm or Manhattan distance. Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
             <remarks>Not efficient for large mm values, i.e. greater than 10.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeMmZEatVolumeBoundary(System.Double)">
             <summary>
             Erodes in Z only this BitVol into the result BitVol by the given mm amount.
             In case it is not a multiple of the voxel spacing, the closest matching multiple is used,
             since the implementation is a loop of discrete single layer erosions.
             Note, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is also eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will shrink in height and thickness.
            
             This BitVol is not modified.
             </summary>
             <param name="mm">how far to Erode in L1 norm or Manhattan distance. Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
             <remarks>Not efficient for large mm values, i.e. greater than 10.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.DilateMmZInBox(System.Double,Claron.WIF.BoxI32)">
             <summary>
             Dilates in Z only this BitVol into the result BitVol by the given mm amount.
             In case it is not a multiple of the voxel spacing, the closest matching multiple is used,
             since the implementation is a loop of discrete single layer dilations.
            
             New voxels are only added if they are inside the box whereDilateIsAllowedBoxSi.
             This BitVol is not modified, and all voxels of this BitVol will be turned on in the result BitVol,
             even if they are not inside the box whereDilateIsAllowedBoxSi.
             </summary>
             <param name="mm">how far to dilate in L1 norm or Manhattan distance. Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
             <param name="whereDilateIsAllowedBoxSi">where dilation to is allowed, affects only newly to be added voxels,
             so does not delete anything of the original bits.
             Regardless of box size, padding voxels will be turned off at the end of the operation.</param>
             <remarks>Not efficient for large mm values, i.e. greater than 10.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeMmZInBox(System.Double,Claron.WIF.BoxI32)">
             <summary>
             Erodes in Z only this BitVol into the result BitVol by the given mm amount.
             In case it is not a multiple of the voxel spacing, the closest matching multiple is used,
             since the implementation is a loop of discrete single layer erosions.
             However, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is not eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will keep its full height,
             but become one voxel layer slimmer.
            
             Voxels are only removed if they are inside the box whereErodeIsAllowedBoxSi.
             This BitVol is not modified.
             Outside the box whereErodeIsAllowedBoxSi the operation is a straight copy.
             </summary>
             <param name="mm">how far to Erode in L1 norm or Manhattan distance. Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
             <param name="whereErodeIsAllowedBoxSi">where erosion is allowed.
             A voxel on in this BitVol must be inside whereErodeIsAllowedBoxSi so it can be turned off in the result.</param>
             <remarks>Not efficient for large mm values, i.e. greater than 10.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeMmZInBoxEatVolumeBoundary(System.Double,Claron.WIF.BoxI32)">
             <summary>
             Erodes in Z only this BitVol into the result BitVol by the given mm amount.
             In case it is not a multiple of the voxel spacing, the closest matching multiple is used,
             since the implementation is a loop of discrete single layer erosions.
             Note, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is also eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will shrink in height and thickness.
            
             Voxels are only removed if they are inside the box whereErodeIsAllowedBoxSi.
             This BitVol is not modified.
             Outside the box whereErodeIsAllowedBoxSi the operation is a straight copy.
             </summary>
             <param name="mm">how far to Erode in L1 norm or Manhattan distance. Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
             <param name="whereErodeIsAllowedBoxSi">where erosion is allowed.
             A voxel on in this BitVol must be inside whereErodeIsAllowedBoxSi so it can be turned off in the result.</param>
             <remarks>Not efficient for large mm values, i.e. greater than 10.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.DilateMmZInMask(System.Double,Claron.WIF.BitVol)">
             <summary>
             Dilates in Z only this BitVol into the result BitVol by the given mm amount.
             In case it is not a multiple of the voxel spacing, the closest matching multiple is used,
             since the implementation is a loop of discrete single layer dilations.
            
             New voxels are only added if they are already present in the mask whereDilateIsAllowedMaskBv.
             This BitVol is not modified, and all voxels of this BitVol will be turned on in the result BitVol,
             even if they are not turned on in the mask whereDilateIsAllowedMaskBv.
             </summary>
             <param name="mm">how far to dilate in L1 norm or Manhattan distance. Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
             <param name="whereDilateIsAllowedMaskBv">where dilation to is allowed, affects only newly to be added voxels,
             so does not delete anything of the original bits</param>
             <remarks>Not efficient for large mm values, i.e. greater than 10.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeMmZInMask(System.Double,Claron.WIF.BitVol)">
             <summary>
             Erodes in Z only this BitVol into the result BitVol by the given mm amount.
             In case it is not a multiple of the voxel spacing, the closest matching multiple is used,
             since the implementation is a loop of discrete single layer erosions.
             However, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is not eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will keep its full height,
             but become one voxel layer slimmer.
            
             New voxels are only added if they are already present in the mask whereErodeIsAllowedMaskBv.
             This BitVol is not modified, and all voxels of this BitVol will be turned on in the result BitVol,
             even if they are not turned on in the mask whereErodeIsAllowedMaskBv.
             </summary>
             <param name="mm">how far to Erode in L1 norm or Manhattan distance. Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
             <param name="whereErodeIsAllowedMaskBv">where erosion is allowed, needs to be on in mask so it can be turned off in result.</param>
             <remarks>Not efficient for large mm values, i.e. greater than 10.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeMmZInMaskEatVolumeBoundary(System.Double,Claron.WIF.BitVol)">
             <summary>
             Erodes in Z only this BitVol into the result BitVol by the given mm amount.
             In case it is not a multiple of the voxel spacing, the closest matching multiple is used,
             since the implementation is a loop of discrete single layer erosions.
             Note, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is also eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will shrink in height and thickness.
            
             New voxels are only added if they are already present in the mask whereErodeIsAllowedMaskBv.
             This BitVol is not modified, and all voxels of this BitVol will be turned on in the result BitVol,
             even if they are not turned on in the mask whereErodeIsAllowedMaskBv.
             </summary>
             <param name="mm">how far to Erode in L1 norm or Manhattan distance. Multiply by Sqrt(3) if you like an effect similar to L2 norm.</param>
             <param name="whereErodeIsAllowedMaskBv">where erosion is allowed, needs to be on in mask so it can be turned off in result.</param>
             <remarks>Not efficient for large mm values, i.e. greater than 10.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.CloseMm(System.Double)">
            <summary>
            Closes (dilate -> erode) at most as much as given in radius argument (as many discrete layers as fit in mm target)
            </summary>
            <param name="mm">how far to close in mm</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.OpenMm(System.Double)">
            <summary>
            Opens (erode -> dilate) at most as much as given in radius argument (as many discrete layers as fit in mm target)
            </summary>
            <param name="mm">how far to Open in mm</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.CloseMmXy(System.Double)">
            <summary>
            Closes (dilate -> erode) at most as much as given in radius argument (as many discrete layers as fit in mm target)
            </summary>
            <param name="mm">how far to close in mm</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.OpenMmXy(System.Double)">
            <summary>
            Opens (erode -> dilate) at most as much as given in radius argument (as many discrete layers as fit in mm target)
            </summary>
            <param name="mm">how far to Open in mm</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.CloseMmX(System.Double)">
            <summary>
            Closes (dilate -> erode) at most as much as given in radius argument (as many discrete layers as fit in mm target)
            </summary>
            <param name="mm">how far to close in mm</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.OpenMmX(System.Double)">
            <summary>
            Opens (erode -> dilate) at most as much as given in radius argument (as many discrete layers as fit in mm target)
            </summary>
            <param name="mm">how far to Open in mm</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.CloseMmZ(System.Double)">
            <summary>
            Closes (dilate -> erode) at most as much as given in radius argument (as many discrete layers as fit in mm target)
            </summary>
            <param name="mm">how far to close in mm</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.OpenMmZ(System.Double)">
            <summary>
            Opens (erode -> dilate) at most as much as given in radius argument (as many discrete layers as fit in mm target)
            </summary>
            <param name="mm">how far to Open in mm</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.DilateDiscrete">
             <summary>
             Returns a new BitVol dilated one discrete layer in all 6 directions.
            
             This BitVol is not modified.
             </summary>
             <remarks>
             TODO: Need to repeat timing measurements.
            
             bone; thresholded at 250HU after 2590ms
             511 slices; dilated after 79ms min  86ms 2nd min  96.5ms avg 115ms 2nd max 121ms max 84 82 116 81 121 86 79 115 112 89
             511 slc; IP dilated after 60ms min  61ms 2nd min  61.5ms avg  62ms 2nd max  66ms max (same result)
            
             muscle; thresholded at 0HU after 2653ms
             511 slices; dilated after 147ms min 151ms 2nd min 167.4ms avg 180ms 2nd max 205ms max 184 205 173 180 154 177 152 151 147 151
             511 slc; IP dilated after  67ms min  69ms 2nd min  70.3ms avg  71ms 2nd max  73ms max (same result)
            
             body; thresholded at -500HU after 2597ms
             511 slices; dilated after 95ms min 113ms 2nd min 124.5ms avg 139ms 2nd max 147ms max 104 140 116 138 127 147 95 126 139 113
             511 slc; IP dilated after 65ms min  66ms 2nd min  67.4ms avg  69ms 2nd max  72ms max (same result)
             </remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.DilateDiscrete18">
             <summary>
             Returns a new BitVol dilated one discrete layer in 18 directions
             (all neighbors less than 1.5 units away).
            
             This BitVol is not modified.
             </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.DilateDiscreteXy8">
            <summary>
            Returns a new BitVol dilated one discrete layer in all 8 directions in the XY plane (only)
            This BitVol is not modified.
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.DilateDiscrete26">
             <summary>
             Returns a new BitVol dilated one discrete layer in 26 directions
             (all neighbors less than 2 units away).
            
             This BitVol is not modified.
             </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.DilateMeDiscrete">
            <summary>
            Dilated the full (1) regions by one discrete layer in all 6 directions.
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeDiscrete">
             <summary>
             Erodes this BitVol into the result BitVol by one discrete layer in all directions.
             However, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is not eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will keep its full height,
             but become one voxel layer slimmer.
            
             This BitVol is not modified.
             </summary>
             <returns></returns>
             <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeMeDiscrete">
            <summary>
            Erodes the full (1) regions by one discrete layer in all 6 directions.
            Voxels at the mask boundary layers are not eroded by being next to the "outside".
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeDiscreteEatVolumeBoundary">
             <summary>
             Erodes this BitVol into the result BitVol by one discrete layer in all directions.
             Note, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is also eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will shrink in height and thickness.
            
             This BitVol is not modified.
             </summary>
             <returns></returns>
             <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.DilateDiscreteInBox(Claron.WIF.BoxI32)">
             <summary>
             Dilates this BitVol into the result BitVol by one discrete layer in all directions.
            
             New voxels are only added if they are inside the box whereDilateIsAllowedBoxSi.
             This BitVol is not modified, and all voxels of this BitVol will be turned on in the result BitVol,
             even if they are not inside the box whereDilateIsAllowedBoxSi.
             </summary>
             <param name="whereDilateIsAllowedBoxSi">where dilation to is allowed, affects only newly to be added voxels,
             so does not delete anything of the original bits.
             Regardless of box size, padding voxels will be turned off at the end of the operation.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeDiscreteInBox(Claron.WIF.BoxI32)">
             <summary>
             Erodes this BitVol into the result BitVol one discrete layer in all directions.
             However, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is not eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will keep its full height,
             but become one voxel layer slimmer.
            
             Voxels are only removed if they are inside the box whereErodeIsAllowedBoxSi.
             This BitVol is not modified.
             Outside the box whereErodeIsAllowedBoxSi the operation is a straight copy.
             </summary>
             <param name="whereErodeIsAllowedBoxSi">where erosion is allowed.
             A voxel on in this BitVol must be inside whereErodeIsAllowedBoxSi so it can be turned off in the result.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeDiscreteInBoxEatVolumeBoundary(Claron.WIF.BoxI32)">
             <summary>
             Erodes this BitVol into the result BitVol one discrete layer in all directions.
             Note, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is also eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will shrink in height and thickness.
            
             Voxels are only removed if they are inside the box whereErodeIsAllowedBoxSi.
             This BitVol is not modified.
             Outside the box whereErodeIsAllowedBoxSi the operation is a straight copy.
             </summary>
             <param name="whereErodeIsAllowedBoxSi">where erosion is allowed.
             A voxel on in this BitVol must be inside whereErodeIsAllowedBoxSi so it can be turned off in the result.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.DilateDiscreteInMask(Claron.WIF.BitVol)">
             <summary>
             Dilates this BitVol into the result BitVol by one discrete layer in all directions,
             as long as the change falls inside the constraining mask whereDilateIsAllowedMaskBv.
            
             New voxels are only added if they are inside the mask whereDilateIsAllowedMaskBv.
             This BitVol is not modified, and all voxels of this BitVol will be turned on in the result BitVol,
             even if they are not inside the mask whereDilateIsAllowedMaskBv.
             </summary>
             <param name="whereDilateIsAllowedMaskBv">where dilation to is allowed, affects only newly to be added voxels,
             so does not delete anything of the original bits.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeDiscreteInMask(Claron.WIF.BitVol)">
             <summary>
             Erodes this BitVol into the result BitVol one discrete layer in all directions,
             as long as the change falls inside the constraining mask whereErodeIsAllowedMaskBv.
             However, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is not eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will keep its full height,
             but become one voxel layer slimmer.
            
             Voxels are only removed if they are inside the mask whereErodeIsAllowedMaskBv.
             This BitVol is not modified.
             Outside the mask whereErodeIsAllowedMaskBv the operation is a straight copy.
             </summary>
             <param name="whereErodeIsAllowedMaskBv">where erosion is allowed.
             A voxel on in this BitVol must be inside the mask whereErodeIsAllowedMaskBv so it can be turned off in the result.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeDiscreteInMaskEatVolumeBoundary(Claron.WIF.BitVol)">
             <summary>
             Erodes this BitVol into the result BitVol one discrete layer in all directions,
             as long as the change falls inside the constraining mask whereErodeIsAllowedMaskBv.
             Note, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is also eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will shrink in height and thickness.
            
             Voxels are only removed if they are inside the mask whereErodeIsAllowedMaskBv.
             This BitVol is not modified.
             Outside the mask whereErodeIsAllowedMaskBv the operation is a straight copy.
             </summary>
             <param name="whereErodeIsAllowedMaskBv">where erosion is allowed.
             A voxel on in this BitVol must be inside the mask whereErodeIsAllowedMaskBv so it can be turned off in the result.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.DilateDiscreteXy">
             <summary>
             Dilates in X and Y only this BitVol into the result BitVol by one discrete layer.
            
             This BitVol is not modified, and all voxels of this BitVol will be turned on in the result BitVol.
             </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeDiscreteXy">
             <summary>
             Erodes in x and y only this BitVol into the result BitVol by one discrete layer in all directions.
             However, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is not eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will keep its full height,
             but become one voxel layer slimmer.
            
             This BitVol is not modified.
             </summary>
             <returns></returns>
             <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeDiscreteXyEatVolumeBoundary">
             <summary>
             Erodes in x and y only this BitVol into the result BitVol by one discrete layer in all directions.
             Note, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is also eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will shrink in height and thickness.
            
             This BitVol is not modified.
             </summary>
             <returns></returns>
             <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.DilateDiscreteXyInBox(Claron.WIF.BoxI32)">
             <summary>
             Dilates in x and y only this BitVol into the result BitVol by one discrete layer in all directions.
            
             New voxels are only added if they are inside the box whereDilateIsAllowedBoxSi.
             This BitVol is not modified, and all voxels of this BitVol will be turned on in the result BitVol,
             even if they are not inside the box whereDilateIsAllowedBoxSi.
             </summary>
             <param name="whereDilateIsAllowedBoxSi">where dilation to is allowed, affects only newly to be added voxels,
             so does not delete anything of the original bits.
             Regardless of box size, padding voxels will be turned off at the end of the operation.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeDiscreteXyInBox(Claron.WIF.BoxI32)">
             <summary>
             Erodes in x and y only this BitVol into the result BitVol one discrete layer in all directions.
             However, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is not eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will keep its full height,
             but become one voxel layer slimmer.
            
             Voxels are only removed if they are inside the box whereErodeIsAllowedBoxSi.
             This BitVol is not modified.
             Outside the box whereErodeIsAllowedBoxSi the operation is a straight copy.
             </summary>
             <param name="whereErodeIsAllowedBoxSi">where erosion is allowed.
             A voxel on in this BitVol must be inside whereErodeIsAllowedBoxSi so it can be turned off in the result.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeDiscreteXyInBoxEatVolumeBoundary(Claron.WIF.BoxI32)">
             <summary>
             Erodes in x and y only this BitVol into the result BitVol one discrete layer in all directions.
             Note, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is also eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will shrink in height and thickness.
            
             Voxels are only removed if they are inside the box whereErodeIsAllowedBoxSi.
             This BitVol is not modified.
             Outside the box whereErodeIsAllowedBoxSi the operation is a straight copy.
             </summary>
             <param name="whereErodeIsAllowedBoxSi">where erosion is allowed.
             A voxel on in this BitVol must be inside whereErodeIsAllowedBoxSi so it can be turned off in the result.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.DilateDiscreteXyInMask(Claron.WIF.BitVol)">
            <summary>
            Dilate in x and y only, and new voxels are added only if they are also turned on in the whereDilateIsAllowedMaskBv.
            </summary>
            <param name="whereDilateIsAllowedMaskBv">where dilation to is allowed, affects only newly to be added voxels,
            so does not delete anything of the original bits</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeDiscreteXyInMask(Claron.WIF.BitVol)">
             <summary>
             Erode in x and y only this BitVol into the result BitVol one discrete layer in all directions,
             as long as the change falls inside the constraining mask whereErodeIsAllowedMaskBv.
             However, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is not eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will keep its full height,
             but become one voxel layer slimmer.
            
             Voxels are only removed if they are inside the mask whereErodeIsAllowedMaskBv.
             This BitVol is not modified.
             Outside the mask whereErodeIsAllowedMaskBv the operation is a straight copy.
             </summary>
             <param name="whereErodeIsAllowedMaskBv">where erosion is allowed.
             A voxel on in this BitVol must be inside the mask whereErodeIsAllowedMaskBv so it can be turned off in the result.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeDiscreteXyInMaskEatVolumeBoundary(Claron.WIF.BitVol)">
             <summary>
             Erode in x and y only this BitVol into the result BitVol one discrete layer in all directions,
             as long as the change falls inside the constraining mask whereErodeIsAllowedMaskBv.
             Note, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is also eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will shrink in height and thickness.
            
             Voxels are only removed if they are inside the mask whereErodeIsAllowedMaskBv.
             This BitVol is not modified.
             Outside the mask whereErodeIsAllowedMaskBv the operation is a straight copy.
             </summary>
             <param name="whereErodeIsAllowedMaskBv">where erosion is allowed.
             A voxel on in this BitVol must be inside the mask whereErodeIsAllowedMaskBv so it can be turned off in the result.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.DilateDiscreteX">
             <summary>
             Dilates in X only this BitVol into the result BitVol by one discrete layer.
            
             This BitVol is not modified, and all voxels of this BitVol will be turned on in the result BitVol.
             </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeDiscreteX">
             <summary>
             Erodes in x  only this BitVol into the result BitVol by one discrete layer in all directions.
             However, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is not eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will keep its full height,
             but become one voxel layer slimmer.
            
             This BitVol is not modified.
             </summary>
             <returns></returns>
             <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeDiscreteXEatVolumeBoundary">
             <summary>
             Erodes in x only this BitVol into the result BitVol by one discrete layer in all directions.
             Note, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is also eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will shrink in height and thickness.
            
             This BitVol is not modified.
             </summary>
             <returns></returns>
             <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.DilateDiscreteXInBox(Claron.WIF.BoxI32)">
             <summary>
             Dilates in X only this BitVol into the result BitVol by one discrete layer in all directions.
            
             New voxels are only added if they are inside the box whereDilateIsAllowedBoxSi.
             This BitVol is not modified, and all voxels of this BitVol will be turned on in the result BitVol,
             even if they are not inside the box whereDilateIsAllowedBoxSi.
             </summary>
             <param name="whereDilateIsAllowedBoxSi">where dilation to is allowed, affects only newly to be added voxels,
             so does not delete anything of the original bits.
             Regardless of box size, padding voxels will be turned off at the end of the operation.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeDiscreteXInBox(Claron.WIF.BoxI32)">
             <summary>
             Erodes in X only this BitVol into the result BitVol one discrete layer in all directions.
             However, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is not eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will keep its full height,
             but become one voxel layer slimmer.
            
             Voxels are only removed if they are inside the box whereErodeIsAllowedBoxSi.
             This BitVol is not modified.
             Outside the box whereErodeIsAllowedBoxSi the operation is a straight copy.
             </summary>
             <param name="whereErodeIsAllowedBoxSi">where erosion is allowed.
             A voxel on in this BitVol must be inside whereErodeIsAllowedBoxSi so it can be turned off in the result.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeDiscreteXInBoxEatVolumeBoundary(Claron.WIF.BoxI32)">
             <summary>
             Erodes in X only this BitVol into the result BitVol one discrete layer in all directions.
             Note, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is also eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will shrink in height and thickness.
            
             Voxels are only removed if they are inside the box whereErodeIsAllowedBoxSi.
             This BitVol is not modified.
             Outside the box whereErodeIsAllowedBoxSi the operation is a straight copy.
             </summary>
             <param name="whereErodeIsAllowedBoxSi">where erosion is allowed.
             A voxel on in this BitVol must be inside whereErodeIsAllowedBoxSi so it can be turned off in the result.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.DilateDiscreteXInMask(Claron.WIF.BitVol)">
            <summary>
            Dilate in x only, and new voxels are added only if they are also turned on in the whereDilateIsAllowedMaskBv.
            </summary>
            <param name="whereDilateIsAllowedMaskBv">where dilation to is allowed, affects only newly to be added voxels,
            so does not delete anything of the original bits</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeDiscreteXInMask(Claron.WIF.BitVol)">
             <summary>
             Erode in x only this BitVol into the result BitVol one discrete layer in all directions,
             as long as the change falls inside the constraining mask whereErodeIsAllowedMaskBv.
             However, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is not eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will keep its full height,
             but become one voxel layer slimmer.
            
             Voxels are only removed if they are inside the mask whereErodeIsAllowedMaskBv.
             This BitVol is not modified.
             Outside the mask whereErodeIsAllowedMaskBv the operation is a straight copy.
             </summary>
             <param name="whereErodeIsAllowedMaskBv">where erosion is allowed.
             A voxel on in this BitVol must be inside the mask whereErodeIsAllowedMaskBv so it can be turned off in the result.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeDiscreteXInMaskEatVolumeBoundary(Claron.WIF.BitVol)">
             <summary>
             Erode in x only this BitVol into the result BitVol one discrete layer in all directions,
             as long as the change falls inside the constraining mask whereErodeIsAllowedMaskBv.
             Note, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is also eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will shrink in height and thickness.
            
             Voxels are only removed if they are inside the mask whereErodeIsAllowedMaskBv.
             This BitVol is not modified.
             Outside the mask whereErodeIsAllowedMaskBv the operation is a straight copy.
             </summary>
             <param name="whereErodeIsAllowedMaskBv">where erosion is allowed.
             A voxel on in this BitVol must be inside the mask whereErodeIsAllowedMaskBv so it can be turned off in the result.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.DilateDiscreteY">
             <summary>
             Dilates in Y only this BitVol into the result BitVol by one discrete layer.
            
             This BitVol is not modified, and all voxels of this BitVol will be turned on in the result BitVol.
             </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.DilateDiscreteZ">
             <summary>
             Dilates in Z only this BitVol into the result BitVol by one discrete layer.
            
             This BitVol is not modified, and all voxels of this BitVol will be turned on in the result BitVol.
             </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeDiscreteZ">
             <summary>
             Erodes in Z only this BitVol into the result BitVol by one discrete layer in all directions.
             However, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is not eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will keep its full height,
             but become one voxel layer slimmer.
            
             This BitVol is not modified.
             </summary>
             <returns></returns>
             <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeDiscreteZEatVolumeBoundary">
             <summary>
             Erodes in Z only this BitVol into the result BitVol by one discrete layer in all directions.
             Note, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is also eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will shrink in height and thickness.
            
             This BitVol is not modified.
             </summary>
             <returns></returns>
             <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.DilateDiscreteZInBox(Claron.WIF.BoxI32)">
             <summary>
             Dilates in Z only this BitVol into the result BitVol by one discrete layer in all directions.
            
             New voxels are only added if they are inside the box whereDilateIsAllowedBoxSi.
             This BitVol is not modified, and all voxels of this BitVol will be turned on in the result BitVol,
             even if they are not inside the box whereDilateIsAllowedBoxSi.
             </summary>
             <param name="whereDilateIsAllowedBoxSi">where dilation to is allowed, affects only newly to be added voxels,
             so does not delete anything of the original bits.
             Regardless of box size, padding voxels will be turned off at the end of the operation.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeDiscreteZInBox(Claron.WIF.BoxI32)">
             <summary>
             Erodes in Z only this BitVol into the result BitVol one discrete layer in all directions.
             However, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is not eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will keep its full height,
             but become one voxel layer slimmer.
            
             Voxels are only removed if they are inside the box whereErodeIsAllowedBoxSi.
             This BitVol is not modified.
             Outside the box whereErodeIsAllowedBoxSi the operation is a straight copy.
             </summary>
             <param name="whereErodeIsAllowedBoxSi">where erosion is allowed.
             A voxel on in this BitVol must be inside whereErodeIsAllowedBoxSi so it can be turned off in the result.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeDiscreteZInBoxEatVolumeBoundary(Claron.WIF.BoxI32)">
             <summary>
             Erodes in x and y only this BitVol into the result BitVol one discrete layer in all directions.
             Note, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is also eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will shrink in height and thickness.
            
             Voxels are only removed if they are inside the box whereErodeIsAllowedBoxSi.
             This BitVol is not modified.
             Outside the box whereErodeIsAllowedBoxSi the operation is a straight copy.
             </summary>
             <param name="whereErodeIsAllowedBoxSi">where erosion is allowed.
             A voxel on in this BitVol must be inside whereErodeIsAllowedBoxSi so it can be turned off in the result.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.DilateDiscreteZInMask(Claron.WIF.BitVol)">
            <summary>
            Dilate in Z only, and new voxels are added only if they are also turned on in the whereDilateIsAllowedMaskBv.
            </summary>
            <param name="whereDilateIsAllowedMaskBv">where dilation to is allowed, affects only newly to be added voxels,
            so does not delete anything of the original bits</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeDiscreteZInMask(Claron.WIF.BitVol)">
             <summary>
             Erode in Z only this BitVol into the result BitVol one discrete layer in all directions,
             as long as the change falls inside the constraining mask whereErodeIsAllowedMaskBv.
             However, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is not eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will keep its full height,
             but become one voxel layer slimmer.
            
             Voxels are only removed if they are inside the mask whereErodeIsAllowedMaskBv.
             This BitVol is not modified.
             Outside the mask whereErodeIsAllowedMaskBv the operation is a straight copy.
             </summary>
             <param name="whereErodeIsAllowedMaskBv">where erosion is allowed.
             A voxel on in this BitVol must be inside the mask whereErodeIsAllowedMaskBv so it can be turned off in the result.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.ErodeDiscreteZInMaskEatVolumeBoundary(Claron.WIF.BitVol)">
             <summary>
             Erode in Z only this BitVol into the result BitVol one discrete layer in all directions,
             as long as the change falls inside the constraining mask whereErodeIsAllowedMaskBv.
             Note, if the mask is touching the volume boundary
             as does for masks from a field of view that is completely inside the body/data,
             then that mask boundary layer is also eroded.
             I.e. a cylinder all they way from top to bottom of the dataset will shrink in height and thickness.
            
             Voxels are only removed if they are inside the mask whereErodeIsAllowedMaskBv.
             This BitVol is not modified.
             Outside the mask whereErodeIsAllowedMaskBv the operation is a straight copy.
             </summary>
             <param name="whereErodeIsAllowedMaskBv">where erosion is allowed.
             A voxel on in this BitVol must be inside the mask whereErodeIsAllowedMaskBv so it can be turned off in the result.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.CompactnessVolumeToSurface">
            <summary>
            BitVol ROI compactness as ratio between the voxel count sphere radii of this BItVOl and the once eroded version.
            Is near zero for a sparse cluster of turned on scattered voxels
            Is 1 for perfect spheres.
            </summary>
            <returns>The compactness measure [0, sqrt(3)].</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.AverageDown(Claron.WIF.Vector3_I32)">
            <summary>
            Averages down a bitvol.
            </summary>
            <param name="pixelSizeFactor">The relative size of voxels in the x-, y-, z-directions respectively in the
            new bitvol in comparison to this bitvol.</param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.BitVol.AddSphereMask(Claron.WIF.Vector3,System.Double)">
            <summary>
            Efficient sphere scan conversion. Should be used instead of AddSphereBitVol()
            </summary>
            <param name="centerPosPatRcs"></param>
            <param name="radiusMm"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.SphereSet(Claron.WIF.Vector3,System.Double,System.Boolean)">
            <summary>
            Efficiently sets a spheric region to 1 or 0. Should be used instead of AddSphereBitVol()
            </summary>
            <param name="centerPosPatRcs">The center of the sphere.</param>
            <param name="radiusMm">The radius of the sphere/</param>
            <param name="To1">Determines if the sphere is set to 1 (true) or 0 (false).</param>
        </member>
        <member name="M:Claron.WIF.BitVol.CircleSet(Claron.WIF.Vector3,System.Double,System.Boolean,Claron.WIF.Vector3,Claron.WIF.Vector3,System.Double)">
            <summary>
            Sets a circle region to 1 or 0.
            </summary>
            <param name="centerPosPatRcs">The center of the circle.</param>
            <param name="radiusMm">The radius of the circle.</param>
            <param name="to1">Determines if the circle is set to 1 (true) or 0 (false)</param>
            <param name="xVecPr">The direction of the x-axis in the plane of the circle.</param>
            <param name="yVecPr">The direction of the y-axis in the plane of the circle.</param>
            <param name="zThicknessMm">The threshold distance which the distance from the point on the stroke to
            the plane of the stroke must be within to cause the bitvol to be modified.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.SphereStrokeSet(Claron.WIF.Vector3,Claron.WIF.Vector3,System.Double,System.Boolean)">
            <summary>
            Efficiently sets to 1 or 0 a region representing a stroke (line segment) made with a sphere element.
            Mathematically, all voxel locations within a given radius from the given line segment
            are set to the given value (0 or 1).
            Designed for use for manually "brushing" or "erasing" a region using continous motions
            with a cursor.
            </summary>
            <param name="strokeStartPr">One end of the stroke (line segment) in patient scan RCS</param>
            <param name="strokeEndPr">One other end of the stroke in patient scan RCS</param>
            <param name="radiusMm">The maximum distance from the stroke in which bit voxels would be affected.</param>
            <param name="To1">Determines if the affected bits would be set to 1 (true) or 0 (false)</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.CircleStrokeSet(Claron.WIF.Vector3,Claron.WIF.Vector3,System.Double,System.Boolean,Claron.WIF.Vector3,Claron.WIF.Vector3,System.Double)">
            <summary>
            Sets to 1 or 0 a region representing a stroke (line segment) made with a circle element.  Designed
            for use for manually "brushing" or "erasing" a region using continuous motions with a cursor.
            </summary>
            <param name="strokeStartPr">One end of the stroke (line segment) in patient scan RCS</param>
            <param name="strokeEndPr">Other end of the stroke in patient scan RCS</param>
            <param name="radiusMm">The maximum distance from the stroke in which bit voxels would be affected.</param>
            <param name="to1">Determines if the affected bits would be set to 1 (true) or 0 (false)</param>
            <param name="xVecPr">The direction of the x-axis in the plane of the circle.</param>
            <param name="yVecPr">The direction of the y-axis in the plane of the circle.</param>
            <param name="zThicknessMm">The maximum distance from any point on the stroke to
            the plane of the stroke in which the bitvol is modified.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.CountAllBits">
            <summary>
            Computes the number of 1 bits in the bitvol
            </summary>
            <returns></returns>
            <remarks></remarks>
            merge with next function
        </member>
        <member name="F:Claron.WIF.BitVol.BitsCount_LastComputedCount">
            <summary>
            Returns the number of 1 bits in the volume. Optimized
            to avoid re-computations if not needed.
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.VolumeMm3">
            <summary>
            Returns the total volume of all the 1-bits in the bitvol.
            Optimized to avoid re-computations. Uses the grid to find the size of each
            bit-voxel in mm.
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.AverageXyz">
            <summary>
            Returns the average (index) coordinate of the full bits, or Invalid if empty bitvol.
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ResampleBvToHalfX">
            <summary>
            Resamples the BitVol to one with half as many slices.
            The y,z sampling are untouched, x is made ceil(zOrig/2).
            Note that the destination voxels are an exact average of two source voxels.
            Thus the origin of the result BitVol is moved by 1/2 voxel for the destination BitVol.
            </summary>
            <returns>A newly allocated BitVol with the resampled bits.</returns>
            <remarks>
            ?s for 512x512x1000 @ 8 threads, 4 cores, Intel i7 @ 2.67Ghz
            ?s for 512x512x1000 @ 4 threads, 4 cores, Intel i7 @ 2.67Ghz
            ?s for 512x512x1000 @ 2 threads, 4 cores, Intel i7 @ 2.67Ghz
            5ms for 512x512x1000 @ 1 threads, 4 cores, Intel i7 @ 2.67Ghz
            </remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ResampleBvToHalfY">
            <summary>
            Resamples the BitVol to one with half as many slices.
            The x,z sampling are untouched, y is made ceil(zOrig/2).
            Note that the destination voxels are an exact average of two source voxels.
            Thus the origin of the result BitVol is moved by 1/2 voxel for the destination BitVol.
            </summary>
            <returns>A newly allocated BitVol with the resampled bits.</returns>
            <remarks>
            0.?s for 512x512x1000 @ 8 threads, 4 cores, Intel i7 @ 2.67Ghz
            0.?s for 512x512x1000 @ 4 threads, 4 cores, Intel i7 @ 2.67Ghz
            0.?s for 512x512x1000 @ 2 threads, 4 cores, Intel i7 @ 2.67Ghz
            0.?s for 512x512x1000 @ 1 threads, 4 cores, Intel i7 @ 2.67Ghz
            </remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ResampleBvToHalfZ">
            <summary>
            Resamples the BitVol to one with half as many slices.
            The x,y sampling are untouched, z is made ceil(zOrig/2).
            Note that the destination voxels are an exact average of two source voxels.
            Thus the origin of the result BitVol is moved by 1/2 voxel for the destination BitVol.
            </summary>
            <returns>A newly allocated BitVol with the resampled bits.</returns>
            <remarks>
            0.?s for 512x512x1000 @ 8 threads, 4 cores, Intel i7 @ 2.67Ghz
            0.?s for 512x512x1000 @ 4 threads, 4 cores, Intel i7 @ 2.67Ghz
            0.?s for 512x512x1000 @ 2 threads, 4 cores, Intel i7 @ 2.67Ghz
            0.?s for 512x512x1000 @ 1 threads, 4 cores, Intel i7 @ 2.67Ghz
            </remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.GetCentralPos">
            <summary>
            Get a center point (index coordinates) of all set bits such that the center is part of the set bits. Since
            the center is not well defined, a greedy method is used to find the storage center
            followed by refining of the center along X then Y, and then Z. This is a fast implementation
            which should work reasonably well.
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.GetCenterOfGravityPr">
            <summary>
            Returns the center of gravity in patient scan coordinates.
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.GetCenterOfGravitySi">
            <summary>
            Returns the center of gravity in grid index coordinates.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.BitVol.GetCenterOfGravityPrWeightedByVoxelIntensity(Claron.WIF.SliceStack,System.Int32,System.Int32)">
            <summary>
            Returns the center of gravity in patient scan coordinates weighted by the voxel intensity.
            </summary>
            <param name="ss">The SliceStack to take the voxel intensities from.</param>
            <param name="minHu">The HU value which a voxel must be above to be given a non-zero
            weight.</param>
            <param name="weight1Hu">The HU value which a voxel must have to be given a weight of 1.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.GetCenterOfGravitySiWeightedByVoxelIntensity(Claron.WIF.SliceStack,System.Int32,System.Int32)">
            <summary>
            Returns the center of gravity in grid index coordinates weighted by the voxel intensity.
            </summary>
            <param name="ss">The SliceStack to take the voxel intensities from.</param>
            <param name="minHu">The HU value which a voxel must be above to be given a non-zero
            weight.</param>
            <param name="weight1Hu">The HU value which a voxel must have to be given a weight of 1.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.VolumeBBox">
            <summary>
            Returns the bounding box of the full volume of the bitvol (not just filled voxels)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.BitVol.ShrinkToSubVolume(Claron.WIF.BoxI32)">
            <summary>
            Shrinks the BitVol to any arbitrary sized but axis aligned sub volume.
            If the sub volume box is also brick aligned (stopping at last slice counts as brick aligned, too)
            then execution will be a few ms, i.e. less than 10sms.
            Otherwise, especially if the starting corner is not brick aligned, execution may take more than 1000ms.
            </summary>
            <param name="box_in">The box to shrink too (make brick aligned for more speed).</param>
        </member>
        <member name="M:Claron.WIF.BitVol.BoundingBoxOfData">
            <summary>
            Returns the exact bounding box (index coordinates) of all turned on voxels.
            Results are cached across calls and updated only when the contents change.
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.BoundBoxOfDataCenterPr">
            <summary>
            Provides the middle of the boundbox of the data (1 voxels) in the patient
            RCS
            </summary>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.BitVol.ComputeDataBBox">
            <summary>
            Computes the exact bounding box (index coordinates) of all turned on voxels.
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ComputeDataBricksBBox">
            <summary>
            Computes the bounding box of all bricks with turned on voxels.
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ComputeDataDiffBBox(Claron.WIF.BitVol)">
            <summary>
            Computes the brick-aligned bounding box that tightly encloses the region
            that changed between this and another bit volume.
            </summary>
            <param name="otherVol">The reference bitvol.
            If Nothing, then it is treated as "unknown" and the full volume box is returned.</param>
            <returns>The bounding box, or Nothing if there is no change.</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.FindClosestManhattanIdxVoxelInMask(Claron.WIF.Vector3_I32)">
            <summary>
            finds the closest voxel in the mask considering distances in voxel index coordinates.
            A course search in brick Manhattan distance up front is followed by a euclidean distance in the closest brick layer.
            </summary>
            <param name="pos"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ComputeExtrema">
            <summary>
            gets the 6 positions of data voxels most extreme in min/max X/Y/Z direction
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.GetStoredValuesCountArray(Claron.WIF.SliceStack)">
            <summary>
            Returns an array with counts of each stored value in all 1 voxel locations of this BitVol
            </summary>
            <param name="ss">The SliceStack to lookup the intensities.</param>
            <returns>A 12b (4096 entries) histogram</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.GetStoredValuesCountArraySubSampled(Claron.WIF.SliceStack)">
            <summary>
            Returns an array with counts of each CT value in all 1 voxel locations of this BitVol
            </summary>
            <param name="ss">The SliceStack to lookup the intensities.</param>
            <returns>A 12b (4096 entries) histogram</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.GetHistogramHu(Claron.WIF.SliceStack)">
            <summary>
            Returns a histogram of modality values in HU in a SliceStack in
            all the corresponding 1 voxel locations.
            </summary>
            <param name="ss">The SliceStack to lookup the intensities.</param>
            <returns>The histogram</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.GradientBasedAutoThreshold(Claron.WIF.SliceStack,System.Int32)">
            <summary>
            Threshold computed as a weighted gradient average of the intensities
            </summary>
            <param name="SS">The slice stack</param>
            <param name="gradPow">Specifies the edge strength, gradPow should be greater than zero</param>
            <returns>The threshold as a stored value</returns>
        </member>
        <member name="M:Claron.WIF.BitVol.ThresholdOtsu(Claron.WIF.SliceStack,System.Boolean)">
            <summary>
            Implementation of Otsu Thresholding methodology
            Otsu N. (1979) "A Threshold Selection Method from Gray Level Histograms" 
            IEEE Trans. on Systems, Man and Cybernetics, 9(1): 62-66
            </summary>
            <param name="SS">The slice stack to pick the intensities from</param>
            <param name="smoothHistogram">Smooth the histogram? (preferred)</param>
            <returns>The threshold bin</returns>
        </member>
        <member name="M:Claron.WIF.BitVol.GetHistogramStored(Claron.WIF.SliceStack)">
            <summary>
            Returns a histogram of stored values in a SliceStack in all the corresponding 1 voxel locations.
            </summary>
            <param name="ss">The SliceStack to lookup the intensities.</param>
            <returns>The histogram</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.GetHistogramStoredSubSampled(Claron.WIF.SliceStack)">
            <summary>
            Returns a histogram of stored values in a SliceStack in all the corresponding 1 voxel locations.
            </summary>
            <param name="ss">The SliceStack to lookup the intensities.</param>
            <returns>The histogram</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.GetHistogramHuSubSampled(Claron.WIF.SliceStack)">
            <summary>
            Returns a histogram of Hu values in a slice stack in all the corresponding 1 voxel locations.
            </summary>
            <param name="ss">The SliceStack to lookup the intensities.</param>
            <returns>The histogram</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Serialize(Claron.WIF.BitVol,System.String)">
             <summary>
            
             </summary>
             <param name="vol"></param>
             <param name="filePath">Default value = "serializedVolBit.dat"</param>
             <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Deserialize(Claron.WIF.BitVol@,System.String)">
             <summary>
            
             </summary>
             <param name="vol"></param>
             <param name="filePath">Default value = "serializedVolBit.dat"</param>
             <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ToBVArray32(System.UInt32[]@,System.Int32,System.Int32)">
            <summary>
            Resizes the given array and stores a VR2-compatible representation in it.
            </summary>
            <param name="outBvArray"></param>
            <param name="FirstZ">Default value = 0</param>
            <param name="LastZ">Default value = I32.MaxValue</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ToBVArray64(System.Int64[]@)">
            <summary>
            Fills the given array with a VR2-compatible 64bit padded representation of this bit vol.
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.ToBVArray64(System.IntPtr,System.UInt32)">
            <summary>
            Fills the given array with a VR2-compatible 64bit padded representation of this bit vol.
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.ToArray3DBoolean">
            <summary>
            Converts to a 3D array of booleans.
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.CopyDataFromArray3DBoolean(Claron.WIF.Array3DBoolean)">
            <summary>
            Copies data from a 3D array of booleans.
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.SubSampleSlices(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new BitVol with fewer slices.
            The difference between the first and second slice index indicates the desired spacing between the slices.
            </summary>
            <param name="firstSliceI">The index of the first slice to keep.</param>
            <param name="secondSliceI">The index of the second slice to keep.</param>
            <param name="lastSliceI">The index of the last slice to keep.</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ToBVArrayUpdate(System.UInt32[]@,Claron.WIF.BitVol)">
            <summary>
            Updates the VR2-compatible representation of the BitVol, efficiently modifying only
            the regions in the representation that have changed since the last time the conversion
            occurred.
            </summary>
            <param name="outBvArray">A reference to the output array. Will be allocated if not provided
            or the one provided is insufficiently large.</param>
            <param name="BvLastConvertedToArray">The bitvol that was last converted into the array. Used to
            limit the conversion only to bricks that have changed, greatly accelerating it. If not
            provided, a clear (all bits are 0) outBvArray array is assumed.</param>
        </member>
        <member name="M:Claron.WIF.BitVol.ToBVArrayUpdate(System.UInt32[]@,Claron.WIF.BoxI32)">
            <summary>
            Updates the VR2-compatible representation of the BitVol
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.ToBase64">
            <summary>
            Converts a BitVol into a minimal size Base64 string representation.
            </summary>
            <returns>The BitVol state as Base64 string.</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ToMinimalByteArray">
            <summary>
            Converts a BitVol into a minimal size byte array representation.
            </summary>
            <returns>The BitVol state as byte[] .</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.ToBitVolFromMinimalByteArray(System.Byte[])">
            <summary>
            Creates an BitVol from an minimal byte[] encoding. Use the matching ToMinimalByteArray to create the buffer
            </summary>
            <param name="bytes">serialized BitVol</param>
            <returns></returns>
        </member>
        <member name="P:Claron.WIF.BitVol.Grid">
            <summary>
            The grid box defining the dimensions, spacing and position (in PatientScan RCS) of the
            Bitvol samples. Set is by value.
            </summary>
        </member>
        <member name="P:Claron.WIF.BitVol.DebugBvIdx">
            <summary> Global property for enabling debug data collection,
            i.e. log info, ing write out or BitVol write out
            (even in release mode) </summary>
        </member>
        <member name="P:Claron.WIF.BitVol.Dims">
            <summary>
            The size of the bit volume.
            </summary>
            <returns>The size of the BitVol.</returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.BitVol.Ubounds">
            <summary>
            The maximum voxel position.
            </summary>
            <returns>The maximum voxel position.</returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.BitVol.SpacingMm">
            <summary>
            The spacing of the voxels.
            </summary>
            <returns>The spacing of the voxels.</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.UI64.PrintBitsInByteCountTable">
            <summary>
            this functions prints the code for the table defining _bitsInByteCounts
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Cube.C.ComputeNBorBits">
            <summary>
            Calculates the Neighbor bits of for each in the cube
            </summary>
            <returns></returns>
        </member>
        <member name="T:Claron.WIF.BitVol.BrickManager">
            <summary>
            Brick manager object creates a pool of bricks which are given out as requested.
            </summary>
        </member>
        <member name="F:Claron.WIF.BitVol.BrickManager.POOL_ALLOCATION_SIZE">
            <summary>
            The allocation size for bricks.
            </summary>
        </member>
        <member name="F:Claron.WIF.BitVol.BrickManager._bricksPool">
            <summary>
            The bricks allocated.
            </summary>
        </member>
        <member name="F:Claron.WIF.BitVol.BrickManager._nextFreeBrick">
            <summary>
            The next free brick.
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickManager.#ctor">
            <summary>
            Creates a new brick manager object.
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickManager.AllocateBricks">
            <summary>
            Allocates bricks.
            </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.BrickManager.GetNewEmptyBrick">
            <summary>
            Returns a new empty brick.
            </summary>
        </member>
        <member name="T:Claron.WIF.BitVol.FillInExtrudedCurveParameters">
            <summary>
            Class to pass parameters needed for cookie cutting thread.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.BitVol.FillInExtrudedCurveParameters._tmpBv">
            <summary>
            The array of temporary BitVols.
            </summary>
        </member>
        <member name="F:Claron.WIF.BitVol.FillInExtrudedCurveParameters._bv2cvMat">
            <summary>
            BitVol grid to curve grid transformation matrix
            </summary>
        </member>
        <member name="F:Claron.WIF.BitVol.FillInExtrudedCurveParameters._bBoxSi">
            <summary>
            A box that restricts where filling of the curve should have effect in the BitVol
            </summary>
        </member>
        <member name="F:Claron.WIF.BitVol.FillInExtrudedCurveParameters._brickCenterOffset">
            <summary>
            Offset to the center of the brick from a brick corner.
            </summary>
        </member>
        <member name="F:Claron.WIF.BitVol.FillInExtrudedCurveParameters._cubeCenterOffset">
            <summary>
            Offset to the center of the cube from a cube corner.
            </summary>
        </member>
        <member name="F:Claron.WIF.BitVol.FillInExtrudedCurveParameters._brickFootPrintRadius">
            <summary>
            The radius of a brick when projected onto the viewport.
            </summary>
        </member>
        <member name="F:Claron.WIF.BitVol.FillInExtrudedCurveParameters._cubeFootPrintRadius">
            <summary>
            The radius of a cube when projected onto the viewport.
            </summary>
        </member>
        <member name="F:Claron.WIF.BitVol.FillInExtrudedCurveParameters._canvas">
            <summary>
            The filled in curve.
            </summary>
        </member>
        <member name="F:Claron.WIF.BitVol.FillInExtrudedCurveParameters._dMap">
            <summary>
            Distance map for the curve.
            </summary>
        </member>
        <member name="F:Claron.WIF.BitVol.FillInExtrudedCurveParameters._sizeX">
            <summary>
            The x-size of the canvas.
            </summary>
        </member>
        <member name="F:Claron.WIF.BitVol.FillInExtrudedCurveParameters._sizeY">
            <summary>
            The y-size of the canvas.
            </summary>
        </member>
        <member name="T:Claron.WIF.BitVol.FrontVoxel">
            <summary>
            The descriptor for a voxel on the dilation/erosion front.
            </summary>
        </member>
        <member name="T:Claron.WIF.BitVol.Iter">
            <summary>
            A class for systematically stepping between all voxels in a bitvol that match
            a certain criteria (eg, all full or empty voxels), as per the GotoNext* function
            call.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.BitVol.Iter._cube">
            <summary>
            _cube contains a bit pattern which tells you which voxels in a
            particular cube are set to 1.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.PosFromLinearOffset(System.Int32)">
            <summary>
            Converts a linear memory offset into the corresponding Xyz position.
            </summary>
            <param name="offset">The linear memory offset where (0,0,0) is at offset 0.</param>
            <returns>The x,y,z-voxel coordinate as Vector3_I32.</returns>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.IsAtBorder6">
            <summary>
            Detects if the current location is a face nbor border point. i.e. if at least one face nbor is outside the mask.
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.VoxelInGet(Claron.WIF.BitVol)">
            <summary>
             The state of the current position's voxel bit in a given bitvol.
             </summary>
             <param name="vol"></param>
             <returns></returns>
             <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.VoxelInSet(Claron.WIF.BitVol,System.Boolean)">
            <summary>
            The state of the current position's voxel bit in a given bitvol.
            </summary>
            <param name="vol"></param>
            <param name="NewValue"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.VoxelInGet(Claron.WIF.VolI64)">
            <summary>
            The state of the current position's voxel bit in a given VolI64.
            </summary>
            <param name="vol"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.VoxelInSet(Claron.WIF.VolI64,System.Int64)">
            <summary>
            The state of the current position's voxel bit in a given VolI64.
            </summary>
            <param name="vol"></param>
            <param name="NewValue"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.VoxelInGet(Claron.WIF.VolI32)">
            <summary>
            The state of the current position's voxel bit in a given VolI32.
            </summary>
            <param name="vol"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.VoxelInSet(Claron.WIF.VolI32,System.Int32)">
            <summary>
            The state of the current position's voxel bit in a given VolI32.
            </summary>
            <param name="vol"></param>
            <param name="NewValue"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.GoToNextVoxel_16">
            <summary>
            Goes to the next voxel.
            </summary>
            <returns>Returns true if we were able to successfully move to the next
            voxel, false if we moved beyond the last voxel in the bit volume.</returns>
            <remarks>The last slice of bricks is completely traversed even if the
            number of slices in the volume is not a multiple of 16 (hence _16 at
            end of name of function). This makes the function significantly
            faster.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.GoToNextNonZeroVoxel">
            <summary>
            Moves the iterator to the next 1 voxel location. Returns true iff a 1 voxel was, indeed,
            found before reaching the end of the bitvol.
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.GoToNextNonZeroVoxelInNextBrick">
            <summary>
            Advances the next non-empty brick, and the first non-empty voxel inside that brick.
            Returns true if such advance is possible.
            Returns false if there is no more data to advance to.
            </summary>
            <returns>
            Returns true if such advance is possible.
            Returns false if there is no more data to advance to.
            </returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.GoToNextNonZeroBrick">
            <summary>
            Advances the next non-empty brick, and the first voxel inside that brick (could be an empty voxel).
            Returns true if such advance is possible.
            Returns false if there is no more data to advance to.
            </summary>
            <returns>
            Returns true if such advance is possible.
            Returns false if there is no more data to advance to.
            </returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.GoToFirstXZSurfaceNonZeroVoxelAndCopyBrick(Claron.WIF.BitVol.IterBox@,Claron.WIF.BitVol,System.Int32[],System.Int32[],System.Boolean)">
            <summary>
            The following 4 functions allow to iterate on all bricks inside iterBox, comprising XZ or YZ surface
            </summary> The bricks  below/above the surface are skipped, the bricks above/below surface are copied to otherVol
            The voxels of bricks which comprise surface are returned consequently to calling function
            <param name="iterBox"></param>
            <param name="otherVol"></param>
            <param name="surfaceMin"></param> the Lower limit of surface per brick
            <param name="surfaceMax"></param> the Upper limit of surface per brick
            <param name="copyAbove"></param>
            <returns></returns> true, if next voxel is found, false - if not
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.GoToNextCubeInSameBrick">
            <summary>
            Goes to next cube inside the current brick, but does not move if the last cube is reached.
            </summary>
            <returns>True if the position has changed. False if we are already in the last cube of the brick.</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.GoToNextVoxelInSameCube">
            <summary>
            Goes to next voxel inside the current cube, but does not move if the last voxel is reached.
            </summary>
            <returns>True if the position has changed. False if we are already at the last voxel of the cube.</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.GoToNextNonZeroZSliceCube">
            <summary>
            Gets next non-empty cube, intersecting with current XY plane
            NOTE: the actual intersection of the cube with the plane can be empty
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.GoToNextBorderVoxelX">
            <summary>
            Assumes it currently is at a border (1 with a 0 neighbor), and moves to the next
            border voxel in storage order (x,y,z in the cube, then in brick).
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.GoToNextConnectedBorderVoxelXZ(System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Returns boundary voxels in order of their appearance in contour, while going clockwise
            The stop condition : the first voxel with the origin border direction is reached
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.GoToNextConnectedBorderVoxelXZ(System.Int32)">
            <summary>
            Check the possible direction to next border pixel, starting from the direction
            to the previous border pixel + 1(mod 4), and picking the directions clockwise
            The first found direction, for which the next pixel is in the BitVol, is the direction
            and the pixel where the iterator moves.
            </summary>
            <param name="prevDir"></param> the direction from prev border pixel to current border pixel
            <returns></returns> the direction from current border pixel to the next border pixel
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.GoToNextBorderVoxelXZ">
            <summary>
            Assumes it currently is at a border (1 with a 0 neighbor), and moves to the next
            border voxel in storage order (x,y,z in the cube, then in brick).
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.GoToNextBorderVoxel">
            <summary>
            Can be called with the iterator at any location.
            Moves the iterator to the next border voxel in storage order (x,y,z in the cube, then in brick).
            Returns the first direction index (0=MinX, 1=MaxX, 2=MinY, 3=MaxY, 4=MinZ, 5=MaxZ) in which there is a nbor that is not turned on.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.GoToNextBorderVoxelXy">
            <summary>
            Can be called with the iterator at any location.
            Moves the iterator to the next xy-border voxel in storage order (x,y,z in the cube, then in brick).
            Returns the first direction index (0=MinX, 1=MaxX, 2=MinY, 3=MaxY) in which there is a nbor that is not turned on.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.GoToNextBorderVoxel(System.Int32,System.Int32)">
            <summary>
            assumes it currently is at a border
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.NBorOut6">
            <summary>
            Counts how many of the 6-connected face nbors are outside the mask.
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.NBorOut26">
            <summary>
            Counts how many of the 26-connected face/edge/corner nbors are outside the mask.
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.GoToNextXSliceVoxel">
            <summary>
            assumes it currently is at desired X slice
            </summary>
            <remarks>x slice = a slice with the x-axis as normal</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.GoToNextYSliceVoxel">
            <summary>
            assumes it currently is at desired Y slice
            </summary>
            <remarks>y slice = a slice with the y-axis as normal</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.GoToNextZSliceVoxel">
            <summary>
            assumes it currently is at desired Z slice
            </summary>
            <remarks>z slice = a slice with the z-axis as normal</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.GoToPrevZSliceVoxel">
            <summary>
            assumes it currently is at desired Z slice
            </summary>
            <remarks>z slice = a clice with the z-axis as normal</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.IsNeighbourOffAtMinX">
            <summary> Returns if the neighbor is off (true) or on (false), without moving the iterator. </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.IsNeighbourOffAtMaxX">
            <summary> Returns if the neighbor is off (true) or on (false), without moving the iterator. </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.IsNeighbourOffAtMinY">
            <summary> Returns if the neighbor is off (true) or on (false), without moving the iterator. </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.IsNeighbourOffAtMaxY">
            <summary> Returns if the neighbor is off (true) or on (false), without moving the iterator. </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.IsNeighbourOffAtMinZ">
            <summary> Returns if the neighbor is off (true) or on (false), without moving the iterator. </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.IsNeighbourOffAtMaxZ">
            <summary> Returns if the neighbor is off (true) or on (false), without moving the iterator. </summary>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.MoveToNextNbor6(System.Int32)">
            <summary>
            Moves the iterator in a circle around all nbor positions.
            </summary>
            <param name="prevNborI">The step index of the previous step along the list of Nbor positions.</param>
            <returns>the NborI to use as argument for the next call to this function.</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.MoveToNext2DNbor8(System.Int32)">
            <summary>
            Moves the iterator in a circle around all nbor positions in 2D. Use -1 to 2 for "4" 
            neighborhood and -1 to 6 for all 8 neighbors
            </summary>
            <param name="prevNborI">The step index of the previous step along the list of Nbor positions.</param>
            <returns>the NborI to use as argument for the next call to this function.</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.MoveToNextNbor26(System.Int32)">
            <summary>
            Moves the iterator in a circle around all nbor positions.
            </summary>
            <param name="prevNborI">The step index of the previous step along the list of Nbor positions.</param>
            <returns>the NborI to use as argument for the next call to this function.</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.GoToLocallyClossestMaskVoxel(Claron.WIF.Vector3)">
            <summary>
            Relocates the iterator to the mask position at the edge of the mask closses to the given position.
            </summary>
            <param name="target">the position to move toward</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.Iter.GoToNextLocallyClossestMaskVoxel(Claron.WIF.Vector3)">
            <summary>
            Relocates the iterator by one step towards the mask position at the edge of the mask closses to the given position.
            </summary>
            <param name="target">the position to move toward</param>
            <remarks></remarks>
            <returns>True if we actually moved to a new location, false if we did not move (we are as close as possible).</returns>
        </member>
        <member name="P:Claron.WIF.BitVol.Iter.BrickI">
            <summary>
            Index of brick containing the current voxel position
            </summary>
        </member>
        <member name="P:Claron.WIF.BitVol.Iter.cubeI">
            <summary>
            Index of cube containing the current voxel position
            </summary>
        </member>
        <member name="P:Claron.WIF.BitVol.Iter.VoxelI">
            <summary>
            Index of current voxel position in the current cube
            </summary>
        </member>
        <member name="P:Claron.WIF.BitVol.Iter.PosXyz">
            <summary>
            The current voxel coordinates in the bitvol grid
            </summary>
            <value></value>
        </member>
        <member name="P:Claron.WIF.BitVol.Iter.PosXyzPr">
            <summary>
            The current voxel coordinates in the PatientScan RCS
            </summary>
            <value></value>
        </member>
        <member name="P:Claron.WIF.BitVol.Iter.PosXyzSr">
            <summary>
            The current voxel coordinates in Bitvol (its Grid) RCS, which is
            usually the same as the RCS of the slice-stack it references (ie, Sr).
            </summary>
            <value></value>
        </member>
        <member name="P:Claron.WIF.BitVol.Iter.PosXyzV3">
            <summary>
            The current voxel coordinates in the bitvol grid provided as a Vector3 structure.
            </summary>
        </member>
        <member name="P:Claron.WIF.BitVol.Iter.Voxel">
            <summary>
            The state of the current position's voxel bit.
            </summary>
        </member>
        <member name="T:Claron.WIF.BitVol.IterBox">
            <summary>
            A sub-class of Iter, confining the stepping  to be only within a given box.
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.BitVol.IterGeneralDirection">
            <summary>
            A sub-class of Iter, forcing the stepping to be in the direction of a given vector.
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.BitVol.MapperIter">
            <summary>
            Class to iterate over bit volume in RCS coordinates.
            </summary>
            <remarks>Use property .XyzVoxel to retrieve the x-y-z voxel coordinate
            values and .XyzRcs to obtain the corresponding coordinates in the
            RCS.</remarks>
        </member>
        <member name="F:Claron.WIF.BitVol.MapperIter._vol">
            <summary>
            The bit volume being iterated over.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.BitVol.MapperIter._brick">
            <summary>
            The current brick.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.BitVol.MapperIter._cube">
            <summary>
            _cube contains a bit pattern which tells you which voxels in a
            particular cube are set to 1. A cube is grid of 4 x 4 x 4 voxels
            with bit 0 corresponding to voxel (0, 0, 0), bit 1
            corresponding to voxel (1, 0, 0), ..., and bit 63 corresponding to
            voxel (3, 3, 3).
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.BitVol.MapperIter._brickI">
            <summary>
            The index of the current brick in the bit volume being iterated over.
            A brick is a collection of 4 x 4 x 4 cubes.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.BitVol.MapperIter._cubeI">
            <summary>
            The index of the current cube in the bit volume being iterated over.
            A cube is a collection of 4 x 4 x 4 voxels.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.BitVol.MapperIter._voxelI">
            <summary>
            The index of the current voxel in the bit volume being iterated over.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.BitVol.MapperIter._bBox">
            <summary>
            The box within the bit volume within which the traversal
            is restricted to.
            </summary>
        </member>
        <member name="F:Claron.WIF.BitVol.MapperIter._mappedPositionVoxel">
            <summary>The location of the current voxel in RCS space.</summary>
        </member>
        <member name="F:Claron.WIF.BitVol.MapperIter._mappedPositionCube">
            <summary>The beginning of the current cube in RCS space.</summary>
        </member>
        <member name="F:Claron.WIF.BitVol.MapperIter._mappedPositionBrick">
            <summary>The beginning of the current brick in RCS space.</summary>
        </member>
        <member name="F:Claron.WIF.BitVol.MapperIter._mappedPositionIncVoxelX">
            <summary>
            Incremental vector which moves from current to next voxel in
            x-direction.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.BitVol.MapperIter._mappedPositionIncVoxelY">
            <summary>
            Incremental vector which moves from current to next voxel in
            y-direction.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.BitVol.MapperIter._mappedPositionIncVoxelZ">
            <summary>
            Incremental vector which moves from current to next voxel in
            z-direction.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.BitVol.MapperIter._mappedPositionIncCubeX">
            <summary>
            Incremental vector which moves from current cube to next cube in
            x-direction.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.BitVol.MapperIter._mappedPositionIncCubeY">
            <summary>
            Incremental vector which moves from current cube to next cube in
            y-direction.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.BitVol.MapperIter._mappedPositionIncCubeZ">
            <summary>
            Incremental vector which moves from current cube to next cube in
            z-direction.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.BitVol.MapperIter._mappedPositionIncBrickX">
            <summary>
            Incremental vector which moves from current brick to next brick in
            x-direction.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.BitVol.MapperIter._mappedPositionIncBrickY">
            <summary>
            Incremental vector which moves from current brick to next brick in
            y-direction.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.BitVol.MapperIter._mappedPositionIncBrickZ">
            <summary>
            Incremental vector which moves from current brick to next brick in
            z-direction.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.MapperIter.#ctor(Claron.WIF.BitVol,System.Double[])">
            <summary>
            Creates a new iterator.
            </summary>
            <param name="vol">The bit volume to iterate over.</param>
            <param name="matrix">4x4 Homogenous transformation matrix which maps BitVol index
            coordinates to the target coordinate system (see GridBox.HomoMat4x4GridToPatientScanRcs)
            </param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.MapperIter.#ctor(Claron.WIF.BitVol,System.Double[],Claron.WIF.BoxI32)">
            <summary>
            Creates a new iterator.
            </summary>
            <param name="vol">The bit volume to iterate over.</param>
            <param name="matrix">4x4 Homogenous transformation matrix which maps BitVol index
            coordinates to the target coordinate system (see GridBox.HomoMat4x4GridToPatientScanRcs)
            </param>
            <param name="bBox">The box within the bit volume to restrict the
            iteration over. Default value = null</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.MapperIter.GoToNextVoxel_16(System.Boolean)">
            <summary>
            Goes to the next voxel.
            </summary>
            <param name="goToNextCube">Set to False if the iterator should not
            move to the next cube. Default value = True</param>
            <returns>Returns true if we were able to successfully move to the next
            voxel, false if we moved beyond the last voxel in the bit volume.
            </returns>
            <remarks>The last slice of bricks is completely traversed even if the
            number of slices in the volume is not a multiple of 16 (hence _16 at
            end of name of function). This makes the function significantly
            faster.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.MapperIter.GoToNextCube_16(System.Boolean)">
            <summary>
            Goes to the next cube.
            </summary>
            <param name="goToNextBrick">Set to False if the iterator should not
            move to the next brick. Default value = True</param>
            <returns>Returns true if we were able to successfully move to
            the next cube, false if we moved beyond the last cube in the bit
            volume.</returns>
            <remarks>The last slice of bricks is completely traversed even if the
            number of slices in the volume is not a multiple of 16 (hence _16 at
            end of name of function). This makes the function significantly
            faster.</remarks>
        </member>
        <member name="M:Claron.WIF.BitVol.MapperIter.GoToNextBrick_16">
            <summary>
            Goes to the next brick.
            </summary>
            <returns>Returns true if we were able to successfully move to
            the next brick, false if we moved beyond the last brick in the bit
            volume.</returns>
            <remarks>The last slice of bricks is completely traversed even if the
            number of slices in the volume is not a multiple of 16 (hence _16 at
            end of name of function). This makes the function significantly
            faster.</remarks>
        </member>
        <member name="P:Claron.WIF.BitVol.MapperIter.Cube">
            <summary>
            Property to get/set cube values.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.BitVol.MapperIter.BrickI">
            <summary>
            Property to get/set the brick index.
            </summary>
            <value>The new brick index value.</value>
            <returns>The current brick index value.</returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.BitVol.MapperIter.CubeI">
            <summary>
            Property to get/set the cube index value.
            </summary>
            <value>The new cube index value.</value>
            <returns>The current cube index value.</returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.BitVol.MapperIter.VoxelI">
            <summary>
            Property to get/set the voxel index value.
            </summary>
            <value>The new voxel index value.</value>
            <returns>The current voxel index value.</returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.BitVol.MapperIter.XyzVoxel">
            <summary>
            Returns the position of the voxel (in voxel coordinates) that the
            iterator is currently at.
            </summary>
            <value>The position of the voxel (in voxel coordinates) that the
            iterator is to be positioned at.
            </value>
            <returns>The position of the voxel (in voxel coordinates) that the
            iterator is currently at.</returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.BitVol.MapperIter.XyzRcs">
            <summary>
            Returns the position of the voxel (in the RCS) that the
            iterator is currently at.
            </summary>
            <value>The position of the voxel (in the RCS) that the
            iterator is currently at.</value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.BitVol.MapperIter.Voxel">
            <summary>
            Returns the voxel value.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.BitVol.MapperIter.BBox">
            <summary>
            Property for setting/getting the volume within which the iterator
            should be restricted to moving over.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.BitVol.BitPattern">
            <summary>
            for debugging support, type 'new BitPattern(u64variable)' in debugger to see the 64 bits in a useful cube pattern
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.I28BrickCubeVoxel._bits">
            <summary>
            stores four numbers in a single I64
            I Int28 : 28b
            B brick : 24b -> 768x768x6710 max volume size
            C cube :  6b
            V voxel :  6b
            </summary>
        </member>
        <member name="M:Claron.WIF.I28BrickCubeVoxel.ToVectorI32(Claron.WIF.BitVol,Claron.WIF.I28BrickCubeVoxel[])">
            <summary>
            Converts an array of I28BrickCubeVoxel[] to the equivalent Vector3_I32[]
            for a given bitvol.
            </summary>
            <param name="bv"></param>
            <param name="BVCs"></param>
            <returns></returns>
        </member>
        <member name="T:Claron.WIF.Camera">
             <summary>
             <para>Camera converts 3D input data (volumetric or geometric) to a displayable (32b ARGB buffer)
             image output using one of a range of available projection methods:
             orthographic or perspective full-volume projection, flat plane/slab,
             1-D, 2-D or 3-D curved plane/slab/projection.</para>
            
             <para>The key function is Render(), which refreshes OutArgb, the output 2D color array.
             The rendering sampling locations are determined by the output grid box
             (controlled by the client) and the spatial mapping between the output and input grid boxes.
             The input grid box is obtained from the input SliceStack.
             The camera itself is located in its grid RCS at the position
             Grid.RCSCoord(0.5, 0.5, 0.5) in Slab and CurvedSlab modes and at
             Grid.RCSCoord(0.5, 0.5, 0) otherwise (regular 3D projections). </para>
            
             <para>The operation performed to combine samples along a virtual 3D ray into a
             color in the output picture is controlled by a variety of other properties.
             The output will typically be used by a Viewport object for display in a region on the
             screen.</para>
            
             <para>The renderer may also be used "in reverse" to probe the 3D grid locations associated with
             output 2D picture locations.</para>
            
             <para>When the input SliceStack contains only a single slice, the camera performs
             only 2D operations: pan/zoom and windowing.</para>
            
             <para>The 3D rendering computation is actually performed by the VR2 renderer library, which is
             written in C and compiled separately. See the document "The VR2 Renderer" for
             more details on VR2 and its API.</para>
             </summary>
        </member>
        <member name="F:Claron.WIF.Camera.czHistUbound">
            <summary>
            For iso-surface conversion.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Camera._outImageU12">
             <summary>
             The array's 2D dimensions are determined by the OutputPictureGrid
             </summary>
            
        </member>
        <member name="M:Claron.WIF.Camera.TissueColorwashImage(System.Int32)">
            <summary>
            A byte image reflecting the colorwash region drawn for a given
            Tissue, or Nothing if the tissue colorwash was not enabled in the most recent
            render call.
            </summary>
            <param name="TissueI">Tissue index</param>
            <returns>An image of dimensions at least as large as the camera grid (but may be larger),
            with pixels in raster order, or Nothing if such image is not available.
            Values are 0 outside, 1 inside the boundary and 2 or higher on the boundary.
            The value returned is the actual image used by the Camera object, so don't modify it directly
            - create a copy first.</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Camera.TissueColorwashImage(Claron.WIF.Tissue)">
            <summary>
            A byte image reflecting the colorwash region drawn for a given
            Tissue, or Nothing if the tissue colorwash was not enabled in the most recent
            render call.
            </summary>
            <param name="Tis">The Tissue</param>
            <returns>An image of dimensions at least as large as the camera grid (but may be larger),
            with pixels in raster order.
            Values are 0 outside, 1 inside the boundary and 2 or higher on the boundary.
            The value returned is the actual image used by the Camera object, so don't modify it directly
            - create a copy first.</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Camera.IsoSurfaceNormal(System.Drawing.Point)">
            <summary>
            Returns the surface normal of the IsoSurface, in camera RCS, for a given output
            buffer location. The normal may be invalid if it cannot be obtained.
            </summary>
            <param name="AtXY">Location in output grid</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Camera._CizQ16Image">
            <summary>
            A buffer, the size of the output image (outArgb), which, for every output pixel, maintains
            the cameras index z (depth) coordinate of the pixel written there, in fixed point with 16 bit fraction
            (Q16) format.
            The buffer is updated only in certain modes.
            </summary>
        </member>
        <member name="F:Claron.WIF.Camera._czHitTestImage">
            <summary>
            0: for background
            1: Body
            100: 1st Visible surface in _visibleSurfaces array
            101: 2nd Visible surface in _visibleSurfaces array
            102: 3rd Visible surface in _visibleSurfaces array
            ..
            ..
            </summary>
        </member>
        <member name="M:Claron.WIF.Camera.OutHeightAsU12(System.Double)">
            <summary>
            Returns the depth buffer (OutCizQ16) of converted to a height map in specified real-world units.
            The closest location is set to 4095, and farther locations to smaller numbers based on
            the spacing (mm per depth unit) specified.
            Background locations, or any location lower in height than the value of 1, is set to 0.
            If not IsCizValid, returns null.
            The z spacing of the grid of the returned image is set to MmPerPixelUnit
            </summary>
        </member>
        <member name="F:Claron.WIF.Camera.outArgbPerInSliceStack">
            <summary>
            In case the outArgb buffer needs to be cached per input stack, two dictionaries are
            used (see SliceStackCyclingCachingEnabled), with the VR2ID property of the slice stack
            used as the key for the dictionary.
            </summary>
        </member>
        <member name="M:Claron.WIF.Camera.RecordArgbUpdate">
            <summary>
            This function should be called whenever the outArgb buffer has been updated.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Camera.TissueSet(System.Int32,Claron.WIF.Tissue)">
            <summary>
            Sets the Camera's i-th tissue. 
            Note that only the first 7 (i in [0,6]) tissues can be rendered in 3D.
            Any higher index tissue will only show up in a 2D Viewport.
            </summary>
            <param name="i">The Tissue index</param>
            <param name="NewValue">The Tissue te reference for that index.</param>
        </member>
        <member name="M:Claron.WIF.Camera.TissuePresetGet(System.Int32)">
            <summary>
            The viewing preset for tissue i. If Nothing (default), the ARGB LUT associated with
            the tissue is used as is (client responsibility). Preset parameters other than ARGB are ignored.
            </summary>
            <param name="i"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Camera.TissuePresetSet(System.Int32,Claron.WIF.RenderingPreset)">
            <summary>
            The viewing preset for tissue i. If Nothing (default), the ARGB LUT associated with
            the tissue is used as is (client responsibility). Preset parameters other than ARGB are ignored.
            </summary>
            <param name="i"></param>
            <param name="NewValue"></param>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Camera._LastRenderSecs">
            <summary>
              Execution time, in seconds, of the last render. Negative if never rendered.
            </summary>`
        </member>
        <member name="F:Claron.WIF.Camera._lastRenderVR2Secs">
            <summary>
              Execution time, in seconds, of the last render call to VR2. Does not include setup time.
            </summary>`
        </member>
        <member name="F:Claron.WIF.Camera._debugVr2">
            <summary>
            If true, VR2 debugging mode is enabled
            </summary>
        </member>
        <member name="F:Claron.WIF.Camera._suggestedNumOfThreads">
            <summary>
            Number of threads to use when doing the rendering. A value if 0 will automatically set
            the number of threads depending on the processors
            </summary>
        </member>
        <member name="M:Claron.WIF.Camera.SetRotationToPatientView(Claron.WIF.SpaceMapperSimilarity,Claron.WIF.Camera.PatientViewDirection)">
            <summary>
            Sets the rotation of the given mapper so that the source (eg, camera) will view the
            patient from the given direction.
            </summary>
        </member>
        <member name="M:Claron.WIF.Camera.SetPatientView(Claron.WIF.Camera.PatientViewDirection)">
            <summary>
            Sets the viewing direction in the ToPatient mapper to one of the standard orientations relative to the patient
            </summary>
        </member>
        <member name="M:Claron.WIF.Camera.SetToSliceOrientation">
            <summary>
            Set the mapping of ToPatientScan so that the camera's X and Y axes will be parallel
            to InSliceStack's XY axes (slice plane)
            </summary>
        </member>
        <member name="M:Claron.WIF.Camera.SetViewCenterToStackCenter">
            <summary>
            Modifies the ToPatientScan mapper so that the center of the input slice stack
            is placed at the center of the view grid.
            </summary>
            <remarks>Does nothing if there is no input slice stack</remarks>
        </member>
        <member name="F:Claron.WIF.Camera._renderingGridFactor">
            <summary>
            It is a factor by which the size of the Camera.grid is reduced 
            for interactive rendering.
            Its a ratio of Camera.Grid.DimX/VP.Grid.DimX
            </summary>
        </member>
        <member name="F:Claron.WIF.Camera._LumenRibbonRollRadians">
            <summary>
            Specifies the ribbon's angle around the lumen's centerline
            </summary>
        </member>
        <member name="M:Claron.WIF.Camera.TissueEnabledGet(System.Int32)">
            <summary>
            Controls whether tissue i would affect the rendering or be ignored
            </summary>
            <param name="i"></param>
        </member>
        <member name="M:Claron.WIF.Camera.TissueEnabledSet(System.Int32,System.Boolean)">
            <summary>
            Controls whether tissue i would affect the rendering or be ignored
            </summary>
            <param name="i"></param>
            <param name="NewValue"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Camera.DisableAllTissues">
            <summary>
            Disable all tissues in rendering
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Camera.EnableAllTissues">
            <summary>
            Enables all tissues in rendering
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Camera.TissuesClear">
            <summary>
            Sets all tissues to Nothing and disables them
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Camera.ColorwashOutlineGet(System.Int32)">
            <summary>
            Determines whether the colorwash is shown using only the outside contour for all tissue.
            Use ColorwashOutlineGet/Set to determine it separately for individual tissues.
            </summary>
        </member>
        <member name="M:Claron.WIF.Camera.ColorwashOutlineSet(System.Int32,System.Boolean)">
            <summary>
            Determines whether the colorwash is shown using only the outside contour.
            The outside contour consists of "in" pixels that have an "out" neighbor (including outside
            the picture region).
            </summary>
            <param name="i"></param>
            <param name="NewValue"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Camera.#ctor">
             <summary>
             Returns a copy with references to same externally-assigned objects, but with a new copy of private objects (eg, Grid).
             </summary>
            
        </member>
        <member name="M:Claron.WIF.Camera.#ctor(System.Boolean)">
             <summary>
            
             </summary>
             <param name="UseRemoter">If true, a CameraRemoter object will be used to do the actual rendering.
             This object can be configured to be instantiated on a server.</param>
             <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Camera.Clone">
            <summary>
            Returns a relatively "shallow" copy of the camera.
            References to input objects (other than Grid and, therefore, ToPatientScan) are copied, not
            the objects themselves.
            </summary>
        </member>
        <member name="M:Claron.WIF.Camera.SetAs(Claron.WIF.Camera)">
            <summary>
            Sets the properties of this camera to the same values as another.
            Input objects that may be shared with other cameras are not copied, only their references.
            </summary>
            <remarks>Temporary buffers are cleared/erased</remarks>
        </member>
        <member name="M:Claron.WIF.Camera.SetViewGeometryAs(Claron.WIF.Camera)">
            <summary>
            Set the pan, zoom, orientation and front clipping plane properties to be the same as another camera.
            Useful for synchronizing the views of multiple 3D views
            </summary>
            <param name="other">The camera to copy from</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Camera.ResetRenderingProperties">
            <summary>
            Sets all the viewport's visual output control properties to their default values
            (as if after New). Does not affect any of the input and output references (including
            the rendering preset).
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Camera.FreeVr2CacheMemory">
            <summary>
            Frees up all the VR2 cache memory used for the camera. Has no negative
            effect except that the subsequent rendering call would be slower.
            </summary>
        </member>
        <member name="M:Claron.WIF.Camera.CurvedSlabSiQ16">
            <summary>
            An array of at least (grid.dim.X x grid.dim.Y x 3) Int64 of Si coordinates 
            corresponding to the center of each pixel-ray in the curved slab output buffer.
            Stored in Q16 representation (48b integer . 16b fraction).
            Note: could be larger than the grid, so use grid dimensions to iterate on it.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Camera.CurvedSlabSi(System.Double,System.Double)">
            <summary>
            Maps the position of a point in camera index coordinates (Ci) to a slice-stack index 
            coordinate (Si). If it is undefined, an invalid vector is returned.
            </summary>
            <param name="CiX"></param>
            <param name="CiY"></param>
            <returns></returns>
        </member>
        <member name="F:Claron.WIF.Camera.resultsQue">
            Que containing the RenderResults, recieved from the CameraRemoter
        </member>
        <member name="F:Claron.WIF.Camera.renderRequestInvervals">
            <summary>
            Used for image compression quality adjustment in client/server mode
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Camera.lastCompresssionQuality">
            <summary>
            TO dynamically adjust the image compression quality in client/server mode
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Camera.RemoteRenderCallBack(System.IAsyncResult)">
            <summary>
            The callBack for Remoter.Render function
            </summary>
            <param name="ar"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Camera.SortResultsQue">
            <summary>
            Sort the images as per the renderID
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Camera.RenderMutex">
            <summary>
            This mutex protects against changes to the rendering parameters (eg, pointers) while
            rendering is being executed by VR2. This state is possible when rendering calls are made
            by different threads in the same process, but not across processes.
            Since the paramater setting is fast and VR2 itself is protected by a mutex against
            re-entrance in the same process, thereis almost no benefit in allowing multiple rendering
            parameter structures to filled in parallel by multiple threads.
            </summary>
        </member>
        <member name="F:Claron.WIF.Camera._postRenderingDelegates">
            <summary>
            Array storing delegates which are called when a render is done.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Camera._WindowedArgb">
            <summary>
            A windowed output image, with A=0xff and RGB are the same windowed byte
            </summary>
        </member>
        <member name="F:Claron.WIF.Camera._colorwashImage">
            <summary>
            Colorwash image.
            </summary>
        </member>
        <member name="F:Claron.WIF.Camera._lastClearTicks">
            <summary>
            For clearing output.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Camera.Render">
            <summary>
            Projects virtual rays from the camera plane onto a slice stack to produce output picture.
            </summary>
            <remarks>Minimal computation is performed (none if nothing changed since last render).
            The output is written to OutArgb.
            Will throw an exception if rendering fails.</remarks>
        </member>
        <member name="M:Claron.WIF.Camera.IsRenderNeeded">
            <summary>
            Indicates whether the input SliceStack data needs to be rendered (ie, raycast/reformat etc.) to
            reflect a change in input.
            </summary>
        </member>
        <member name="M:Claron.WIF.Camera.Render(Claron.WIF.Camera.RefreshParam@,Claron.WIF.Camera.RenderResults@,System.Boolean)">
            <summary>
            Projects virtual rays from the camera plane onto a slice stack to produce output picture.
            </summary>
            <remarks>Minimal computation is performed (none if nothing changed since last render).
            The output is written to OutArgb.
            Will throw an exception if rendering fails.</remarks>
        </member>
        <member name="M:Claron.WIF.Camera._Render(Claron.WIF.Vector3[],Claron.WIF.Camera.RefreshParam@,Claron.WIF.Camera.RenderResults@,System.Boolean,System.Boolean,Claron.WIF.Vector3[]@)">
            <summary>
            Generates the output image or maps coordinates form image index to
            stack RCS.
            </summary>
            <param name="CCoords">Image index coordinates to map. If Nothing, performs a full render.</param>
            <param name="refreshParams"></param>
            <param name="outRenderResults"></param>
            <param name="bringResults2Client"></param>
            <param name="doOnlyWindowing"></param>
            <param name="outSCoords">The mapped coordinates in Si</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Camera.GetRenderingParamsAsString">
            <summary>
            Converts the current rendering parameters to a string.
            </summary>
        </member>
        <member name="M:Claron.WIF.Camera.PinMarshaledData">
            <summary>
            Pins the local data buffers/vars that need to be passed to VR2 by reference pointers.
            Should be called after _RP is already set other than the pointers.
            </summary>
            <remarks>Each Alloc has to have a symmetrical Free in UnpinMarshaledData</remarks>
        </member>
        <member name="M:Claron.WIF.Camera.PinPolygonArray(Claron.WIF.Camera.PolygonArrayApi@)">
            <summary>
            Given a PolygonArrayApi instance with the polys.polygonsVB() array filled in,
            pins it in memory and updates the GC handles and IntPtr
            </summary>
            <param name="polys">the structure to update</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Camera.UnpinMarshaledData">
            <summary>
            Reverses the effect of PinMarshaledData. Harmless if called redundantly.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Camera.ExtrudeLineOnRibbonView(Claron.WIF.Vector3,Claron.WIF.Vector3)">
            <summary>
            Fills in the bit volume interior to the surface generated by
            extruding the line segment(drawn on the Ribbon viewport) 
            specified in Ci cordinates (ie, perpendicular to its XY plane).
            Currently does not support RibbonStretchedHorizontally=true.
            </summary>
            <param name="linePtCi0">End point of the line in Ci</param>
            <param name="linePtCi1">End point of the line in Ci</param>
            <returns>Bitvol with interior filled in the extruded region, returns null if _lumenForRibbon is null</returns>
        </member>
        <member name="M:Claron.WIF.Camera.UpdateLumenCenterlineSectionToRender">
            <summary>
            Updates LumenCenterlineSectionToRender to reflect the state of the parameters controlling
            the portion of the lumen centerline to be rendered in the output buffer.
            </summary>
        </member>
        <member name="M:Claron.WIF.Camera.UpdateCurvedSlabFromLumen">
            <summary>
            Enables and defines the geometry of a singly-curved slab for a stretched view of
            a lumen.
            See CurvedSlabDescriptor for details on the structure this function updates.
            </summary>
        </member>
        <member name="M:Claron.WIF.Camera.DisableCurvedSlab">
            <summary>
            Disables curved slab rendering
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Camera.WindowingAndColorwash__OutArgbCopy">
            <summary>
            Updates OutArgb from the Image16b using WL/WW and BitVol reformatting as needed.
            </summary>
        </member>
        <member name="F:Claron.WIF.Camera.IsTissueBorderThick">
            <summary>
            If set true, thickens tissue border to 3 pixels.
            </summary>
        </member>
        <member name="M:Claron.WIF.Camera.ColorwashImageTagOutline(System.Int32)">
            <summary>
            Ensures non-zero colorwash image 1-pixels that have a 0 6-neighbor are assigned
            a value higher than 1 (while internal ones have a value of 1)
            ''' </summary>
            <param name="TissueI"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Camera.ApplyDepthFadeToOutARGB(System.Int32[])">
            <summary>
            Darkens the ARGB values in a depth ramp starting at
            a small fraction of the depth histogram ramping down to
            black DepthFadeRampMm afterwards, or performing auto-exposure
            correction if DepthFadeRampMm is 0
            </summary>
            <param name="CzQ16Image"></param>
        </member>
        <member name="M:Claron.WIF.Camera.ApplyTransparencyToOutArgb(System.Double)">
            <summary>
            Reduces the alpha value in each _OutArgb pixel according to the 
            given TransparencyFraction.
            </summary>
            <param name="TransparencyFraction"></param>
        </member>
        <member name="M:Claron.WIF.Camera.ApplySoftShadowsToOutARGB(System.Int32[])">
            <summary>
            Add soft shadows to the image, with strength based on SoftShadows0to1
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Camera.ConvertIsoSurfaceToARGB">
            <summary>
            Maps the IsoSurface rendering buffer to ARGB values in out ARGB 
            according to IsoSurfaceRgbaType
            </summary>
        </member>
        <member name="M:Claron.WIF.Camera.BitvolOfRenderedRegion(System.Double)">
            <summary>
            Returns a bitvol (in InSliceStack grid), representing the
            region over which rendering is being done. It accounts for the grid of InSliceStack,
            the camera grid (viewing frustum), clipper (if enabled), and Mask (if enabled).
            Currently does not properly accounts for perspective rendering.
            </summary>
            <param name="OpacityThresholdFraction">If larger than 0 (default) in shaded rendering mode,
            only voxels with opacity fraction (alpha) above the threshold (based on the mapping of the
            rendering preset) are included. Ignored in other rendering modes.</param>
            <returns>A bitvol InSliceStack grid coordinates, or Nothing if
            there is no InSliceStack</returns>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Camera._hashCodeUsePixelData">
            <summary>
            Property to get/set whether the pixel data should be used when
            calculating the hash code.
            </summary>
        </member>
        <member name="M:Claron.WIF.Camera.GetHashCode">
            <summary>
            Returns the hash code of the Camera object.
            </summary>
        </member>
        <member name="M:Claron.WIF.Camera.Save16bImgAsPngColor(System.String)">
            <summary>
            Saves the current 16b buffer as .PNG image with the current date_time in the filename.
            No modification to the 16b image is made, but
            it overwrites the current RGBA buffer in the process
            by reapplying the window leveling  with added color enhancement outside the WL ramp.
            </summary>
            <param name="pathAndFileNameBase">The path and base filePath of the image. Date_time.png will be added.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Camera.Save16bImgAsPngGray(System.String)">
            <summary>
            Saves the current 16b buffer as .PNG image with the current date_time in the filename.
            No modification to the 16b image is made, but
            it overwrites the current RGBA buffer in the process
            by reapplying the window leveling  with added color enhancement outside the WL ramp.
            </summary>
            <param name="pathAndFileNameBase">The path and base filePath of the image. Date_time.png will be added.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Camera.ArgbBitmap">
            <summary>
            Returns a bitmap showing the contents of OutARGB.
            Note that an internal buffer is reused for efficiency, so the caller should
            make a clone if it wants to preserve the returned bitmap across calls..
            </summary>
        </member>
        <member name="M:Claron.WIF.Camera.ArgbToBitmap(System.UInt32[],System.Int32,System.Int32)">
            <summary>
            Returns a bitmap showing the contents of an ARGB buffer.
            Note that an internal buffer is reused for efficiency, so the caller should
            make a clone if it wants to preserve the returned bitmap across calls..
            </summary>
            <param name="Argb">An array of ARGB pixels</param>
            <param name="DimX">The length of each line in the buffer</param>
            <param name="DimY">The number of lines in the buffer</param>
        </member>
        <member name="M:Claron.WIF.Camera.SaveArgbAsPng(System.String)">
            <summary>
            Saves the current ARGB image buffer as .PNG image with the current date_time in the filename.
            No modification of the image is made.
            </summary>
            <param name="pathAndFileNameBase">The path and base filePath of the image. Date_time.png will be added.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Camera.ShowOutputImage">
            <summary>
            Pops up a window on the screen showing the current RGBA output image of the camera.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Camera.SetMappingForFullFrameSideView(System.Double)">
            <summary>
            Sets the Grid and ToPatientScan values to generate a full side view of the stack (+-X,+-Y)
            with no margins.
            The sampling rate in Z is set to 1/2 xy voxel size to ensure top quality rendered image.
            </summary>
            <param name="GridXYMmPerPixel">The desired resolution of the output buffer grid</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Camera.MipOfVolumeVertically(Claron.WIF.BoxI32,Claron.WIF.Tissue,System.Single)">
            <summary>
            Project the whole volume along any line in the SliceStack's axial plane.
            The direction of projection is the x-axis rotated by projectionAngleDeg.
            The y-axis of the resulting image is oriented along z-axis of the SliceStack.
            </summary>
            <param name="box"></param>
            <param name="vessels"></param>
            <param name="projectionAngleDeg"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Camera.ToPatientScanScaleLimits(System.Double@,System.Double@)">
            <summary>
            Provides the range of valid scale values of the ToPatient space mapper. 
            Values out of this range will cause rendering failure.
            </summary>
        </member>
        <member name="M:Claron.WIF.Camera.StepTowards(Claron.WIF.Vector3,System.Double,System.Double)">
            <summary>
            Moves the camera towards a target location (particularly useful in perspective)
            </summary>
            <param name="TargetInPatRcs">Location to move towards</param>
            <param name="StepMm">Size of step to take (can be negative) Default value = 0.5</param>
            <param name="MaxAngularRotationRads"> Default value = Math.PI/40 </param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Camera.StepByJoystick(System.Double,System.Double,System.Double,System.Boolean)">
            <summary>
            Moves the camera forward/backwards, optionally with some turning
            </summary>
            <param name="HorizontalTurnRads">Amount of horizontal rotation (around vertical axis) before stepping</param>
            <param name="VerticalTurnRads">Amount of vertical rotation (around horizontal axis) before stepping</param>
            <param name="StepMm">Size of step to take in mm (can be negative)</param>
            <param name="OnlyThroughTransparent">If in Shaded mode, will stop at non-transparent locations. Default value = true</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Camera.OpacityAt(Claron.WIF.Vector3)">
            <summary>
            Returns the opacity fraction (0 to 1) as a given location (ignoring tissues!)
            Returns 0 if the outside the input SliceStack or the RenderMode is not shaded.
            </summary>
            <param name="PositionInPatientRcs"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Camera.ClampScaleToValidRange(System.Double)">
            <summary>
            Clamps a value to be assigned to ToPatientScan.Scale to ensure it does not trigger a VR2 error.
            </summary>
        </member>
        <member name="M:Claron.WIF.Camera.ClampScaleToValidRange">
            <summary>
            Clamps Grid.ToPatientScan.Scale as needed to the range in which it will not trigger a VR2 error.
            </summary>
        </member>
        <member name="M:Claron.WIF.Camera.DataBoxInCameraRcs">
            <summary>
            Returns the bounding box of the visible input data in camera RCS coordinates.
            If the clipper is enabled, the box bounds the clipper. Otherwise, it bounds
            the full InSliceStack.
            When InSliceStack is Nothing, returns an invalid box.
            </summary>
        </member>
        <member name="M:Claron.WIF.Camera.ZoomFactor">
            <summary>
            Returns the current zoom factor.
            A zoom factor of 1 corresponds to seeing the full input stack or clipper if enabled from
            the current view direction. A larger factor means a higher magnification.
            </summary>
        </member>
        <member name="M:Claron.WIF.Camera.Zoom(System.Double,System.Boolean)">
            <summary>
            Modifies the ToPatientScan.Scale to set a view with a given zoom factor.
            </summary>
            <param name="zoomFactor">A zoom factor of 1 corresponds to seeing the full stack
            (or clipper if enabled) from a front view.  Higher value means a larger magnification. </param>
            <param name="CenterTheView">If true, the view will be centered at the center of the data box.</param>
        </member>
        <member name="M:Claron.WIF.Camera.Zoom(System.Double,Claron.WIF.Box,System.Boolean)">
            <summary>
            Modifies ToPatientScan.Scale to reflect the zoom factor desired relative to the
            </summary>
            <param name="BoxInCameraRcs">Viewing box in camera RCS </param>
            <param name="zoomFactor">A zoom factor of 1 corresponds to seeing the full box from
            the current view direction. A larger factor means a higher magnification.</param>
            <param name="CenterTheView">If true, the view will be centered at the center of the data box.</param>
        </member>
        <member name="M:Claron.WIF.Camera.ZoomToFullView">
            <summary>
            Modifies ToPatientScan to show the full databox, centered.
            Same as Zoom(1, True)
            </summary>
        </member>
        <member name="M:Claron.WIF.Camera.ClearOutputs">
            <summary>
            Sets the output buffers to a state as if an empty volume was rendered.
            </summary>
        </member>
        <member name="M:Claron.WIF.Camera.outI(System.Int32,System.Int32)">
            <summary>
            Converts X,Y coordinates in the output picture
            to index for accessing the output data array (outImageU12, OutARGB, or IsoSurfaceBuf).
            Not the fastest (needs to call across class boundary), but convenient.
            </summary>
            <param name="X"></param>
            <param name="Y"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Camera.SaveMinMaxImg(System.Int32[],System.Int32,System.String)">
            <summary>
            Debugging function for HitTest
            </summary>
            <param name="imgQ16"></param>
            <param name="defaultVal"></param>
            <param name="fileSubscript"></param>
        </member>
        <member name="M:Claron.WIF.Camera.SaveMinMaxImg(System.Byte[],System.Int32,System.String)">
            <summary>
            Debugging function for HitTest
            </summary>
            <param name="hitTestImg"></param>
            <param name="defaultVal"></param>
            <param name="fileSubscript"></param>
        </member>
        <member name="M:Claron.WIF.Camera.VisibleSurfaceSet(System.Int32,Claron.WIF.VisibleSurface)">
            <summary>
            Sets a polygon in the array of polys to be displayed in shaded mode.
            The polygon vertex coordinates are in SliceStack Index values (Si)
            </summary>
            <param name="i">Index of the polygon in the array to be rendered. Would enlarge the array
            if it is larger than the last current index.</param>
            <param name="visibleSurface"></param>
        </member>
        <member name="M:Claron.WIF.Camera.VisibleSurfaceGet(System.Int32)">
            <summary>
            The array of polygons to be displayed in shaded mode.
            The polygon vertex coordinates are in SliceStack Index values (Si)
            </summary>
            <param name="i">Polygon index in the array.</param>
            <returns>The polygon or null if there is no polygon at that index</returns>
        </member>
        <member name="M:Claron.WIF.Camera.VisibleSurfaceGet(Claron.WIF.Vector3)">
            <summary>
            Returns a VisibleSurface based on a coordinate in Vi.
            </summary>
            <param name="pointVi">Point in Vi coordinate space</param>
            <returns>VisibleSurface if there is a hit or null if there is a miss</returns>
        </member>
        <member name="M:Claron.WIF.Camera.MapToGridRCS(Claron.WIF.Vector3[],Claron.WIF.GridBox)">
            <summary>
            Maps an array of (2D) index coordinates in the camera's grid to 3D RCS coordinates in
            another grid (eg, the input slice stack). In lumen mode, the targetGrid is ignored and
            the RCS coordinates of the slice stack are returned.
            </summary>
            <param name="pntsCi">An array of coordinates in camera grid index coordinates.
            The third coordinate is ignored.</param>
            <param name="targetGrid">The grid whose coordinates are required. Must be mapped to
            the same PatientScanRCS as the camera, or an exception is thrown.</param>
            <returns>An array of the same size as the input array containing corresponding
            output locations.
            If the location is unknown, the output member is invalid</returns>
            <remarks>The function involves projecting rays in the specified locations according to
            the rendering parameters using the ray casting algorithm.
            An output locations may be unknown because it encounters no data at that location. This
            may be because the does not intersect with the (clipped region of the) stack.
            If render mode is Average, the position at the center of the projection ray is returned.
            NOTE: If an image was rendered using an algorithm other than ray casting, the coordinates
            returned may not match exactly what is shown in the pixel. In case of doubt, set ForceRaycasting to true
            when rendering the image.
            </remarks>
        </member>
        <member name="M:Claron.WIF.Camera.MapToGridRCSUpdateZBuffer(System.Single[],Claron.WIF.GridBox)">
            <summary>
            Updates the depth values in the camera's Z buffer to an RCS Z coordinate in
            another grid (eg, the input slice stack). In lumen mode, the targetGrid is ignored and
            the RCS coordinates of the slice stack are returned.
            </summary>
            <param name="zBuffer">The z buffer, must have the same size as the target grid.</param>
            <param name="targetGrid">The grid whose coordinates are required. Must be mapped to
            the same PatientScanRCS as the camera, or an exception is thrown.</param>
            <returns>An array of the same size as the input array containing corresponding
            output locations.
            If the location is unknown, the output member is invalid</returns>
            <remarks>The function involves projecting rays in the specified locations according to
            the rendering parameters using the ray casting algorithm.
            An output location may be unknown because the ray encounters no data at that location. This
            may be because the ray does not intersect with the data bounding box, or because all voxel
            in the ray's path are transparent and thus invisible.
            If render mode is Average, the position at the center of the projection ray is returned.
            NOTE: If an image was rendered using an algorithm other than ray casting, the coordinates
            returned may not match exactly what is shown in the pixel. In case of doubt, set ForceRaycasting to true
            when rendering the image.
            </remarks>
        </member>
        <member name="M:Claron.WIF.Camera.MapToGridIndex(Claron.WIF.Vector3[],Claron.WIF.GridBox)">
            <summary>
            Maps an array of (2D) index coordinates in the camera's grid to 3D index coordinates in
            another grid (eg, the input slice stack). In lumen (curved slab) mode, the targetGrid is ignored and
            indices in input slice stack grid are returned.
            </summary>
            <param name="pntsCi">An array of coordinates in camera grid index coordinates.
            The third coordinate is ignored.</param>
            <param name="targetGrid">The grid whose coordinates are required. Ignored in lumen mode.
            </param>
            <returns>An array of the same size as the input array containing corresponding
            output locations.
            If the location is unknown (eg, background, or out of the picture),
            the output location vector is invalid!</returns>
        </member>
        <member name="M:Claron.WIF.Camera.MapToGridIndex(Claron.WIF.Vector3,Claron.WIF.GridBox)">
            <summary>
            Maps a 2D index coordinates in the camera's grid to 3D index coordinates in
            another grid (eg, the input slice stack). In lumen mode, the targetGrid is ignored and
            index in input slice stack grid are returned.
            </summary>
            <param name="pntsCi">A location in camera grid index coordinates.
            The z coordinate is ignored.</param>
            <param name="targetGrid">The grid whose coordinates are required. Ignored in lumen mode.
            </param>
            <returns>output location.
            </returns>
        </member>
        <member name="M:Claron.WIF.Camera.MapToPatientRCS(Claron.WIF.Vector3[])">
            <summary>
            Maps an array of (2D) coordinates in the camera's (grid) index to 3D coordinates in the PatientScan RCS of the input stack.
            If a lumen is used, the location at the center of the lumen slab is returned, regardless of rendering mode.
            See also documentation for MapToGridRCS
            </summary>
            <param name="pntsCi">An array of coordinates in camera grid index coordinates. The third coordinate is ignored.</param>
        </member>
        <member name="M:Claron.WIF.Camera.MapToPatientRCS(Claron.WIF.Vector3)">
            <summary>
            Maps a 2D coordinate in the camera's (grid) index to 3D coordinates in the PatientScan RCS of the input stack.
            See documentation for MapToGridRCS
            </summary>
            <param name="pntCi">Coordinates in camera grid index coordinates. The third coordinate is ignored.</param>
        </member>
        <member name="M:Claron.WIF.Camera.MapFromPatientRcsToCameraGridPointF(Claron.WIF.Vector3[])">
            <summary>
            Maps an array of coordinates in PatientGridRCS to the Camera's output grid
            correcting for perspective as needed. Used for overlay drawing.
            May trigger a render cycle if rendering parameters were changed since the last
            render.
            </summary>
            <param name="ptsInPatientRcs">An array of coordinates in the camera's patient RCS.</param>
            <returns>An array of the same size as the input array containing corresponding
            output locations. If the location is unknown or falls behind the camera, the output member
            is (-1, -1)</returns>
        </member>
        <member name="M:Claron.WIF.Camera.RibbonLocalPrToCr(Claron.WIF.Vector3)">
            <summary>
            Provides a mapper from Pr (Patient RCS) to Cr (Camera RCS) at a local point
            on a ribbon image. Useful for overlay drawing of small shapes without the need to map each point on
            the shape separately (slower and may create undesired distortions).
            The distance of Pr from the curve Math.Abs(PrToCr.Map(PointPr).Z * Camera.Grid.SpacingMm.Z) can be used 
            to stop drawing of shapes projected from too far off the curve;
            </summary>
            <param name="PointPr">A coordinate in the patient RCS (usually the center of the shape to be drawn).</param>
            <returns>The desired mapper, or null when _lumenForRibbon is null, or the mapping in not possible (eg, the point falls out of the 
            output image)</returns>
        </member>
        <member name="M:Claron.WIF.Camera.MapFromPatientRcsToCameraGrid(Claron.WIF.Vector3[])">
            <summary>
            Maps an array of Pr coordinates to Ci (the Camera's output grid index)
            correcting for perspective as needed. Used for overlay drawing.
            May trigger some update extra computation (eg, centerline section computation in ribbon view) if 
            relevant rendering parameters were changed since the last render.
            </summary>
            <param name="PointsInPatientRcs">An array of coordinates in the camera's patient RCS.</param>
            <returns>An array of the same size as the input array containing corresponding
            output locations.
            If the location is unknown or falls behind the camera, the output member is invalid</returns>
        </member>
        <member name="M:Claron.WIF.Camera.PerspectiveD">
            <summary>
            Provides the focal distance "D", where the XY sampling distance in both the C and V (perspective
            grid) match in perspective rendering mode
            </summary>
        </member>
        <member name="M:Claron.WIF.Camera.TissueAt(System.Int32,System.Int32)">
            <summary>
            Returns the tissue present at the given camera grid index coordinates,
            or Nothing if there is no tissue there (eg, background data region,
            nothing rendered there, coordinates out of bounds).
            When there is more than one tissue at the given location, the higher indexed tissue is returned.
            </summary>
            <param name="XCi">X camera grid coordinate</param>
            <param name="YCi">Y camera grid coordinate</param>
        </member>
        <member name="F:Claron.WIF.Camera._Spheres">
            <summary>
            A collection of sphere markers to be rendered into the image.
            </summary>
        </member>
        <member name="M:Claron.WIF.Camera.SphereAdd(Claron.WIF.SphereMarker)">
            <summary>
            Adds a sphere marker to draw over the viewport image.
            </summary>
        </member>
        <member name="M:Claron.WIF.Camera.SphereRemove(Claron.WIF.SphereMarker)">
            <summary>
            Removes a sphere maker from the list of spheres to be shown (no-op if the sphere is not on the list)
            </summary>
            <param name="sm"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Camera.SpheresDraw">
            <summary>
            The sphere markers are drawn with hidden surface removal using _CzQ16Image
            to compare to the camera's rendering depth.
            </summary>
        </member>
        <member name="M:Claron.WIF.Camera.SphereDrawnAt(System.Int32,System.Int32)">
            <summary>
            Returns the the (closest) sphere marker drawn at a given image position in the last render
            cycle, or Nothing if no sphere was drawn there.
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.InSliceStack">
            <summary>
            The main data input.
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.Grid">
            <summary>
            Controls the 3D geometry and size (width, height, depth) of the rendering output.
            The origin is at the left, top, front of the image.
            The RCS (and sample spacing) unit is mm.
            </summary>
            <remarks>Gets created automatically by this class</remarks>
        </member>
        <member name="P:Claron.WIF.Camera.outImageU12">
            <summary>
            The last generated ImageU12 when rendering produces such an image.
            Note that if it is a curved slab, its grid.ToPatientScan is null.
            It is recommended to check IsImageU12Valid before getting this image.
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.OutArgb">
            <summary>
            Each 32b pixel combines 4 8b components, MS to LS: Alpha), Red, Green, Blue
            The output picture buffer (not copy) generated by the last rendering call.
            NOTE: May be larger than the size of the grid (to reduce memory reallocation).
                Use Grid.DimXY to find out how many pixels are actual useful.
            May be an empty array (length = 0) if no rendering calls were made yet.
            </summary>
            <value></value>
        </member>
        <member name="P:Claron.WIF.Camera.IsCizValid">
            <summary>
            Indicates whether the information in OutCizQ16 is valid, ie, contains information
            that matches OutArgb
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.IsIsoSurfaceBufValid">
            <summary>
            Indicates whether the information in IsoSurfaceBuf is valid, ie, contains information
            that matches OutArgb
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.OutCizQ16">
            <summary>
            When IsCizValid, this property provides access to the "depth" buffer of
            the renderer. A value in the buffer at the same index as OutArgb represents the
            Camera index Z (Ciz) coordinate related to that location (opacity crossed a threshold),
            with the fraction in the 16 LSB and the integer in the 24 MSB. To convert to a float/double,
            simply divide by 65536 (10000 hex), and to obtain only the integer portion, shift right by 16.
            Background locations have negative values.
            The buffer may be larger than the size of the output (just like OutArgb).
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.Preset">
            <summary>
            The viewing preset, encapsulating all the non-input-specific viewing parameters.
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.TissuesEnabled">
            <summary>
            The list of all the tissues that may affect the rendering
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.Mask">
            <summary>
            A binary mask applied to the voxels in the slice stack. Only location with a value of 1 are
            traversed during ray casting. A Tissue object is used.
            Tissue properties other than its BitVol are ignored.
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.LumenForRibbon">
            <summary>
            Setting the Lumen to a value other than null puts the camera in curved slab mode
            where a "ribbon" (stretched curved slab) view of the lumen is rendered
            The sample spacing in mm is set directly by the grid spacing and the ToPatientScan
            mapper is ignored.
            <see cref="P:Claron.WIF.Camera.LumenRibbonRollRadians"/>, <see cref="P:Claron.WIF.Camera.LumenRibbonCenterMm"/> and 
            <see cref="P:Claron.WIF.Camera.RibbonStretchedHorizontally"/>.
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.RibbonStretchedHorizontally">
            <summary>
            Controls the orientation of the stretched lumen's centerline Z coordinate 
            in the output image. If true, lumen Z,X are aligned with camera X,Y correspondingly,
            otherwise lumen Z,X are aligned with Camera Y,-X. 
            Lumen Y is always aligned with camera Z.
            <see cref="P:Claron.WIF.Camera.LumenForRibbon"/>
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.DebugVR2">
            <summary>
            Set to true in order to debug the VR2 performance.
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.LastRenderInputsUpdateTicks">
            <summary>
            The latest (largest) update tick of all rendering inputs
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.LastNonShadedMeshUpdateTicks">
            <summary>
            The latest (largest) update tick of all rendering inputs
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.LastViewingInputsUpdateTicks">
            <summary>
            The latest (largest) update tick of the rendering inputs not including the ones
            associated with the input slice stack.
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.ToPatientScan">
            <summary>
            Shortcut to Grid.ToPatientScan for convenience.
            Has no effect when a Lumen is rendered.
            </summary>
            <value></value>
        </member>
        <member name="P:Claron.WIF.Camera.PixelsPerMm">
            <summary>
            Gets/Sets the pixels/mm ratio scaling factor (zoom) of the the ToPatientScan mapper
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.NNinterpolation">
            <summary>
            If True, samples values are copied from the nearest neighbor. Otherwise, trilinear interpolation 
            is used, except for 2D slabs (XY/YZ/XZ) in non-shaded rendering, where bi-cubic interpolation
            is used for improved quality.
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.UsebiCubicAlignedSlabInterpolation">
            <summary>
            If True, uses biCubic interpolation for Aligned slab rendering, Otherwise, biLinear interpolation 
            is used. Note: This setting is only for Aligned slab rendering
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.IsAutoInterpolationMode">
            <summary>
            If True, interpolation changes automatically for optimum performance, otherwise, _NNinterpolation value is used. Default is "True"
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.IsSlab">
            <summary>
            Property that defined to the Camera whether the rendering performance would be
            optimized for flat slab interactions. When true, Mask clipping is ignored and
            the camera position is placed at middle of the slab
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Camera.NormalDirection">
            <summary>
            Determines which end of the gradient will be used as normal for lighting
            calculations in RenderModeEnum.Shaded mode
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.IsPerspective">
            <summary>
            Is perspective applied to the projection geometry in non-slab views?
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.IsEndoluminal">
            <summary>
            Is rendering optimized for endoluminal views in shaded mode?
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.PerspectiveAngleDegreesH">
            <summary>
            The horizontal perspective angle, in degrees. Clamped to the range 5..120
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Camera.Interactive">
            <summary>
            Indicates if camera is redering at low resolution for better user responce.
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.IsApplyingShadow">
            <summary>
            Indicates if we need to apply shadows OR not depending upon the interactive mode
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.LumenRibbonCenterMm">
            <summary>
            Specifies the distance along the Lumen's centerline corresponding to the
            center of the rendered ribbon image(_grid.dims\2). If negative, the ribbon is rendered with
            its start aligned with the top of the output buffer.
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.IsPseudoSpacing">
            <summary>
            Get/Set property indicating if the pixel spacing is synthetic
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.NonTissuesVisible">
            <summary>
            Controls whether the non-tissues region may be visible (based on the preset
            transfer function) or forced to become fully transparent.
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.OutputTissuesOnly">
            <summary>
            If set, both the non-tissue and the tissue voxels are raycasted (Shaded mode), but only
            the opacity and color of the tissues is placed in the ARGB buffer.
            Used for the glass effect.
            </summary>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Camera.WindowingEnabled">
            <summary>
            If true (default) WindowingWidth and WindowingCenter determine the (grey-level)
            color of 12b output. Otherwise, the color mapping of the Rendering Preset's 
            xfer function is used.
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.WindowingNonLinearPreset">
            <summary>
            A preset describing 12b->RGB mapping function (color and intensity). The RGB values are 
            the color curve values attenuated/darkened by the opacity values. The opacity curve
            center/width are used to tweak the windowing. Use a uniform white color 
            curve to get gray-level windowing using any opacity curve.
            Usually stored as a RenderingPreset under the "Windowing" category. If null (default), a standard
            linear ramp is used.
            
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.IsWindowingNonLinear">
            <summary>
            Indicates whether the windowing function is non linear, ie, driven from color/attenuation
            transfer functions (see WindowingNonLinearPreset).
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.WindowingCenter">
            <summary>
            Center of 12b->8b mapping ramp (windowing level) in stored value (0 to 4095)
            </summary>
            <remarks>Clipped silently to the range 0 to hFFF
            </remarks>
        </member>
        <member name="P:Claron.WIF.Camera.WindowingCenterModality">
            <summary>
            Center of 12b->8b mapping ramp (windowing level) in modality value (eg, HU).
            If InSliceStack is not assigned, equivalent to WindowingCenter.
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.WindowingWidth">
            <summary>
            Width of 12b->8b mapping ramp (windowing width)
            </summary>
            <remarks>Clipped silently to the range 1 to h1000</remarks>
        </member>
        <member name="P:Claron.WIF.Camera.RenderInverted">
            <summary>
            Whether to render the images with inversion mode, this property takes both WindowingInverted (set by client) 
            and image's photometric interpretation into accounts, i.e. for MONOCHROME1 images, the minimum sample value is
            intended to be displayed as white. 
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.WindowingInverted">
            <summary>
            If true, the windowing mapping is inverted: low values are bright and high values are dark
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.ColorwashEnabled">
            <summary>
            Determines whether any colorwash (eg, reformatted tissues) is shown.
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.ColorwashOutline">
            <summary>
            Determines whether the outside contour of colorwash is shown.
            The outside contour consists of "in" pixels that have an "out" neighbor (including outside
            the picture region).
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.MaskColorwashRgb">
            <summary>
            If >=0, this color would be added (25%) to the pixels outside the mask (reformatted).
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.BackgroundTransparent">
            <summary>
            Determines whether the background into which the image is rendered will be
            transparent (ARGB = 0) or set to Preset.BackgroundARGB. Transparent background
            is useful for laying of cameras (top cameras should have a transparent background to
            show the lower camera images through).
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.DefaultBackgroundValueFor16BitBuffer">
            <summary>
            Gets or sets the default background color of the rendered image for the 
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.BackgroundValueFor16BitBuffer">
            <summary>
            Gets or sets the background color of the rendered image
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.ShadowOffCenter0to1">
            <summary>
            Determines how centered is the penumbra shadow (0->centered, 1->max off-center).
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.DepthFadeInShadedEnabled">
            <summary>
            Depth fade is applied by attenuating the color brightness starting
            at approximately 10% of the depth histogram ramping down to black DepthFadeRampMm afterwards.
            Assumes a hard surface, so should not be applied with high transparency.
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.DepthFadeRampMm">
            <summary>
            The distance, in mm, over which the intensity fades to black. If set to 0 (default)
            the intensity fade distance is determined automatically and an auto-exposure algorithm
            adjusts image intensity, which is mapped to gray levels from the green channel.
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.Transparency0to1">
            <summary>
            Controls making the output ARGB transparent. Useful for laying/fusing multiple
            camera outputs. At 0 (default) it has no effect. At higher values, it reduces
            the alpha channel value proportionately.
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.ValueThreshold">
            <summary>
            The minimum (stored) sample value considered in generating ray values during rendering.
            Values higher than 0 allow the renderer to skip regions where all values are below the threshold,
            accelerating the rendering. Default: 3.
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.IsoSurfaceThresholdModality">
            <summary>
            The Thresholding modality value (eg, HU) for IsoSurface mode.
            During rendering, translated to actual stored value threshold for InSliceStack.
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.IsoSurfaceRgbaType">
            <summary>
            Determines how IsoSurface output will be converted to color.
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.FrontClipPlaneDepthMm">
             <summary>
             The front clipping plane depth in mm relative to the center of rotation/zoom of
             the camera in the patient. (0 = center of rotation/zoom, negative: closer to the viewer)
             </summary>
             <remarks>See FrontClipPlaneEnabled as well.
            </remarks>
        </member>
        <member name="P:Claron.WIF.Camera.FrontClipPlaneInPatient">
            <summary>
            A position in Patient space through which the front clipping plane
            is passing.
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.ForceRaycasting">
            <summary>
            If false, will allow using shear-warp to speed up rendering whenver possible.
            </summary>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Camera.SliceStackCyclingCachingEnabled">
            <summary>
            Controls whether outArgb buffer is cached separately for each
            InSliceStack assigned in the past, to support cycling between SliceStacks
            without the need to re-render.
            Otherwise (default) only a single outArgb buffer is cached.
            </summary>
            <remarks>To prevent excessive cache size, it is recommended to clear the cache by setting
            this property to false whenever cycling is no longer expected.</remarks>
        </member>
        <member name="P:Claron.WIF.Camera.MaskCyclingCachingEnabled">
             <summary>
            TO prevent re-render when same mask is Redisplayed during Cycling
             </summary>
             <value></value>
             <returns></returns>
             <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Camera.VR2ID">
            <summary>
            The ID of this camera when calling the VR2 library. Should usually stay unchanged
            for the lifetime of this camera (unless explicitly overridden).
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.Vr2CacheSizeBytes">
            <summary>
            Returns the number of bytes currently allocated by VR2 in its unmanaged memory caches.
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.PostRenderingDelegates">
            <summary>
            Property to retrieve delegates which are called after render.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Camera.AlphaBlendingFactor">
            <summary>
            controls the blending transparency of the output of this camera over another camera
            used by pet/nm fusion rendering 
            Viewport should use CompositingMethodEnum.AlphaBlending for this property to be considered
            valid values between 0 and 1 (1 means maximum effect, 0 means is transparent)
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.ColormapPostWindowed">
            <summary>
            transform windowed 8bit gray image with an color map 
            used for example by pet/nm rendering 
            if this is not null, then it will be used instead of regular 8 bit->32 bit transform
            WifDataTypes contains 6 predefined colormaps, use ColormapsPostWindowed to load and access the ArgbData property
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.HashCodeUsePixelData">
            <summary>
            Property to get/set whether the pixel data should be used when
            calculating the hash code.
            </summary>
        </member>
        <member name="P:Claron.WIF.Camera.TextureMappedPolygonsSi">
            <summary>
            The array of polygons to be displayed texture-mapped (in shaded mode).
            The polygon vertex coordinates are in SliceStack Index values (Si)
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Camera.TextureOnClippingPolygonsEnabled">
            <summary>
            Whether the clipping surfaces (including outside slice stack boundaries) are
            texture-mapped.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Camera.RenderModeEnum.IsoSurface">
            <summary>
            IsoSurface: 4x32b float values for each ray, thresholded at IsoSurfaceThreshold, and stored
            in IsoSurfaceBuf. The values are:
            [0] depth in camera depth sampling units (Cz).
            [1],[2],[3] the surface normal at that location projected to the view direction.
            When the location is background, Cz is set to a huge negative value (lower than -1e10).
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.Camera.ColorwashingModeEnum">
             <summary>
            
             </summary>
             <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Camera.ColorwashingModeEnum.Blending">
            <summary>
            Adjusts the brightness as per the specified _ColorwashingOpacity0to1
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Camera.ColorwashingModeEnum.Colorizing">
            <summary>
            Colorwashes with the same color as the underlying ARGB value.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Camera.PolygonPtrArray.polysPtr">
            <summary>
            pointer to the polygon array
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Camera.PolygonPtrArray.polysNum">
            <summary>
            The number of polygons, only updated when array gets pinned
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.Camera.PolygonArrayApi">
            <summary>
            The encapsulation of all that is needed to communicate polygon geometry between VB and a C++ DLL
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Camera.PolygonArrayApi.polygonsSiVB">
            <summary> The VB polygon array in Si coordinates</summary>
        </member>
        <member name="F:Claron.WIF.Camera.PolygonArrayApi.polygonsPtr">
            <summary> The C++ polygon pointer array </summary>
        </member>
        <member name="F:Claron.WIF.Camera.PolygonArrayApi.polygonsHdl">
            <summary> The VB GC handler array for the pointers to pinned memory</summary>
        </member>
        <member name="T:Claron.WIF.Camera.RemoteRenderDelegate">
            <summary>
            Delegate used for Async remote rendering in client/server mode
            </summary>
            <param name="refreshParams"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.Camera.RPClass">
            <summary>
            This class encapsulates the render_params Structure.
            If we pass render_params from client to server, it always does
            constant amount of data transfer, even if it is set to nothing(this is because
            it is declared as struct)
            In client server mode sometime, render_params  is same as in previous render call,
            so we do not need to pass it to server, So if we encapsulate it in RPClass and pass
            nothing, to reduce data transfer
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.Camera.PostRenderingDelegate">
            <summary>
            Delegate which is called at the end of a render.
            </summary>
            <param name="camera"></param>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.SphereMarker">
            <summary>
            This class represents a sphere-shaped location marker to be added to the camera image in
            3D (Shaded or MIP) render modes.
            </summary>
        </member>
        <member name="P:Claron.WIF.SphereMarker.CenterPr">
            <summary>
            The center of the sphere in the PatientScan RCS
            </summary>
        </member>
        <member name="F:Claron.WIF.RegionStatistics.StoredValues">
            <summary>
            an array containing the stored pixel values on or inside the polyline,
            in raster scan order. To convert to modality values, use
            VP.InCamera.outImageU12.ModalityValue(StoredValues)
            </summary>
        </member>
        <member name="F:Claron.WIF.RegionStatistics.AreaMmSq">
            <summary>
            The sum of the areas of the pixels used in computing the other statistics.
            </summary>
        </member>
        <member name="F:Claron.WIF.RegionStatistics.LengthMm">
            <summary>
            The distance, in Mm, between the two farthest points
            </summary>
        </member>
        <member name="F:Claron.WIF.RegionStatistics.LengthEndsPointI">
            <summary>
            The indexes of the two end points used to compute the length
            </summary>
        </member>
        <member name="F:Claron.WIF.RegionStatistics.ContourLengthMm">
            <summary>
            Contour length, in Mm
            </summary>
        </member>
        <member name="F:Claron.WIF.RegionStatistics.WidthMm">
            <summary>
            The distance, in Mm, between two points farthest from the line defining
            the length, one on each side.
            </summary>
        </member>
        <member name="F:Claron.WIF.RegionStatistics.WidthEndsPointI">
            <summary>
            The indexes of the two end points used to compute the width
            </summary>
        </member>
        <member name="T:Claron.WIF.CameraRemoter">
            <summary>
            Represent a remote (server-side) object, owned by a client-side Camera object, which
            executes rendering operations on the server, using input from other remoters.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.CameraRemoter.Render(Claron.WIF.Camera.RefreshParam)">
            <summary>
            Remote rendering call, made by the local Camera.Render, passing to it the full render_params
            structure and various data elements render_params references. The results, either ARGB (32b) or
            16b images, are returned in buffers by reference (ie, copied by .NET).
            </summary>
        </member>
        <member name="T:Claron.WIF.Clipper">
             <summary>
             The Clipper class describes a simple geometric region in space: a box,
             a cylinder with an elliptical cross section, or an ellipsoid.
             Its main use is for interactively clipping the region of space being rendered,
             exposing structures that are otherwise hidden.
            
             Clippers use a mapper ToPatientScan to define their center's location and their
             axes' orientation in space. The lengths of the axes are specified in mm.
            
             Clippers are exported to the renderer as a polygon array or triangular mesh. They can also be
             converted to a BitVol to enable their use in segmentation operations.
             </summary>
             <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Clipper.IsOnIn3d">
            <summary>
            When active (default) the clipper does restrict the 3d viewport rendering to show only what is inside the clipper.
            When set to false the 3d rendering is not affected by the clipper, but the overlays still show the clipper outline.
            </summary>
        </member>
        <member name="M:Claron.WIF.Clipper.BBoxPr">
            <summary>
            Returns the bounding box of the clipper in Pr (Patient Rcs coordinates)
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Clipper._ToPatientScan">
            <summary>
            Mapper from clipper coordinates to patient scan coordinates.
            </summary>
        </member>
        <member name="M:Claron.WIF.Clipper.#ctor(Claron.WIF.SpaceMapperSimilarity,Claron.WIF.Vector3,Claron.WIF.Clipper.ClipperShapeEnum,Claron.WIF.Clipper.PlaneOrienationEnum)">
            <summary>
            Creates a new clipper with a given position, size and shape
            </summary>
            <param name="ToPatientScan">The mapper from clipper coordinates (origin at center) to PatientScan RCS</param>
            <param name="sizeMm">The dimensions of the clipper</param>
            <param name="shapeType"></param>
            <param name="cylinderPlane">If a cylinder shape, the plane in which the cross-section is an ellipse</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Clipper.#ctor(Claron.WIF.SpaceMapperSimilarity,Claron.WIF.Vector3,Claron.WIF.Clipper.ClipperShapeEnum)">
            <summary>
            Creates a new clipper with a given position, size and shape
            </summary>
            <param name="ToPatientScan">The mapper from clipper coordinates (origin at center) to PatientScan RCS</param>
            <param name="sizeMm">The dimensions of the clipper</param>
            <param name="shapeType"></param>
        </member>
        <member name="M:Claron.WIF.Clipper.#ctor(Claron.WIF.Clipper)">
            <summary>
            Creates a new clipper which is a clone of another clipper
            </summary>
            <param name="other">The clipper to clone</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Clipper.GetHashCode">
            <summary>
            Returns the hash code of the Clipper object.
            </summary>
        </member>
        <member name="F:Claron.WIF.Clipper._clipperPolygonsSi">
            <summary>
            Dictionary mapping grid boxes of slice stacks to the polygons of the clipper in that
            grid box coordinates.
            Necessary for support of multiple slice stacks in collage.
            </summary>
        </member>
        <member name="F:Claron.WIF.Clipper._lastClipperPolygonsSiTicks">
            <summary>
            Dictionary mapping grid boxes of slice stack with last update time of clipper polygons. Necessary for
            support of multiple slice stacks in collage.
            </summary>
        </member>
        <member name="M:Claron.WIF.Clipper.GetClipperPolygonsSi(Claron.WIF.GridBox)">
            <summary>
            Returns the clipper polygons associated with a slice stack grid box.
            Recomputes polygon vertices only if necessary.
            </summary>
            <param name="ssGrid">The slice stack grid box for which to retrieve the polygons defining
            the clipper.</param>
            <returns>The polygons defining the clipper with their vertices in
            slice stack grid index coordinates.</returns>
        </member>
        <member name="M:Claron.WIF.Clipper.ScanconvertToBitVol(Claron.WIF.BitVol@)">
            <summary>
            Scan-converts the clipper into a BitVol containing 1 at the locations inside clipper, and 0 outside the clipper.
            Uses brick at once computation and multi threading for speedup.
            </summary>
            <remarks>Make sure that grid is mapped to the PatientScan RCS</remarks>
        </member>
        <member name="M:Claron.WIF.Clipper.ScanconvertToBitVolBoxWorkerThread(System.Int32,System.Int32,System.Object,System.Exception@)">
            <summary>
            Function called in single and in multi threaded execution of Clipper scan conversion, if clipper is of shape Box.
            Traverses the destination BitVol in Brick-order, filling/clearing as many as once as possible.
            In each thread brick runs of 7 bricks are targeted to improve cache coherency over simple round robin brick distribution.
            Inclusion/exclusion of bricks/cubes/voxels is computed on the fly as needed.
            </summary>
            <param name="myThreadI">The ID of the thread calling this function. Assumed to be an integer in range [0,numThreads).</param>
            <param name="numThreads">The number of threads computing in parallel, typically taken from SysUtils.SuggestedThreadsCount, (could be ==1 when debugging).</param>
            <param name="threadData">The parameters the threads needs during the scan conversion.</param>
            <param name="_threadEx">An exception to output in case it is thrown in the thread.</param>
        </member>
        <member name="M:Claron.WIF.Clipper.ScanconvertToBitVolCylinderWorkerThread(System.Int32,System.Int32,System.Object,System.Exception@)">
            <summary>
            Function called in single and in multi threaded execution of Clipper scan conversion, if clipper is of shape Cylinder.
            Traverses the destination BitVol in Brick-order, filling/clearing as many as once as possible.
            In each thread brick runs of 7 bricks are targeted to improve cache coherency over simple round robin brick distribution.
            Inclusion/exclusion of bricks/cubes/voxels is computed on the fly as needed.
            </summary>
            <param name="myThreadI">The ID of the thread calling this function. Assumed to be an integer in range [0,numThreads).</param>
            <param name="numThreads">The number of threads computing in parallel, typically taken from SysUtils.SuggestedThreadsCount, (could be ==1 when debugging).</param>
            <param name="threadData">The parameters the threads needs during the scan conversion.</param>
            <param name="_threadEx">An exception to output in case it is thrown in the thread.</param>
        </member>
        <member name="M:Claron.WIF.Clipper.ScanconvertToBitVolEllipsoidWorkerThread(System.Int32,System.Int32,System.Object,System.Exception@)">
            <summary>
            Function called in single and in multi threaded execution of Clipper scan conversion, if clipper is of shape Ellipsoid.
            Traverses the destination BitVol in Brick-order, filling/clearing as many as once as possible.
            In each thread brick runs of 7 bricks are targeted to improve cache coherency over simple round robin brick distribution.
            Inclusion/exclusion of bricks/cubes/voxels is computed on the fly as needed.
            </summary>
            <param name="myThreadI">The ID of the thread calling this function. Assumed to be an integer in range [0,numThreads).</param>
            <param name="numThreads">The number of threads computing in parallel, typically taken from SysUtils.SuggestedThreadsCount, (could be ==1 when debugging).</param>
            <param name="threadData">The parameters the threads needs during the scan conversion.</param>
            <param name="_threadEx">An exception to output in case it is thrown in the thread.</param>
        </member>
        <member name="M:Claron.WIF.Clipper.ScanconvertToBitVolSphereWorkerThread(System.Int32,System.Int32,System.Object,System.Exception@)">
            <summary>
            Function called in single and in multi threaded execution of Clipper scan conversion, if clipper is of shape Ellipsoid.
            Traverses the destination BitVol in Brick-order, filling/clearing as many as once as possible.
            In each thread brick runs of 7 bricks are targeted to improve cache coherency over simple round robin brick distribution.
            Inclusion/exclusion of bricks/cubes/voxels is computed on the fly as needed.
            </summary>
            <param name="myThreadI">The ID of the thread calling this function. Assumed to be an integer in range [0,numThreads).</param>
            <param name="numThreads">The number of threads computing in parallel, typically taken from SysUtils.SuggestedThreadsCount, (could be ==1 when debugging).</param>
            <param name="threadData">The parameters the threads needs during the scan conversion.</param>
            <param name="_threadEx">An exception to output in case it is thrown in the thread.</param>
        </member>
        <member name="M:Claron.WIF.Clipper.Set_EditDirectionFromMousePosition(System.Drawing.Point,Claron.WIF.GridBox,Claron.WIF.Clipper.PlaneOrienationEnum)">
            <summary>
            Sets the direction in which the clipper is currently being modified by the user
            </summary>
            <param name="currMousePos">current mouse location </param>
            <param name="vpGrid">Vieport Grid</param>
            <param name="_PlaneOrienation">PlaneOrienationEnum</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Clipper.DrawClipperLine(System.Drawing.Pen,System.Drawing.Graphics,Claron.WIF.GridBox,Claron.WIF.Vector3,Claron.WIF.Vector3,Claron.WIF.Vector3,Claron.WIF.Vector3,Claron.WIF.Camera)">
            <summary>
            Draws a line between p1 and p2. It uses G. DrawLine if either of the sharing triangles are visible
            It uses "DrawLineWithHiddenPixelTest" if both of the sharing triangles are not visible
            i.e.Line is not in front of the clipped volume, so Draw the dotted line using HiddenPointTest
            </summary>
            <param name="pen"></param>
            <param name="G"></param>
            <param name="vpGrid"></param>
            <param name="p0Pr"></param>
            <param name="p1Pr"></param>
            <param name="facing1">Normal of first triangle shared by the Line</param>
            <param name="facing2">Normal of second triangle shared by the Line</param>
            <param name="cam3D"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Clipper.DisplayOverlayClipperOnSlabViewports(System.Drawing.Graphics,System.Drawing.Pen,Claron.WIF.GridBox,Claron.WIF.Clipper.PlaneOrienationEnum)">
            <summary>
            To Display Boundary of clipper On SlabViewports
            </summary>
            <param name="G">Graphics</param>
            <param name="_Pen"></param>
            <param name="vpGrid">Viewport Grid</param>
            <param name="_PlaneOrienation">PlaneOrienationEnum</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Clipper.UpdateClipperParameters(Claron.WIF.Clipper.EditDirectionEnum,Claron.WIF.GridBox,Claron.WIF.Clipper.PlaneOrienationEnum,System.Windows.Forms.MouseEventArgs,System.Windows.Forms.MouseEventArgs,Claron.WIF.SpaceMapperSimilarity@,Claron.WIF.GridBox)">
            <summary>
            Sets the dimensions of clipper depending upon the mouse location and _EditDirection
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Clipper.EnsureClipperInViewportBounds(Claron.WIF.GridBox,Claron.WIF.GridBox,Claron.WIF.GridBox,Claron.WIF.SpaceMapperSimilarity@,System.Boolean)">
            <summary>
            Ensure that the size of the clipper is such that, it is clearly visible
            inside the viewport bounds. i.e. 15% margin is kept at the outer bounday
            and not smaller than the 10% of the viewport size
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Clipper.GetClipperPtsOnVp(Claron.WIF.GridBox,Claron.WIF.Clipper.PlaneOrienationEnum)">
            <summary>
            Gets the coordinates of the corners of the clipper in viewport coordinate system.
            </summary>
            <param name="vpGrid">The viewport grid.</param>
            <param name="planeOrienation"></param>
        </member>
        <member name="P:Claron.WIF.Clipper.CylinderCirclePlane">
            <summary>
            In case of cylinder shape, the plane of the circular cross-section.
            </summary>
        </member>
        <member name="P:Claron.WIF.Clipper.CenterPr">
            <summary>
            Location of Center of clipper in (P)atient (R)CS
            </summary>
        </member>
        <member name="P:Claron.WIF.Clipper.SizeMm">
            <summary>
            Size of the clipper bounding box in mm.
            Measured along the axes of the clipper.
            </summary>
        </member>
        <member name="P:Claron.WIF.Clipper.CornerPtsPr">
             <summary>
             Returns the corner points of the clipper ordered as follows:
            
             0 = bottom left corner, bottom plane;
             1 = top left corner, bottom plane; 
             2 = top right corner, bottom plane; 
             3 = bottom right corner, bottom plane; 
             4 = bottom left corner, top plane; 
             5 = top left corner, top plane; 
             6 = top right corner, top plane; 
             7 = bottom right corner, top plane; 
             </summary>
        </member>
        <member name="P:Claron.WIF.Clipper.ToPatientScan">
            <summary>
            Mapper of the center of the clipper and its axes to patient scan coordinates.
            </summary>
        </member>
        <member name="P:Claron.WIF.Clipper.Pinned">
            <summary>
            When Pinned, the clipper does not change its size or position in patient space in
            response to user input.
            </summary>
        </member>
        <member name="T:Claron.WIF.Clipper.EditDirectionEnum">
            <summary>
            Enum indicating which dimension of the
            clipper is currently being modified by the user
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.Clipper.PlaneOrienationEnum">
            <summary>
            principal planes (eg, perpendicular to the length/width/height dimensions of the clipper)
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Clipper.ScanconvertToBitVolThreadData._tmpBv">
            <summary>
            The array of temporary BitVols.
            </summary>
        </member>
        <member name="F:Claron.WIF.Clipper.ScanconvertToBitVolThreadData._bv2PrMat">
            <summary>
            BitVol grid to PatientRcs grid transformation matrix
            </summary>
        </member>
        <member name="F:Claron.WIF.Clipper.ScanconvertToBitVolThreadData._bBoxSi">
            <summary>
            A box that restricts where filling of the clipper should have effect in the BitVol
            </summary>
        </member>
        <member name="F:Claron.WIF.Clipper.ScanconvertToBitVolThreadData._brickCenterOffset">
            <summary>
            Offset to the center of the brick from a brick corner.
            </summary>
        </member>
        <member name="F:Claron.WIF.Clipper.ScanconvertToBitVolThreadData._cubeCenterOffset">
            <summary>
            Offset to the center of the cube from a cube corner.
            </summary>
        </member>
        <member name="F:Claron.WIF.Clipper.ScanconvertToBitVolThreadData._brickFootPrintRadius">
            <summary>
            The radius of a brick when projected onto the viewport.
            </summary>
        </member>
        <member name="F:Claron.WIF.Clipper.ScanconvertToBitVolThreadData._cubeFootPrintRadius">
            <summary>
            The radius of a cube when projected onto the viewport.
            </summary>
        </member>
        <member name="M:Claron.WIF.Clipper.ScanconvertToBitVolThreadData.#ctor(Claron.WIF.BitVol[],System.Double[],Claron.WIF.BoxI32,Claron.WIF.Vector3,Claron.WIF.Vector3,System.Double,System.Double)">
            <summary>
            Constructor for the class ScanconvertToBitVolThreadData to make sure no parametes are overlooked.
            </summary>
            <param name="tmpBv">The array of temporary BitVols.</param>
            <param name="bv2PrMat">BitVol grid to PatientRcs grid transformation matrix</param>
            <param name="bBoxSi">A box that restricts where filling of the clipper should have effect in the BitVol</param>
            <param name="brickCenterOffset">Offset to the center of the brick from a brick corner.</param>
            <param name="cubeCenterOffset">Offset to the center of the cube from a cube corner.</param>
            <param name="brickFootPrintRadius">The radius of a brick when projected onto the viewport.</param>
            <param name="cubeFootPrintRadius">The radius of a cube when projected onto the viewport.</param>
        </member>
        <member name="M:Claron.WIF.Clipper.Mesh.GenerateEdges">
            <summary>
            Creates and populates an edge list matching to the already setup triangle list stored in 'triangles'
            </summary>
        </member>
        <member name="M:Claron.WIF.Clipper.Mesh.AddEdge(System.Int32,System.Int32,System.Int32)">
            <summary>
            Adds an edge and completes the nBor triangle references of edges that are already there.
            </summary>
            <param name="v1I">First edge vertex index</param>
            <param name="v2I">Second edge vertex index</param>
            <param name="triI">Triangle list index</param>
        </member>
        <member name="T:Claron.WIF.Curve">
            <summary>
            The Curve class represents a 1-D curve in 3D space.
            The curve shaped is described by a sequence of 3D vertices (Vector3 structures) through which
            the curve passes.
            The curve line is usually interpolated linearly (segments) between vertices when needed.
            Methods are provided for resampling, smoothing, scan-conversion in 2D (for example for cookie-cutting and
            projection visualization), and curvature measurement.
            </summary>
        </member>
        <member name="F:Claron.WIF.Curve._vertices">
            <summary>
            The vertices defining the curve.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Curve._closed">
            <summary>
            Whether the curve is closed or not.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.#ctor">
            <summary>
            Creates a new empty curve.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.#ctor(System.Collections.Generic.IEnumerable{Claron.WIF.Vector3})">
            <summary>
            Creates a new curve and initializes the vertices from an array.
            If the first and last vertices are identical, the last vertex is dropped
            and the Closed property is set to True.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.FromVector2(System.Collections.Generic.IEnumerable{Claron.WIF.Vector2})">
            <summary>
            Creates a new curve and initializes the vertices from an array.
            If the first and last vertices are identical, the last vertex is dropped
            and the Closed property is set to True.
            Not implemented as constructor to make 2d to 3d conversion explicit in client code.
            </summary>
            <param name="vertices"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Curve.#ctor(Claron.WIF.Vector3[])">
            <summary>
            Creates a new curve and initializes the vertices from an array.
            If the first and last vertices are identical, the last vertex is dropped
            and the Closed property is set to True.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.#ctor(System.Collections.Generic.List{Claron.WIF.Vector3})">
            <summary>
            Creates a new curve with the given list of vertices.
            </summary>
        </member>
        <member name="M:Claron.WIF.Curve.#ctor(System.Collections.Generic.List{System.Drawing.Point})">
            <summary>
            Creates a new (2D) curve with the given list of Points.
            </summary>
        </member>
        <member name="M:Claron.WIF.Curve.#ctor(System.Drawing.PointF[],System.Double)">
            <summary>
            Creates a new curve with the given array of XY points and a Z coordinate added to all.
            </summary>
        </member>
        <member name="M:Claron.WIF.Curve.#ctor(Claron.WIF.Vector3,Claron.WIF.SliceStack,System.Int32@,System.Int32)">
            <summary>
            Creates a new curve as iso-line through the startPoint
            Curve vertices are inited in patient coordinates
            </summary>
            <param name="startPointSi"></param>
            <param name="ss"></param>
            <param name="contourVal"></param>
            <param name="delta"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.#ctor(Claron.WIF.Curve)">
            <summary>
            Creates a new curve which is a copy of a given curve
            </summary>
        </member>
        <member name="M:Claron.WIF.Curve.#ctor(Claron.WIF.Curve,Claron.WIF.SpaceMapperSimilarity)">
            <summary>
            Creates a deep copy of the given curve.
            </summary>
            <param name="other">The curve to copy.</param>
            <param name="ToAnotherRCS">If provided, will map the curve to anther RCS using this mapper. Default value = null</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.Clone">
            <summary>
            Returns a clone of this curve.
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.Clear">
            <summary>
            Clears the vertices defining the curve.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.Add(Claron.WIF.Vector3)">
            <summary>
            Adds a new vertex to the curve at the end of the list of vertices.
            </summary>
            <param name="vertex">The vertex to add.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.Append(Claron.WIF.Curve)">
            <summary>
            Adds a new vertex to the curve at the end of the list of vertices.
            </summary>
            <param name="otherCurve">The other curve to append.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.Reverse">
            <summary>
            Reverses the order of the list of vertices.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.Clamp(Claron.WIF.Box)">
            <summary>
            Clamps all the vertices coordinates to the boundaries of the give bounding box.
            Note that this flattens the parts of the curve that fall outside the box
            </summary>
            <param name="Bounds">The bounding box to clamp to</param>
        </member>
        <member name="M:Claron.WIF.Curve.Clip(Claron.WIF.Box)">
            <summary>
            Replaces vertices which are outside the box but have edge with the other end inside box
            by the intersection of this edge with the box.
            Removes all other vertices outside the clipBox
            </summary>
            <param name="clipBox"></param>
        </member>
        <member name="M:Claron.WIF.Curve.ClampXY(Claron.WIF.Box)">
            <summary>
            Clamps all the vertices coordinates to the boundaries of the give bounding box
            in X and Y (Z is ignored).
            Note that this flattens the parts of the curve that fall outside the box
            </summary>
            <param name="Bounds">The bounding box to clamp to</param>
        </member>
        <member name="M:Claron.WIF.Curve.MapToRCS(Claron.WIF.SpaceMapperSimilarity)">
            <summary>
            Maps the curve's vertices to another RCS
            </summary>
            <param name="ToRCS">The mapper to use</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.MapBackToRCS(Claron.WIF.SpaceMapperSimilarity)">
            <summary>
            Maps the curve's vertices to another RCS in reverse direction
            </summary>
            <param name="ToRCS">The mapper to use</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.MappedToRCS(Claron.WIF.SpaceMapperSimilarity)">
            <summary>
            Returns a copy of the curve with its vertices in another RCS
            </summary>
            <param name="ToRCS">The mapper to use to map the vertices</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.MapToIndex(Claron.WIF.GridBox)">
            <summary>
            Maps the current vertices coordinates to index coords, 
            assumes that current vertices are in RSC coordinates of provided grid
            </summary>
            <param name="grid"></param>
        </member>
        <member name="M:Claron.WIF.Curve.RasterizeFromPrToGrid(Claron.WIF.GridBox)">
            <summary>
            Returns a sequence of 6-connected integer coordinates that represent the curve
            mapped from Patient RCS to a given grid index.
            No check is done for index coordinate range, so some sections of
            the rasterized points may be outside the grid bounding box.
            </summary>
            <param name="grid">The grid box in which it would be rasterized</param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Curve.ResampleEquidistantMe(System.Double)">
            <summary>
            Replaces the Me-curve with a new curve obtained by equidistant resampling of this curve starting from vertex 0.
            Assumes the vertices are connected by straight lines.
            </summary>
            <param name="stepDistance">Step distance in units of the curve coordinate system,
            i.e. in mm if curve coordinats are Patient RCS.</param>
            <remarks>The distance is measured in 3-space in a direct line (not geodesic).
            The last point (first point if closed) is usually not included.</remarks>
        </member>
        <member name="M:Claron.WIF.Curve.Length">
            <summary>
            Returns the sum length of the line segments between the vertices. If the
            curve is closed, the closing segment length is added as well.
            </summary>
        </member>
        <member name="M:Claron.WIF.Curve.CenterOfGravity">
            <summary>
            Returns the center of gravity of the curve.
            </summary>
        </member>
        <member name="M:Claron.WIF.Curve.ClosestVertexI(Claron.WIF.Vector3,System.Double@)">
            <summary>
            Returns the index of the vertex closest to a given location
            </summary>
        </member>
        <member name="M:Claron.WIF.Curve.ClosestVertexI(Claron.WIF.Vector3)">
            <summary>
            Returns the index of the vertex closest to a given location
            </summary>
        </member>
        <member name="M:Claron.WIF.Curve.ClosestVertex(Claron.WIF.Vector3)">
            <summary>
            Returns the coordinates of the curve vertex closest to a given location.
            </summary>
        </member>
        <member name="M:Claron.WIF.Curve.ClosestPoint(Claron.WIF.Vector3)">
            <summary>
            Returns the coordinates of the curve point closest to a given location,
            assuming the curve is piecewise linear.
            </summary>
            <param name="ToLocation">A location on or outside the curve</param>
        </member>
        <member name="M:Claron.WIF.Curve.ClosestPoint(Claron.WIF.Vector3,System.Int32@)">
            <summary>
            Returns the coordinates of the curve point closest to a given location,
            assuming the curve is piecewise linear.
            </summary>
            <param name="ToLocation">A location on or outside the curve</param>
            <param name="ClosestSegmentStartI">Output: the index of the start of the
            segment on which the closest point was found.</param>
        </member>
        <member name="M:Claron.WIF.Curve.ClosestPoint(Claron.WIF.Vector3,System.Int32@,System.Double@)">
            <summary>
            Returns the coordinates of the curve point closest to a given location,
            assuming the curve is piecewise linear.
            </summary>
            <param name="ToLocation">A location on or outside the curve</param>
            <param name="ClosestSegmentStartI">Output: the index of the start of the
            segment on which the closest point was found.</param>
            <param name="DistanceAlongCurve">Output: the total distance along the curve from
            vertex 0 to the closest point in the curve's RCS.</param>
        </member>
        <member name="M:Claron.WIF.Curve.Resampled(System.Double)">
            <summary>
            Returns a new curve obtained by equidistant resampling of this curve starting from vertex 0.
            If the curve is not closed, the last vertex position is maintained.
            </summary>
            <param name="SegmentLength">The desired length of each line segment in units of the curve
            coordinate system, eg, in mm if curve coordinates are Patient RCS.</param>
            <returns></returns>
            <remarks>The distance is measured in 3-space in a direct line (not geodesic).
            The last point (first point if closed) is usually not included.</remarks>
        </member>
        <member name="M:Claron.WIF.Curve.Resampled(System.Double,System.Double)">
            <summary>
            Returns a new curve resampled at approximately fixed distances from vertex 0.
            Where the points are otherwise exceed a given distance tolerance from the base linear segments,
            the resampling steps are shortened.
            Useful before smoothing and image-driven adjustments (active contours).
            </summary>
            <param name="DesiredSegmentLength">The desired linear distance between the new resampled points</param>
            <param name="Tolerance">Maximum distance between the new vertexes and the based curve</param>
            <returns>A new resampled curve</returns>
        </member>
        <member name="M:Claron.WIF.Curve.AddVertexWithToleranceCheck(System.Collections.Generic.List{Claron.WIF.Vector3}@,Claron.WIF.Vector3,System.Collections.Generic.List{Claron.WIF.Vector3},System.Double)">
            <summary>
            Adds one or more vertexes to the list with a tolerance check and returns the last vertex added
            </summary>
        </member>
        <member name="M:Claron.WIF.Curve.Resampled(System.Int32,System.Double,System.Double)">
            <summary>
            Returns a new curve resampled at close to fixed distances. Where the points are farther than
            a given tolerance from the base linear segments, intermediate vertexes are inserted.
            Useful before smoothing and image-driven adjustments (active contours).
            </summary>
            <param name="StartVertexIndex">The index of the point from which to start resampling
            (common to based and returned)</param>
            <param name="DesiredSegmentLength">The desired linear distance between the new resampled points</param>
            <param name="Tolerance">Maximum distance between the new vertexes and the based curve</param>
            <returns>A new resampled curve</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.ResampledToCount(System.Int32)">
            <summary>
            Returns a new curve resampled to a given number of vertices count at fixed distances.
            Throws an exception if this cannot be accomplished.
            </summary>
            <returns>A new resampled curve, guaranteed to have the desired number of vertices</returns>
        </member>
        <member name="M:Claron.WIF.Curve.ResampledToVerticallyUnitIncrements(System.Int32)">
            <summary>
            Returns a new curve resampled to a given number of vertices count at vertical unit distances.
            </summary>
            <returns>A new resampled curve, guaranteed to have the desired number of vertices</returns>
        </member>
        <member name="M:Claron.WIF.Curve.Smooth">
            <summary>
            Returns a new smoother curve by computing a weighted average along the curve. 
            (Laplace style smoothing). Does not modify the first and last point.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.SmoothMe">
            <summary>
            Make smoother by computing a weighted average along the curve. (Laplace style smoothing).
            Does not modify the first and last point.
            </summary>
        </member>
        <member name="M:Claron.WIF.Curve.SmoothRegression(System.Int32)">
            <summary>
            Returns a new smoother curve via regression. 
            Outliers and invalid points along the curve are removed.
            Does modify first and last point.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.SmoothCurvature(System.Int32[])">
            <summary>
            Returns a new smoother curve by minimizing the curvature change along the curve.
            Does not modify the first and last point.
            </summary>
            <param name="fixedIndices">An optional single index, 
            or comma separated list, or array of indices 
            in the Curve that should not be moved.</param>
            <remarks>The core algorithm is repeated, as the deviation from smooth curvature
            is not updated after each point adjustment So at the end of each round there may
            be some neighbors of adjusted points that now have non-smooth curvature.
            Those are fixed in the next path.</remarks>
        </member>
        <member name="M:Claron.WIF.Curve.CalculateDeviationFromTargetCurvature(System.Int32,System.Double)">
            <summary>
            Calculates the signed Euclidean distance between the given index point and a point computed
            according to the given target curvature.
            </summary>
            <param name="j">The index at which to compute the deviation.</param>
            <param name="targetCurvatureRadius">In coordinate units of the curve (mm if in Pr)</param>
            <returns>0 for exactly matching curvature, - for within curvature limit, + for more curved
            than curvature limit.</returns>
        </member>
        <member name="M:Claron.WIF.Curve.CalculatePointAtCurvatureTarget(System.Int32,System.Double)">
             <summary>
            
             </summary>
             <param name="j"></param>
             <param name="targetCurvatureRadiusInverse">In coordinate units of the curve (mm if in Pr)</param>
        </member>
        <member name="M:Claron.WIF.Curve.SmoothCurveToTargetCurvature(System.Double,System.Int32)">
            <summary>
            Iteratively smooth the curve incrementally at each point the curvature is more than the given
            limit. The two ends of the curve are left unchanged if the curve is not closed.
            </summary>
            <param name="targetCurvatureRadius">In coordinate units of the curve (mm if in Pr)</param>
            <param name="maxIterations">The maximum allowed number of iterations (one point moved per iteration)</param>
        </member>
        <member name="M:Claron.WIF.Curve.CurvatureRadii">
            <summary>
            Returns the curvature radii along each point on the curve using the its two nearest neigbours.
            End points are identical to the adjacent elements.
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.CurvatureInverseRadii">
            <summary>
            Computes the inverse of the curvature radii along the curve. 
            Has the advantage over reporting the actual radius, that straight lines can be represented as valid number 0,
            (if the radius was reported then for a line the value would have to be infinity, and then smoothing of neighboring radii fails)
            For closed curves considers wrap around connection, 
            for open curve reports for first and last point the results of their immediate nbors.
            </summary>
            <returns></returns>
            <remarks>
                       d             d=circle center
                      /|             a,b,c on circle edge
                   r/  |
                  /    |
                /  x   |
              a--------m--------c
                 ____  |y
                       b
            </remarks>
        </member>
        <member name="M:Claron.WIF.Curve.CurvatureInverseRadiusSnapTo(System.Double,System.Int32)">
            <summary>
            Computes the inverse of the curvature radii along the curve. 
            Has the advantage over reporting the actual radius, that straight lines can be represented as valid number 0,
            (if the radius was reported then for a line the value would have to be infinity, and then smoothing of neighboring radii fails)
            For closed curves considers wrap around connection, 
            for open curve reports for first and last point the results of their immediate nbors.
            </summary>
            <returns></returns>
            <remarks>
                       d             d=circle center
                      /|             a,b,c on circle edge
                   r/  |
                  /    |z
                /  x   |
              a--------m--------c
                 ____  |y
                       b
            </remarks>
        </member>
        <member name="M:Claron.WIF.Curve.SmoothCurveToTargetCurvature(System.Double[])">
            <summary>
            Smooth the curve such that at each vertex the curvature is less or equal the given limits.
            </summary>
            <param name="targetCurvatureRadiiMm">An array of curvature radius limit per vertex</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.SmoothAdaptively">
            <summary>
            smilar to SmoothCurveToMinimizeCurvatureChange(), but with vertex count-adaptive reduction in samples,
            since SmoothCurveToMinimizeCurvatureChange() tends to be less effective for large vertex counts.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Curve.ExtrapolateBgn(System.Int32)">
            <summary>
            Extrapolates the curve at the beginning along the tangent repeating the last vertex delta direction for each added vertex.
            The delta magnitude is normalized to 1 with respect to the curve coordinate system
            </summary>
            <param name="numExtraVertices">The desired number of extra vertices.</param>
        </member>
        <member name="M:Claron.WIF.Curve.ExtrapolateEnd(System.Int32)">
            <summary>
            Extrapolates the curve at the end along the tangent repeating the last vertex delta direction for each added vertex.
            The delta magnitude is normalized to 1 with respect to the curve coordinate system
            </summary>
            <param name="numExtraVertices">The desired number of extra vertices.</param>
        </member>
        <member name="M:Claron.WIF.Curve.EnsureClosedClockwiseXY">
            <summary>
            Tests that the vertices are ordered clockwise assuming the curve is closed and
            non intersecting. If not, reverses the vertex order.
            </summary>
        </member>
        <member name="M:Claron.WIF.Curve.IsClosedClockwiseXY">
            <summary>
            Indicates whether the vertices are ordered clockwise assuming the curve is closed and
            non intersecting.
            </summary>
        </member>
        <member name="M:Claron.WIF.Curve.ComputeRadialVectorsXY(System.Double,System.Double,System.Int32,Claron.WIF.Vector3[]@,Claron.WIF.Vector3[]@)">
            <summary>
            Computes for each vertex in XY only, two radial vectors, one to the left and one to the right
            (when stepping in rising index direction). If the curve is closed and vertex indexes are ordered
            clockwise (see EnsureClosedClockwiseXY), then left is outside and right is inside.
            Optimized for use in a "ribbon" resampling
            around the curve, usually used to locate nearby object boundaries.
            The function optionally attempts to ensure that the vectors do not cross each other,
            to eliminate undesirable spatial twists in the ribbon sampling process.
            </summary>
            <param name="LeftLength">The length (in curve units) of each radial vector to the left</param>
            <param name="RightLength">The length (in curve units) of each radial vector to the right</param>
            <param name="MaxRegularizationIterations">If higher than 0, the function will attempt to ensure
            that vectors of neighbors do not intersect by iteratively separating the ends of
            intersecting vectors, iterating up to a maximum of MaxRegularizationIterations</param>
            <param name="outLeftVectors">An array of the radial displacement vectors to the left</param>
            <param name="outRightVectors">An array of the radial displacement vectors to the right</param>
        </member>
        <member name="M:Claron.WIF.Curve.RibbonImageXY(Claron.WIF.ImageU12,Claron.WIF.Vector3[],Claron.WIF.Vector3[],System.Double,System.Int32@)">
            <summary>
            Resamples a given (2D) image radially from the curve,to produce a "ribbon" image along the curve.
            Designed to use the output of ComputeRadialVectorsXY.
            The curve vertices and radial vector coordinates are assumed to be image indices!!
            </summary>
            <param name="InImage">The image to resample</param>
            <param name="LeftRadials">The radials output from ComputeRadialVectorsXY to display left of the vertices</param>
            <param name="RightRadials">The radials output from ComputeRadialVectorsXY to display right of the vertices</param>
            <param name="Spacing">The distance (in pixel units) between samples along the vectors</param>
            <param name="outVerticesX">The X index in the output ribbon image of the curve vertices. Smaller
            indexes than this are left radial samples, and higher ones, right radial samples.</param>
            <returns>The resampled image. Samples that fall outside the inImage grid are set to 0</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.BoundingBox">
            <summary>
            Computes the bounding Box of the curve.
            </summary>
            <returns>Returns the bounding box of the curve.
            Box.IsEmpty will return true if there are no vertices.</returns>
        </member>
        <member name="M:Claron.WIF.Curve.BoundingBoxExpandedInViewDirection(Claron.WIF.Image4Vu.ViewSideEnum,Claron.WIF.GridBox)">
            <summary>
            Calculates the bounding box for the curve in target grid RCS coordinate system and then
            expands the box in the given view direction so that the faces of the box touch the
            bounding box of the target grid. Assumes that the points of the curve are in the patient
            scan RCS.
            </summary>
            <param name="viewSide">The view direction in which to expand the bounding box.</param>
            <param name="targetGrid"></param>
        </member>
        <member name="M:Claron.WIF.Curve.BoundingBoxI32">
            <summary>
            Computes the bounding BoxI32 of the curve
            </summary>
            <returns>Returns the bounding box of the curve.</returns>
        </member>
        <member name="M:Claron.WIF.Curve.Read(System.IO.Stream,System.Runtime.Serialization.Formatters.Binary.BinaryFormatter)">
            <summary>
            Reads the curve using the specified stream and formatter.
            </summary>
            <param name="stream"></param>
            <param name="formatter"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.Write(System.IO.Stream,System.Runtime.Serialization.Formatters.Binary.BinaryFormatter)">
            <summary>
            Writes the image using the specified stream and formatter.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.DrawInArray(System.Int32,System.Int32)">
            <summary>
            Draws the curve in a 2D char array.
            </summary>
            <param name="width">The width of the array.</param>
            <param name="height">The height of the array.</param>
            <returns></returns>
            <remarks>
            Note that all points defining the array are assumed to lie within the
            canvas array.
            </remarks>
        </member>
        <member name="M:Claron.WIF.Curve.DrawInArray(System.Int32,System.Int32,System.Char)">
            <summary>
            Draws the curve in a 2D char array.
            </summary>
            <param name="width">The width of the array.</param>
            <param name="height">The height of the array.</param>
            <param name="ch">The character to use to draw the curve. Default value = "*"c</param>
            <remarks>
            Note that all points defining the array are assumed to lie within the
            canvas array.
            </remarks>
        </member>
        <member name="M:Claron.WIF.Curve.DrawInArray(System.Char[0:,0:],System.Char)">
            <summary>
            Draws the curve in the given 2D char array. Note that all points
            defining the array are assumed to lie within the array.
            </summary>
            <param name="canvas">The array to draw into.</param>
            <param name="ch">The character to use to draw the curve. Default value = "*"c</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.FilledXY(Claron.WIF.GridBox)">
            <summary>
            Assuming the curve is in index coordinates (z coordinates ignored), 
            given a grid on which the curve was drawn, returns a single-plane BitVol 
            (same width and height as the grid) with the boundary locations and, if Closed, 
            the inside region, set to 1.
            </summary>
            <param name="OnGrid">The grid on which the curve is assumed to be drawn. All curve coordinates
            should be within the grid bounds or an exception is raised. (ClampXY() can be used if needed)</param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Curve.FillInCurveOnCanvas(System.Int32,System.Int32,System.Char)">
            <summary>
            Fills the curve in a 2D char array.
            </summary>
            <param name="width">The width of the array.</param>
            <param name="height">The height of the array.</param>
            <param name="ch">The character to use to fill inside the curve.</param>
            <returns>A 2D I8 array containing the filled in curve, where locations on the curve
            itself are filled with numbers, and locations inside are filled with the given
            character.</returns>
            <remarks>If the curve is not closed then this function does the same
            as DrawInArray(). Note that all points defining the curve are assumed
            to lie within the canvas array.</remarks>
        </member>
        <member name="M:Claron.WIF.Curve.AreaXY">
            <summary>
            Returns the area bound by the XY projection of the curve assuming the curve is closed
            and NOT SELF-INTERSECTING. Very fast and efficient.
            </summary>
        </member>
        <member name="M:Claron.WIF.Curve.AreaXySigned">
            <summary>
            Returns the signed area bound by the XY projection of the curve assuming the curve is closed.
            Very fast and efficient. Positive if the curve is closed clockwise, and negative otherwise.
            </summary>
            <remarks>Uses the sum of the areas of the trapezoids formed between each pair
            of subsequent point and their projections on the X axis.
            </remarks>
        </member>
        <member name="M:Claron.WIF.Curve.IsPointInsideXY(Claron.WIF.Vector3)">
            <summary>
            Determines if the input point is within the interior of a polygon represented by the curve in 2D.
            </summary>
            <param name="point">point of interest</param>
            <returns>true if inside the polygon</returns>
        </member>
        <member name="M:Claron.WIF.Curve.IsPointInsideXY(System.Collections.Generic.List{Claron.WIF.Vector3},Claron.WIF.Vector3)">
            <summary>
            Helper method to determine if the input point is within the interior of a polygon represented by the list of points in 2D.
            </summary>
            <param name="points">list of point which define a polgon</param>
            <param name="point">point of interest</param>
            <returns>true if inside the polygon</returns>
        </member>
        <member name="M:Claron.WIF.Curve.VerticesAverage">
            <summary>
            Calculates and returns the average vertex position
            </summary>
        </member>
        <member name="M:Claron.WIF.Curve.FarthestVerticesIndexes(System.Int32@,System.Int32@)">
            <summary>
            Computes and returns the indexes of the two vertexes farthest from each other.
            The computation is done at O(N), but is not guaranteed to always return a
            correct answer - there are some marginal situations where the pair return is
            lightly closer than the farthest.
            </summary>
        </member>
        <member name="M:Claron.WIF.Curve.RotateVertices(System.Int32)">
            <summary>
            Rotates the vertexes such that a given vertex is the first on the list
            (useful for closed curves)
            </summary>
            <param name="FirstVertexIndex">The index of the vertex which will have index 0 after the call</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.TranslateVertices(Claron.WIF.Vector3)">
            <summary>
            Translate all the vertices by a given Translation vector
            </summary>
            <param name="Translation">The vector to add to each vertex</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.SubCurve(System.Int32,System.Int32)">
            <summary>
            Returns a new curve (Closed=false) which is part of this one.
            </summary>
            <param name="StartIndex">The vertex index to become index 0 in the returned curve</param>
            <param name="EndIndex">The last index. Since it's clamped to range, using Integer.MaxValue can be used to
            indicate the last index</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.SubCurveWithinRadius(Claron.WIF.Vector3,System.Double)">
            <summary>
            Returns a new curve (Closed=false) which is part of this one.
            Chooses the vertices based on a reference vertex on or close to the curve and
            then includes nbors in a geodesic walk as long as they are within the given geodesic distance.
            Assumes the curve units and the inclusionRadius units match.
            </summary>
            <param name="onCurvePt"></param>
            <param name="inclusionRadius">In same coordinate system as the curve, i.e. assumes same units.</param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Curve.GetLineIntersectionPoints2D(Claron.WIF.Vector3,Claron.WIF.Vector3)">
            <summary>
            Returns an array of Vector3 objects giving the intersection points of a line with this curve.
            </summary>
            <remarks>z-components are ignored.</remarks>
        </member>
        <member name="M:Claron.WIF.Curve.GetLineIntersectionPoint2D(Claron.WIF.Vector3,Claron.WIF.Vector3,Claron.WIF.Vector3,Claron.WIF.Vector3,Claron.WIF.Vector3@,System.Double@)">
            <summary>
            Finds the intersection point of two lines, p0 is set as invalid if the lines are parallel.
            </summary>
            <param name="r0">The first point in the first line.</param>
            <param name="r1">The second point in the first line.</param>
            <param name="s0">The first point in the second line.</param>
            <param name="s1">The second point in the second line.</param>
            <param name="p0"></param>
            <param name="lambda"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.FindIsoLine(Claron.WIF.Vector3,Claron.WIF.ImageU12,System.Int32@,System.Int32)">
            <summary>
            Builds iso-line contour through startSi point.
            The value of iso-line is taken from value in point and can be changed
            by adding delta
            </summary>
            <param name="startSi"></param>
            <param name="image"></param>
            <param name="contourVal"></param>
            <param name="deltaVal"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.FillNeighborValues(Claron.WIF.Vector3,System.Int32[],Claron.WIF.Vector3[],Claron.WIF.ImageU12)">
            <summary>
            Fill the array of values in 8 pixels around curSi.
            The deltas to neighbors are precomputed and passed in array deltaNeighbors()
            </summary>
            <param name="curSi"></param>
            <param name="neighborVals"></param>
            <param name="deltaNeighbors"></param>
            <param name="image"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.GetHistogramOfCurveCutRegion(Claron.WIF.ImageU12)">
            <summary>
            Given an image, a histogram of the STORED pixel values that fall on or inside the curve
            is computed and returned. The curve is closed if it was not before.
            The curve is assumed to already be in the GRID COORDINATES of the image, or
            exceptions may be thrown. If the image and the curve do not intersect, an empty
            histogram is returned.
            </summary>
            <param name="image">The image from which to obtain the pixel values</param>
        </member>
        <member name="M:Claron.WIF.Curve.GetStoredValuesInsideCurveCutRegion(Claron.WIF.ImageU12)">
            <summary>
            Given an image, returns an array containing the stored pixel values on or inside the curve,
            in raster scan order.
            The curve is assumed to already be in the GRID COORDINATES of the image, and be fully contained
            within the image (no negative coordinates), or exceptions may be thrown. 
            If the image and the curve do not intersect, an array of size 0
            is returned.
            </summary>
            <param name="image">The image from which to obtain the pixel values</param>
        </member>
        <member name="M:Claron.WIF.Curve.GetPointsPrInsideCurveCutRegion(Claron.WIF.ImageU12)">
            <summary>
            Returns a list of patient RCS (Pr) locations, one for each pixel inside the curve.
            </summary>
            <param name="image">The image to take the pixels and the ToPatientScan SpaceMapper from.</param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Curve.GetModalityValuesInsideCurveCutRegion(Claron.WIF.ImageU12)">
            <summary>
            Given an image, returns an array containing the modality values for each pixel
            on or inside the curve, in raster scan order.
            The curve is assumed to already be in the GRID COORDINATES of the image, or
            exceptions may be thrown. If the image and the curve do not intersect, an array of size 0
            is returned.
            </summary>
            <param name="image">The image from which to obtain the pixel values</param>
        </member>
        <member name="M:Claron.WIF.Curve.DrawLine(System.Int32,System.Int32,System.Int32,System.Int32,System.Char,System.Char[0:,0:])">
            <summary>
            Draws a line segment in the canvas array assuming that the two points
            defining the line segment lie within the canvas.
            </summary>
            <param name="x0">The x-coordinate of the first point.</param>
            <param name="y0">The y-coordinate of the first point.</param>
            <param name="x1">The x-coordinate of the second point.</param>
            <param name="y1">The y-coordinate of the second point.</param>
            <param name="ch">The character to use to draw the line.</param>
            <param name="canvas">The canvas array.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.DrawLineWithCounts(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean,System.Char[0:,0:])">
            <summary>
            Helper function to draw line segments with boundary count values which
            are used to calculate whether a point is inside or outside the curve
            during scan conversion.
            </summary>
            <param name="x0">The x-coordinate of the first point.</param>
            <param name="y0">The y-coordinate of the first point.</param>
            <param name="x1">The x-coordinate of the second point.</param>
            <param name="y1">The y-coordinate of the second point.</param>
            <param name="hasSignOfDyChanged"></param>
            <param name="canvas">The 2D canvas array.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.FillCountBoundary(System.Char[0:,0:],Claron.WIF.BoxI32)">
            <summary>
            Helper function to fill in the curve using boundary counts.
            </summary>
            <param name="canvas">The canvas.</param>
            <param name="bBox">The bounding box of the curve.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.ToString">
            <summary>
            Converts the curve object to a string.
            </summary>
            <returns>The string with the first ten vertices of the curve.</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.ToCanvasString(System.Char[0:,0:],System.Int32,System.Int32)">
            <summary>
            Converts the given canvas array into a string so that it can be printed.
            </summary>
            <param name="canvas">The canvas array.</param>
            <param name="maxHeight">The maximum height of the region to print</param>
            <param name="maxWidth">The maximum width of the region to print</param>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Curve.Vertices">
            <summary>
            Returns THE list of the vertices defining the curve (not a copy!).
            </summary>
            <returns>The vertices.</returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Curve.Closed">
            <summary>
            Property to get/set whether the curve is closed.
            </summary>
            <value></value>
            <returns>Returns whether the curve is closed.</returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Curve.IsValid">
            <summary>
            Property to get/set whether the curve is closed.
            </summary>
            <value></value>
            <returns>Returns whether the curve is closed.</returns>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.Curve.DistanceMap2d">
            <summary>
            Class for calculating the Manhattan distance map for a 2D curve.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Curve.DistanceMap2d._curve">
            <summary>
            The curve from which to calculate the distance map from.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Curve.DistanceMap2d._dimX">
            <summary>
            The size of the distance map canvas to use.
            </summary>
            <remarks>If this value is set equal to -1 or the size is less than
            the width of the bounding box of the curve then the value is
            disregarded and the size of the bounding box of the curve is used as
            the size of the distance map canvas.</remarks>
        </member>
        <member name="M:Claron.WIF.Curve.DistanceMap2d.DimX">
            <summary>
            The dimension of the distance map in X
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Curve.DistanceMap2d._dimY">
            <summary>
            The size of the distance map canvas to use.
            </summary>
            <remarks>If this value is set equal to -1 or the size is less than
            the width of the bounding box of the curve then the value is
            disregarded and the size of the bounding box of the curve is used as
            the size of the distance map canvas.</remarks>
        </member>
        <member name="F:Claron.WIF.Curve.DistanceMap2d._distanceMap">
            <summary>
            The distance map.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.DistanceMap2d.#ctor(Claron.WIF.Curve)">
            <summary>
            Creates a new Manhattan distance map object.
            </summary>
            <param name="curve">The curve object to use to calculate
            the distance map from.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.DistanceMap2d.#ctor(Claron.WIF.Curve,System.Int32,System.Int32)">
            <summary>
            Creates a new Manhattan distance map object.
            </summary>
            <param name="curve">The curve object to use to calculate
            the distance map from.</param>
            <param name="sizeX">Default value = -1</param>
            <param name="sizeY">Default value = -1</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.DistanceMap2d.#ctor(Claron.WIF.Curve.DistanceMap2d)">
            <summary>
            Creates a new distance map by cloning the given Manhattan distance
            map.
            </summary>
            <param name="other"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Curve.DistanceMap2d.DistanceMapUpdate">
             <summary>
             Updates the distance map.
             </summary>
             <remarks>
             The algorithm to compute the Manhattan distance map works in the
             following way.
            
             1) All points outside the curve are initialized to +Infinity, boundary
             pixels to 0, and inside pixels to -Infinity.
            
             2) Starting at (0, 0) we run in scan line order to find the first
             boundary pixel.
            
             3) Subsequent outside pixels are set to:
            
             1 + Min(distanceMap(x - 1, y), distanceMap(x, y - 1))
            
             Inside pixels are set to:
            
             -1 - Min(distanceMap(x - 1, y), distanceMap(x, y - 1))
            
             4) Steps 2 and 3 are repeated in reverse direction starting at
             (xMax, yMax) in the canvas.</remarks>
        </member>
        <member name="M:Claron.WIF.Curve.DistanceMap2d.PrintDistanceMap(System.Int32[0:,0:])">
            <summary>
            Prints the distance map.
            </summary>
            <param name="map">The distance map array.</param>
            <remarks>Note this function is for debugging purposes only and should
            be used to print distance map arrays which are relatively small in
            size (e.g. 50 x 50). +Infinity and -Infinity in the distance map array
            are represented as "  +" and "  -" respectively when printed on the
            debug console.</remarks>
        </member>
        <member name="M:Claron.WIF.Curve.DistanceMap2d.DistanceMapShow(System.Int32[0:,0:])">
            <summary>
            Returns a bitmap showing the contents of an ARGB buffer.
            Note that the bitmap needs to be disposed by the caller.
            </summary>
            <param name="map">An array of ARGB pixels</param>
        </member>
        <member name="P:Claron.WIF.Curve.DistanceMap2d.Curve">
            <summary>
            Property to get/set the curve from which the distance map is
            calculated.
            </summary>
            <value>The curve to compute the distance map from. As soon as the
            curve is set, the distance map is updated.</value>
            <returns>The curve used to compute the distance map.</returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Curve.DistanceMap2d.DistanceMap">
            <summary>
            Property to get the distance map.
            </summary>
            <value></value>
            <returns>The distance map.</returns>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.CurveCubicSpline">
            <summary>
            A class representing a curve that is cubic splined through a sequence of 3D points.
            Methods are provided for resampling the curve at different frequencies, and for measuring
            and/or reducing the curvature at any or all points.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.CurveCubicSpline._pts">
            <summary>
            The control points defining the curve.
            </summary>
        </member>
        <member name="F:Claron.WIF.CurveCubicSpline._splineCoefficientsUpdateTicks">
            <summary>
            The last time the spline coefficients were updated.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.CurveCubicSpline._gs">
            <summary>
            The gamma values.
            </summary>
        </member>
        <member name="F:Claron.WIF.CurveCubicSpline._dsx">
            <summary>
            The delta values for the x-coordinates.
            </summary>
        </member>
        <member name="F:Claron.WIF.CurveCubicSpline._dsy">
            <summary>
            The delta values for the y-coordinates.
            </summary>
        </member>
        <member name="F:Claron.WIF.CurveCubicSpline._dsz">
            <summary>
            The delta values for the Z-coordinates.
            </summary>
        </member>
        <member name="F:Claron.WIF.CurveCubicSpline._ax">
            <summary>
            The coefficients of the cubic splines.
            </summary>
        </member>
        <member name="F:Claron.WIF.CurveCubicSpline._closed">
            <summary>
            Whether the curve is closed or not.
            </summary>
        </member>
        <member name="F:Claron.WIF.CurveCubicSpline._samplePts">
            <summary>
            The curve sample points.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.CurveCubicSpline.#ctor(Claron.WIF.Vector3[],System.Boolean)">
            <summary>
            Creates a new interpolating cubic spline curve.
            </summary>
            <param name="pts">Default value = null</param>
            <param name="closed">Default value = False</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.CurveCubicSpline.#ctor(System.Collections.Generic.List{Claron.WIF.Vector3},System.Boolean)">
            <summary>
             Creates a new interpolation cubic spline curve from the given list of vertices.
            </summary>
            <param name="pts"></param>
            <param name="closed">Default value = False</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.CurveCubicSpline.UpdateSplineCoefficients">
            <summary>
            Updates the parameters of the cubic spline curve so as to interpolate the given points.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.CurveCubicSpline.UpdateGammas">
            <summary>
            Updates the gamma values.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.CurveCubicSpline.UpdateDeltas">
            <summary>
            Updates the delta values.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.CurveCubicSpline.UpdateABCDs">
            <summary>
            Updates the B-spline coefficients.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.CurveCubicSpline.SampleCurve(System.Int32,System.Double[]@)">
            <summary>
            Samples the curve at n-points along each interval between control points.
            </summary>
            <param name="n">The number of points in each interval.</param>
            <param name="curvs">An array holding the curvatures. Default value = null</param>
        </member>
        <member name="M:Claron.WIF.CurveCubicSpline.GetDefaultNumberOfSampledPointsInEachInterval(System.Int32)">
            <summary>
            Returns the default number of sampled points in each interval for a given number of sampled
            points along the whole length of the curve.
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.CurveCubicSpline.SampleCurveUniformly(System.Int32,System.Double[]@,System.Int32[]@,System.Double[]@)">
            <summary>
            Samples the curve at n-points along the length of the whole curve such that the arc
            length between samples is approximately the same.
            </summary>
            <param name="n">The number of points to sample at along the length of the curve.</param>
            <param name="curvs">Array to hold the curvatures at the sampled points. Default value = null</param>
            <param name="intervalNumbers">Array to hold which interval the corresponding point was
            sampled from. Default value = null</param>
            <param name="uVals">Array to store the u-value of the corresponding point. Default value = null</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.CurveCubicSpline.CalculateCentroidSampleCurveUniformly(System.Int32,Claron.WIF.Vector3[]@,System.Double[]@,System.Int32[]@,System.Double[]@)">
            <summary>
            Returns the center of gravity of the curve.
            </summary>
            <param name="n">The number of samples to use along the length of the curve. Default value = 10</param>
            <param name="sampledPts">The sampled points used to calculate the center of gravity. Default value = null</param>
            <param name="curvs">Default value = null</param>
            <param name="intervalNumbers">Default value = null</param>
            <param name="uVals">Default value = null</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.CurveCubicSpline.CalculateCentroid(System.Int32,Claron.WIF.Vector3[]@,System.Double[]@)">
             <summary>
            
             </summary>
             <param name="n"></param>
             <param name="sampledPts">Default value = null</param>
             <param name="curvs">Default value = null</param>
             <returns></returns>
             <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.CurveCubicSpline.CalculateCentroidOfControlPoints">
            <summary>
            Returns the centroid of the control points.
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.CurveCubicSpline.GetControlPointsForWhichCurvatureIsNotWithinBounds(System.Int32,System.Double,System.Double)">
            <summary>
            Returns the set of control points which influence positions of points along the curve at
            which the curvature is not within the specified range.
            </summary>
            <param name="n">The number of points to sample at along the whole length of the curve.</param>
            <param name="minCurvRadius">The minimum curvature.</param>
            <param name="maxCurvRadius">The maximum curvature.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.CurveCubicSpline.GetControlPointsForWhichCurvatureIsNotWithinBounds(System.Int32,System.Double[0:,0:])">
            <summary>
            Returns the set of control points which influence positions of points along the curve at
            which the curvature is not within the specified ranges.
            </summary>
            <param name="n">The number of points to sample at along the whole length of the curve.</param>
            <param name="curvRadiusBounds">A 2D array containing the min/max curvature radius for each
            sampled point. The dimensions of the array must be (n, 2).</param>
        </member>
        <member name="M:Claron.WIF.CurveCubicSpline.GetControlPointsForWhichCurvatureExceedsBounds(System.Int32,System.Double)">
            <summary>
            Returns the set of control point which influence positions of points along the curve at
            which the curvature exceeds the given curvature radius bound.
            </summary>
            <param name="n">The number of points to sample at along the whole length of the curve.</param>
            <param name="curvRadius">The curvature radius.</param>
        </member>
        <member name="M:Claron.WIF.CurveCubicSpline.GetControlPointsForWhichCurvatureExceedsBounds(System.Double)">
            <summary>
            Returns the set of control point which influence positions of points along the curve at
            which the curvature exceeds the given curvature radius bound. Samples points along the curve
            only at control points.
            </summary>
            <param name="curvRadius">The curvature radius.</param>
        </member>
        <member name="M:Claron.WIF.CurveCubicSpline.GetControlPointsForWhichCurvatureExceedsBounds(System.Double[])">
            <summary>
            Returns the set of control point which influence positions of points along the curve at
            which the curvature exceeds the given curvature radius bound. Samples points along the curve
            only at control points.
            </summary>
            <param name="curvRadii">The curvature radius at each sampled point.</param>
        </member>
        <member name="M:Claron.WIF.CurveCubicSpline.GetControlPointsForWhichCurvatureExceedsBounds(System.Int32,System.Double[])">
            <summary>
            Returns the set of control point which influence positions of points along the curve at
            which the curvature exceeds the given curvature radius bound.
            </summary>
            <param name="n">The number of points to sample at along the whole length of the curve.</param>
            <param name="curvRadii">The curvature radius at each sampled point.</param>
        </member>
        <member name="M:Claron.WIF.CurveCubicSpline.SmoothControlPointsForWhichCurvatureIsNotWithinBounds(System.Int32,System.Double,System.Double,System.Int32,System.Boolean)">
            <summary>
            Smoothes those control points which influence positions of points along the curve at which the
            curvature is not within the specified range.
            </summary>
            <param name="n">The number of points to sample at along the whole length of the curve.</param>
            <param name="minCurvRadius">The minimum curvature.</param>
            <param name="maxCurvRadius">The maximum curvature.</param>
            <param name="maxIterations">The maximum number of smoothing iterations.</param>
            <param name="smoothEndPoints">Whether to smooth end points or not.</param>
            <returns>Returns the number of smoothing iterations done.</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.CurveCubicSpline.SmoothControlPointsForWhichCurvatureExceedsBounds(System.Int32,System.Double[],System.Int32,System.Boolean)">
            <summary>
            Smoothes those control points which influence positions of points along the curve at which the
            curvature is not within the specified range.
            </summary>
            <param name="n">The number of points to sample at along the whole length of the curve.</param>
            <param name="minCurvRadii">An array containing the min curvature radii for each
            sampled point.</param>
            <param name="maxIterations">The maximum number of smoothing iterations.</param>
            <param name="smoothEndPoints">Whether to smooth end points or not.</param>
            <returns>Returns the number of smoothing iterations done.</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.CurveCubicSpline.SmoothControlPointsForWhichCurvatureExceedsBoundsIteratively(System.Double,System.Int32,System.Boolean,System.Int32)">
             <summary>
             Smoothes those control points which influence positions of points along the curve at which the
             curvature is not within the specified range. Uses an iterative approach:
            
             1. Phi = Calculate set of control points for which curvature exceeds bounds
             2. While Phi not empty
             3.   Calculate acceleration vectors for each control point in Phi
             4.   Move each control point in Phi in direction of corresponding acceleration vector
             5.   Phi = Calculate set of control points for which curvature exceeds bounds
             6. End While
             </summary>
             <returns></returns>
             <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.CurveCubicSpline.SmoothControlPointsForWhichCurvatureExceedsBoundsIteratively(System.Double[],System.Int32,System.Boolean,System.Int32)">
             <summary>
             Smoothes those control points which influence positions of points along the curve at which the
             curvature is not within the specified range. Uses an iterative approach:
            
             1. Phi = Calculate set of control points for which curvature exceeds bounds
             2. While Phi not empty
             3.   Calculate acceleration vectors for each control point in Phi
             4.   Move each control point in Phi in direction of corresponding acceleration vector
             5.   Phi = Calculate set of control points for which curvature exceeds bounds
             6. End While
             </summary>
             <returns></returns>
             <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.CurveCubicSpline.CalculateAccelerationVectorsAtControlPoints(System.Double@)">
            <summary>
            Returns the acceleration vectors at the control point locations.
            </summary>
        </member>
        <member name="M:Claron.WIF.CurveCubicSpline.ToCurve(System.Int32)">
            <summary>
            Converts to a curve (polyline).
            </summary>
            <param name="n">The number of points along each interval between control points at which
            to sample.</param>
        </member>
        <member name="M:Claron.WIF.CurveCubicSpline.ToCurveUniform(System.Int32)">
            <summary>
            Converts to a curve (polyline) with uniform sampling.
            </summary>
            <param name="n">The number of points along the curve to sample at.</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.CurveCubicSpline.Pts">
            <summary>
            The control points.
            </summary>
        </member>
        <member name="P:Claron.WIF.CurveCubicSpline.Closed">
            <summary>
            Property to get/set whether the curve is closed or not.
            </summary>
        </member>
        <member name="T:Claron.WIF.BucketSortedList`1">
            <summary>
            A bucket-sorted list of generic elements, each associated with an integer cost (usually mapped
            from a floating point value at the resolution/accuracy needed).
            Optimized for front-propagation algorithms, providing very fast insertions and "pop"
            of the lowest cost element, both done at ~O(1). It is about an order of magnitude faster
            than the Heap64FGeneric class.
            
            There is some loss of speed and an increase
            in memory consumption when the number of buckets becomes very large, so it is best to
            keep the bucket count as low as possible.
            
            The key internal data structure is an array of queues holding elements that map to the same
            integer cost. Elements with costs below the lowest or above the highest buckets are stored
            in heaps.
            
            
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Claron.WIF.BucketSortedList`1.Buckets">
            <summary>
            The array holding the buckets, each one a queue.
            </summary>
        </member>
        <member name="F:Claron.WIF.BucketSortedList`1.IsBucketNotEmptyBits">
            <summary>
            To greatly speed up scanning for the minimum cost bucket after a "pop", we also keep
            a bit-array representation of whether each bucket is not empty. The bits are ordered
            LSB to MSB in each word.
            </summary>
        </member>
        <member name="M:Claron.WIF.BucketSortedList`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new BucketSortedList with buckets in the given range.
            The highest efficiency is achieved with the smallest number of buckets
            that provides sufficient cost resolution. Since overflow and underflow is
            supported as well (somewhat less efficiently), the range does not need to 
            cost outliers.
            </summary>
            <param name="minBucketCost"></param>
            <param name="maxBucketCost"></param>
        </member>
        <member name="M:Claron.WIF.BucketSortedList`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an element to the list at a given cost level.
            </summary>
            <param name="cost"></param>
            <param name="element"></param>
        </member>
        <member name="M:Claron.WIF.BucketSortedList`1.PopMin">
            <summary>
            Removes and returns the element with the lowest cost in the list
            </summary>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.BucketSortedList`1.Clear">
            <summary>
            Rapidly removes all the elements from the list (while the buckets and the queues remain
            allocated).
            </summary>
        </member>
        <member name="M:Claron.WIF.BucketSortedList`1.MinCost">
            <summary>
            Returns the cost of the lowest cost element in the list
            </summary>
        </member>
        <member name="M:Claron.WIF.BucketSortedList`1.AllElements">
            <summary>
            Returns an array of all the elements in the list (not necessarily in precise cost order).
            </summary>
        </member>
        <member name="P:Claron.WIF.BucketSortedList`1.Count">
            <summary>
            The number of elements
            </summary>
        </member>
        <member name="T:Claron.WIF.SlidingBucketSortedList`1">
            <summary>
            A bucket-sorted list of generic elements, each associated with an integer "cost" value, where, 
            at any given time, the costs of the elements are in a relatively narrow range that is known in
            advance. The start of the range (ie, element with lowest cost) can slide up or down as 
            elements are added.
            
            Optimized for monotonously increasing front-propagation algorithms, such as distance map transform, 
            providing very fast insertions and "pop" of the lowest cost element, both done at ~O(1).
            It is about an order of magnitude faster than the Heap64FGeneric class.
            
            The key internal data structure is a circular array of queues holding all the elements that map 
            to the same integer cost.
            
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Claron.WIF.SlidingBucketSortedList`1.Buckets">
            <summary>
            The array holding the buckets, each one a queue.
            </summary>
        </member>
        <member name="M:Claron.WIF.SlidingBucketSortedList`1.#ctor(System.Int32)">
            <summary>
            Creates a new SlidingBucketSortedList with a given number of buckets
            </summary>
            <param name="BucketsCount">The "width" of the sliding array of buckets</param>
        </member>
        <member name="M:Claron.WIF.SlidingBucketSortedList`1.BucketI(System.Int32)">
            <summary>
            Returns the index of the bucket corresponding to a given cost
            </summary>
            <param name="cost"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.SlidingBucketSortedList`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an element to the list at a given cost level. An exception may be raised
            if the insertion would cause the range of costs in the list to exceed the
            number of buckets.
            </summary>
            <param name="cost"></param>
            <param name="element"></param>
        </member>
        <member name="M:Claron.WIF.SlidingBucketSortedList`1.PopMin">
            <summary>
            Removes and returns the element with the lowest cost in the list
            </summary>
            <returns></returns>
        </member>
        <member name="P:Claron.WIF.SlidingBucketSortedList`1.MinBucketCost">
            <summary>
            Current value of the lowest cost bucket
            </summary>
        </member>
        <member name="P:Claron.WIF.SlidingBucketSortedList`1.Count">
            <summary>
            The number of elements
            </summary>
        </member>
        <member name="T:Claron.WIF.Triple">
            <summary>
            stores three numbers in a single I64 i.e. (z-y-x) or (b-g-r)
            z/b: 22b:  -8192 to 8191 (14b)   decimal point (implicit)   0-256(8b) fractional values (q8)
            y/g: 21b:  -4096 to 4095 (13b)   decimal point (implicit)   0-256(8b) fractional values (q8)
            x/r: 21b:  -4096 to 4095 (13b)   decimal point (implicit)   0-256(8b) fractional values (q8)
            </summary>
        </member>
        <member name="M:Claron.WIF.Triple.Xq8CInt">
            <summary> only needed when q8 number are to be cast to int </summary>
        </member>
        <member name="M:Claron.WIF.Triple.Yq8CInt">
            <summary> only needed when q8 number are to be cast to int </summary>
        </member>
        <member name="M:Claron.WIF.Triple.Zq8CInt">
            <summary> only needed when q8 number are to be cast to int </summary>
        </member>
        <member name="M:Claron.WIF.Triple.op_Division(Claron.WIF.Triple,System.Int32)">
            <summary>
            per element div (iteger division = number of times k fits into each component
            </summary>
            <param name="t"></param>
            <param name="k"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Triple.op_Division(Claron.WIF.Triple,System.Double)">
            <summary>
            per component double division, result is rounded to fixed point precision
            </summary>
            <param name="t"></param>
            <param name="d"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Triple.op_BitwiseOr(Claron.WIF.Triple,Claron.WIF.Triple)">
            <summary>
            used to efficiently add a small offset b if it is known that a is a power of two
            (assumes that the offset range is equat to the power two gaps between possible values of a)
            (i.e. a = cube corner position = (4x, 4y, 4z), b=offset inside cube (0-3, 0-3, 0-3)
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Triple.Item(System.Int32)">
            <summary>
            A coordinate member, indexed 0 to 2.
            Less efficient than access using X, Y, Z
            </summary>
        </member>
        <member name="F:Claron.WIF.Triple.C.Tneg111">
            <summary> (-1, -1, -1) </summary>
        </member>
        <member name="F:Claron.WIF.Triple.C.T000">
            <summary> (0, 0, 0) </summary>
        </member>
        <member name="F:Claron.WIF.Triple.C.T001">
            <summary> (0, 0, 1) </summary>
        </member>
        <member name="F:Claron.WIF.Triple.C.T010">
            <summary> (0, 1, 0) </summary>
        </member>
        <member name="F:Claron.WIF.Triple.C.T100">
            <summary> (1, 0, 0) </summary>
        </member>
        <member name="F:Claron.WIF.Triple.C.T111">
            <summary> (1, 1, 1) </summary>
        </member>
        <member name="F:Claron.WIF.Triple.C.T123">
            <summary> (1, 1, 1) </summary>
        </member>
        <member name="F:Claron.WIF.Triple.C.T222">
            <summary> (2, 2, 2) </summary>
        </member>
        <member name="F:Claron.WIF.Triple.C.T333">
            <summary> (3, 3, 3) </summary>
        </member>
        <member name="F:Claron.WIF.Triple.C.T444">
            <summary> (4, 4, 4) </summary>
        </member>
        <member name="F:Claron.WIF.Triple.C.T555">
            <summary> (5, 5, 5) </summary>
        </member>
        <member name="F:Claron.WIF.Triple.C.T666">
            <summary> (6, 6, 6) </summary>
        </member>
        <member name="F:Claron.WIF.Triple.C.T777">
            <summary> (7, 7, 7) </summary>
        </member>
        <member name="F:Claron.WIF.Triple.C.T888">
            <summary> (8, 8, 8) </summary>
        </member>
        <member name="F:Claron.WIF.Triple.C.T999">
            <summary> (9, 9, 9) </summary>
        </member>
        <member name="F:Claron.WIF.Triple.C.TAAA">
            <summary> (10, 10, 10) </summary>
        </member>
        <member name="F:Claron.WIF.Triple.C.TFFF">
            <summary> (15, 15, 15) </summary>
        </member>
        <member name="F:Claron.WIF.Triple.C.TGGG">
            <summary> (16, 16, 16) </summary>
        </member>
        <member name="F:Claron.WIF.Triple.C.TVVV">
            <summary> (31, 31, 31) </summary>
        </member>
        <member name="F:Claron.WIF.Triple.C.TWWW">
            <summary> (32, 32 32) </summary>
        </member>
        <member name="F:Claron.WIF.HeapI64.HeapLevel._numElements">
            <summary>Total number of elements in array (this level).</summary>
        </member>
        <member name="F:Claron.WIF.HeapI64.HeapLevel._elements">
            <summary>Element array of one level in the heap.</summary>
        </member>
        <member name="F:Claron.WIF.HeapI64.HeapLevel._levelUp">
            <summary>Pointer to next level up. (with smaller valued elements and half as many array elements.</summary>
        </member>
        <member name="F:Claron.WIF.HeapI64.HeapLevel._levelDown">
            <summary>Pointer to next level down. (with larger valued elements and twice as many array elements.</summary>
        </member>
        <member name="F:Claron.WIF.HeapI64.HeapLevel._heap">
            <summary>Back pointer to complete heap.</summary>
        </member>
        <member name="M:Claron.WIF.HeapI64.HeapLevel.#ctor(Claron.WIF.HeapI64)">
            <summary>
            Creates a new empty heap level (at the root).
            </summary>
            <param name="heap">The parent heap.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.HeapI64.HeapLevel.#ctor(Claron.WIF.HeapI64.HeapLevel)">
            <summary>
            Creates a new heap level below the specified heap.
            </summary>
            <param name="levelUp">The level below which to create the new heap.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.HeapI64.HeapLevel.Insert(System.Int64)">
            <summary>
            Inserts a new element into the heap level.
            </summary>
            <param name="element"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.HeapI64.HeapLevel.FixUp(System.Int32)">
            <summary>
            Starts from current level and works up to root level swapping with parent as long
            as parent is larger.
            </summary>
            <param name="idx"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.HeapI64.HeapLevel.FixDown(System.Int32)">
            <summary>
            Traverses the tree from root to all levels below and swaps nodes so that
            tree is correctly ordered (each subtree has its smallest node at its root).
            </summary>
            <param name="idx"></param>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.HeapF64Generic`1">
            <summary>
            A semi-sorted heap of generic elements, each with associated F64 "cost", optimized
            for very fast selection and removal ("pop") of the lowest cost element of the list. 
            (Note: if you need to select one with the max value, rather than min cost, simply invert the 
            sign of the cost before adding each element to the heap).
            
            Usually used in the heapsort algorithm by repeatedly removing the smallest element of the heap
            and moving it to the sorted list result.
            
            Each level L in the heap holds up to 2^L elements, with each element at array
            index i at level L having higher cost than the element at index i/2 at level L-1.
            Level 0 is the root, with one element, the lowest cost element.
            When there are N elements in the heap, inserts and pops are O(log N).
            
            Much faster than SortedList and about 2X faster than SortedDictionary.
            Other than performance and a simpler interface, a major advantage over the .NET 
            collections is that it handles elements with identical costs.
            
            Timing on a 2.6 GHz XEON for a simulated front of ~2K elements propagating
            through 100K locations (100 cubed) with random costs is:
            vector3 elements: 43 ms
            integer (eg, index in the slicestack) elements: 31 ms
            
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Claron.WIF.HeapF64Generic`1.Insert(Claron.WIF.HeapF64Generic{`0}.F64Generic)">
            <summary>
            Insterts a new element with a 0 cost
            </summary>
        </member>
        <member name="M:Claron.WIF.HeapF64Generic`1.Insert(System.Double,`0)">
            <summary>
            Inserts a new element
            </summary>
            <param name="cost"></param>
            <param name="element"></param>
        </member>
        <member name="M:Claron.WIF.HeapF64Generic`1.PeekMin">
            <summary>
            Returns the lowest-cost element. 
            Will raise an exception if the heap is empty.
            </summary>
        </member>
        <member name="M:Claron.WIF.HeapF64Generic`1.PopMin">
            <summary>
            Returns the lowest-cost element and removes it from the heap.
            Will raise an exception if the heap is empty.
            </summary>
        </member>
        <member name="M:Claron.WIF.HeapF64Generic`1.AllElements">
            <summary>
            Collects and returns all the elements in the heap, in not guaranteed order
            (except that the first one has the lowest cost)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.HeapF64Generic`1.AllCosts">
            <summary>
            Collects and returns all the costs of elements in the heap, in the same order
            as AllElements.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Claron.WIF.HeapF64Generic`1.Size">
            <summary>
            The number of elements in the heap
            </summary>
        </member>
        <member name="T:Claron.WIF.HeapF64Generic`1.F64Generic">
            <summary>
            A struct to store cost-element pairs in the heap
            </summary>
        </member>
        <member name="M:Claron.WIF.HeapF64Generic`1.F64Generic.#ctor(System.Double)">
            <summary>
            Creates a new element and assigns 0 cost and a default value to the element
            </summary>
            <param name="f">ignored</param>
        </member>
        <member name="M:Claron.WIF.HeapF64Generic`1.F64Generic.#ctor(`0)">
            <summary>
            Creates a new element with a 0 cost
            </summary>
        </member>
        <member name="M:Claron.WIF.HeapF64Generic`1.F64Generic.#ctor(System.Double,`0)">
            <summary>
            Creates a new element with a given cost
            </summary>
        </member>
        <member name="T:Claron.WIF.HeapF64Generic`1.HeapLevel">
            <summary>
            One level in the tree structure of the Heap.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.HeapF64Generic`1.HeapLevel._numElements">
            <summary>Total number of elements in array (this level).</summary>
        </member>
        <member name="F:Claron.WIF.HeapF64Generic`1.HeapLevel._elements">
            <summary>Element array of one level in the heap.</summary>
        </member>
        <member name="F:Claron.WIF.HeapF64Generic`1.HeapLevel._levelUp">
            <summary>Pointer to next level up. (with smaller valued elements and half as many array elements.</summary>
        </member>
        <member name="F:Claron.WIF.HeapF64Generic`1.HeapLevel._levelDown">
            <summary>Pointer to next level down. (with larger valued elements and twice as many array elements.</summary>
        </member>
        <member name="F:Claron.WIF.HeapF64Generic`1.HeapLevel._heap">
            <summary>Back pointer to complete heap.</summary>
        </member>
        <member name="M:Claron.WIF.HeapF64Generic`1.HeapLevel.#ctor(Claron.WIF.HeapF64Generic{`0})">
            <summary>
            Creates a new empty heap level (at the root).
            </summary>
            <param name="heap">The parent heap.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.HeapF64Generic`1.HeapLevel.#ctor(Claron.WIF.HeapF64Generic{`0}.HeapLevel)">
            <summary>
            Creates a new heap level below the specified heap.
            </summary>
            <param name="levelUp">The level below which to create the new heap.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.HeapF64Generic`1.HeapLevel.Insert(Claron.WIF.HeapF64Generic{`0}.F64Generic)">
            <summary>
            Inserts a new element into the heap level, ensuring afterwards that if it is the smallest 
            element, it will perculate up to _root._elements[0].
            </summary>
            <param name="element"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.HeapF64Generic`1.HeapLevel.AddAllElements(System.Collections.Generic.List{`0})">
            <summary>
            Adds the elements of this level, then recursively of all the lower levels
            of the tree, to a given list.
            </summary>
        </member>
        <member name="M:Claron.WIF.HeapF64Generic`1.HeapLevel.AddAllCosts(System.Collections.Generic.List{System.Double})">
            <summary>
            Adds the costs of this level, then recursively of all the lower levels
            of the tree, to a given list. The costs are ordered the same way as in the array
            returned by AddAllElements.
            </summary>
        </member>
        <member name="M:Claron.WIF.HeapF64Generic`1.HeapLevel.FixUp(System.Int32)">
            <summary>
            Starts from current level and works up to root level swapping with parent as long
            as parent is larger.
            </summary>
            <param name="idx"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.HeapF64Generic`1.HeapLevel.FixDown(System.Int32)">
            <summary>
            Traverses the tree from root to all levels below and swaps nodes so that
            tree is correctly ordered (each subtree has its smallest node at its root).
            </summary>
            <param name="idx"></param>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.HeapF64I32">
            <summary>
            A heap with elements of a F64 cost and I32 index position. Implementation of generic class HeapF64Generic
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.HeapF64Vertex">
            <summary>
            A heap with elements of a F64 cost and WingEdgeMesh.Vertex element. Implementation of generic class HeapF64Generic
            Used for finding the best route on WingEdgeMesh
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.QuadtreeNode">
            <summary>
            Quadtree for Vector2 structures to assist in efficiently searching for the closest
            point in a large collection of 2D points. To use the class, first call the
            static function QuadtreeNode.BuildTree() with the collection of points and the maximum number
            of points to store in each node. After building the tree call the
            QuadtreeNode.GetClosestPoint() function to get the closest point in the set to a given point.
            </summary>
        </member>
        <member name="F:Claron.WIF.QuadtreeNode._mid">
            <summary>
            The median location.
            </summary>
        </member>
        <member name="F:Claron.WIF.QuadtreeNode._depth">
            <summary>
            The depth of the node.
            </summary>
        </member>
        <member name="F:Claron.WIF.QuadtreeNode._pts">
            <summary>
            The points in the node.
            </summary>
        </member>
        <member name="F:Claron.WIF.QuadtreeNode._node0">
            <summary>
            The first node.
            </summary>
        </member>
        <member name="F:Claron.WIF.QuadtreeNode._node1">
            <summary>
            The second node.
            </summary>
        </member>
        <member name="M:Claron.WIF.QuadtreeNode.BuildTree(Claron.WIF.Vector2[],System.Int32)">
            <summary>
            Builds a quadtree from the given pts.
            </summary>
            <param name="pts">The points in the node.</param>
            <param name="maxPtsPerNode">The maximum number of points in each leaf node.</param>
        </member>
        <member name="M:Claron.WIF.QuadtreeNode.BuildTree(System.Int32)">
            <summary>
            Adds child nodes to the current node if the number of points in the node exceeds the maximum
            number of points.
            </summary>
        </member>
        <member name="M:Claron.WIF.QuadtreeNode.GetClosestPoint(Claron.WIF.Vector2,Claron.WIF.Vector2@)">
            <summary>
            Finds the closest point to the given point.
            </summary>
        </member>
        <member name="M:Claron.WIF.QuadtreeNode.GetClosestPoint(Claron.WIF.Vector2,System.Double@,Claron.WIF.Vector2@)">
            <summary>
            Returns the closest point to the given point.
            </summary>
            <param name="pt">The point to test.</param>
            <param name="cr">The distance to the closest point.</param>
            <param name="cp">The closest point.</param>
        </member>
        <member name="T:Claron.WIF.OctreeNode">
            <summary>
            Octree node for Vector3 structures to assist in efficiently searching for the closest
            point in a large collection of 3D points. To use the class, first call the
            static function OctreeNode.BuildTree() with the collection of points and the maximum number
            of points to store in each node. After building the tree call the
            OctreeNode.GetClosestPoint() function to find the closest point in the set to a given point.
            </summary>
        </member>
        <member name="F:Claron.WIF.OctreeNode._mid">
            <summary>
            The median location.
            </summary>
        </member>
        <member name="F:Claron.WIF.OctreeNode._depth">
            <summary>
            The depth of the node.
            </summary>
        </member>
        <member name="F:Claron.WIF.OctreeNode._pts">
            <summary>
            The points in the node.
            </summary>
        </member>
        <member name="F:Claron.WIF.OctreeNode._node0">
            <summary>
            The first node.
            </summary>
        </member>
        <member name="F:Claron.WIF.OctreeNode._node1">
            <summary>
            The second node.
            </summary>
        </member>
        <member name="M:Claron.WIF.OctreeNode.BuildTree(Claron.WIF.Vector3[],System.Int32)">
            <summary>
            Builds a octree from the given pts.
            </summary>
            <param name="pts">The points in the node.</param>
            <param name="maxPtsPerNode">The maximum number of points in each node.</param>
        </member>
        <member name="M:Claron.WIF.OctreeNode.BuildTree(System.Int32)">
            <summary>
            Adds child nodes to the current node if the number of points in the node exceeds the maximum
            number of points.
            </summary>
        </member>
        <member name="M:Claron.WIF.OctreeNode.GetClosestPoint(Claron.WIF.Vector3,Claron.WIF.Vector3@)">
            <summary>
            Finds the closest point to the given point.
            </summary>
        </member>
        <member name="M:Claron.WIF.OctreeNode.GetClosestPoint(Claron.WIF.Vector3,System.Double@,Claron.WIF.Vector3@)">
            <summary>
            Returns the closest point to the given point.
            </summary>
            <param name="pt">The point to test.</param>
            <param name="cr">The distance to the closest point.</param>
            <param name="cp">The closest point.</param>
        </member>
        <member name="T:Claron.WIF.IPosition">
            <summary>
            Interface for positions.
            </summary>
        </member>
        <member name="T:Claron.WIF.ComparerX`1">
            <summary>
            Class for comparing the x-coordinates of objects which implement the
            IPosition interface.
            </summary>
        </member>
        <member name="T:Claron.WIF.ComparerY`1">
            <summary>
            Class for comparing the y-coordinates of objects which implement the
            IPosition interface.
            </summary>
        </member>
        <member name="T:Claron.WIF.ComparerZ`1">
            <summary>
            Class for comparing the z-coordinates of objects which implement the
            IPosition interface.
            </summary>
        </member>
        <member name="T:Claron.WIF.OctreeNode`1">
            <summary>
            Octree node for find the closest object to a given position. To use the class, first call the
            static function OctreeNode.BuildTree() with the collection of objects and the maximum number
            of objects to store in each node. The objects in the tree must satisfy the IPosition
            interface which contains functions for returning the position of the object and for comparing
            the relative position of objects in the x-, y-, and z-directions. After building the tree
            call the OctreeNode.GetClosestObject() function to get the closest object to a given point.
            </summary>
        </member>
        <member name="F:Claron.WIF.OctreeNode`1._mid">
            <summary>
            The median location.
            </summary>
        </member>
        <member name="F:Claron.WIF.OctreeNode`1._depth">
            <summary>
            The depth of the node.
            </summary>
        </member>
        <member name="F:Claron.WIF.OctreeNode`1._objs">
            <summary>
            The objects in the node.
            </summary>
        </member>
        <member name="F:Claron.WIF.OctreeNode`1._node0">
            <summary>
            The first node.
            </summary>
        </member>
        <member name="F:Claron.WIF.OctreeNode`1._node1">
            <summary>
            The second node.
            </summary>
        </member>
        <member name="M:Claron.WIF.OctreeNode`1.BuildTree(`0[],System.Int32)">
            <summary>
            Builds a octree from the given objects.
            </summary>
            <param name="objs">The objects in the node.</param>
            <param name="maxObjsPerNode">The maximum number of objects in each node.</param>
        </member>
        <member name="M:Claron.WIF.OctreeNode`1.BuildTree(System.Int32)">
            <summary>
            Adds child nodes to the current node if the number of objects in the node exceeds
            the maximum number of objects.
            </summary>
        </member>
        <member name="M:Claron.WIF.OctreeNode`1.GetClosestObject(Claron.WIF.Vector3,`0@)">
            <summary>
            Finds the closest point to the given point.
            </summary>
        </member>
        <member name="M:Claron.WIF.OctreeNode`1.GetClosestObject(Claron.WIF.Vector3,System.Double@,`0@)">
            <summary>
            Returns the closest object to the given point.
            </summary>
            <param name="pt">The point to test.</param>
            <param name="cr">The distance to the closest point.</param>
            <param name="cp">The closest object.</param>
        </member>
        <member name="T:Claron.WIF.OctreeNodeTriangles">
            <summary>
            Octree node for triangles. To use the class, first call the
            static function OctreeNodeTriangles.BuildTree() with the collection of triangles and the
            maximum number of triangles to store in each node. After building the tree
            call the OctreeNode.GetClosestPoint() function to get the closest point in the triangle set
            to the given point.
            </summary>
        </member>
        <member name="F:Claron.WIF.OctreeNodeTriangles._depth">
            <summary>
            The depth of the node.
            </summary>
        </member>
        <member name="F:Claron.WIF.OctreeNodeTriangles._pts">
            <summary>
            The points in the node. Null for all non-leaf nodes.
            </summary>
        </member>
        <member name="F:Claron.WIF.OctreeNodeTriangles._tris">
            <summary>
            The triangles in the node. Null for all non-leaf nodes.
            </summary>
        </member>
        <member name="F:Claron.WIF.OctreeNodeTriangles._nodes">
            <summary>
            The child nodes.
            </summary>
        </member>
        <member name="F:Claron.WIF.OctreeNodeTriangles._x">
            <summary>
            Coordinates of node partitions in the x-direction.
            </summary>
        </member>
        <member name="F:Claron.WIF.OctreeNodeTriangles._y0">
            <summary>
            Coordinates of node partitions in the y-direction.
            </summary>
        </member>
        <member name="F:Claron.WIF.OctreeNodeTriangles._y1">
            <summary>
            Coordinates of node partitions in the y-direction.
            </summary>
        </member>
        <member name="F:Claron.WIF.OctreeNodeTriangles._z0">
            <summary>
            Coordinates of node partitions in the z-direction.
            </summary>
        </member>
        <member name="F:Claron.WIF.OctreeNodeTriangles._z1">
            <summary>
            Coordinates of node partitions in the z-direction.
            </summary>
        </member>
        <member name="F:Claron.WIF.OctreeNodeTriangles._z2">
            <summary>
            Coordinates of node partitions in the z-direction.
            </summary>
        </member>
        <member name="F:Claron.WIF.OctreeNodeTriangles._z3">
            <summary>
            Coordinates of node partitions in the z-direction.
            </summary>
        </member>
        <member name="M:Claron.WIF.OctreeNodeTriangles.BuildTree(Claron.WIF.Vector3[],System.Int32[][],System.Int32)">
            <summary>
            Builds a octree from the given triangles.
            </summary>
            <param name="pts">The vertices of the triangle set.</param>
            <param name="triangles">The triangles.</param>
            <param name="maxTrisPerNode">The maximum number of triangles that can be present in the
            leaf nodes.</param>
        </member>
        <member name="M:Claron.WIF.OctreeNodeTriangles.BuildTree(Claron.WIF.Surface,System.Int32)">
            <summary>
            Builds a octree from the given surface.
            </summary>
            <param name="surface">The surface which must contain triangles only.</param>
            <param name="maxTrisPerNode">The maximum number of triangles that can be present in the
            leaf nodes.</param>
        </member>
        <member name="M:Claron.WIF.OctreeNodeTriangles.BuildTree(System.Int32)">
            <summary>
            Adds child nodes to the current node if the number of triangles in the node exceeds the
            maximum number of triangles.
            </summary>
            <param name="maxTrisPerNode">The maximum number of triangles in each node.</param>
            <returns>Returns true if the tree was partitioned into sub-nodes.</returns>
        </member>
        <member name="M:Claron.WIF.OctreeNodeTriangles.SplitInXDirection(System.Int32[][],System.Double@,System.Int32[][]@,System.Int32[][]@)">
            <summary>
            Splits the triangles in the x-direction based on the bounding boxes of the triangles.
            </summary>
            <param name="tris">The triangles to split.</param>
            <param name="midX">The median value of the maximum x-coordinates of the bounding boxes of the
            triangles.</param>
            <param name="node0Tris">The triangles in the first node.</param>
            <param name="node1Tris">The triangles in the second node.</param>
        </member>
        <member name="M:Claron.WIF.OctreeNodeTriangles.SplitInYDirection(System.Int32[][],System.Double@,System.Int32[][]@,System.Int32[][]@)">
            <summary>
            Splits the triangles in the y-direction based on the bounding boxes of the triangles.
            </summary>
            <param name="tris">The triangles to split.</param>
            <param name="midY">The median value of the maximum y-coordinates of the bounding boxes of the
            triangles.</param>
            <param name="node0Tris">The triangles in the first node.</param>
            <param name="node1Tris">The triangles in the second node.</param>
        </member>
        <member name="M:Claron.WIF.OctreeNodeTriangles.SplitInZDirection(System.Int32[][],System.Double@,System.Int32[][]@,System.Int32[][]@)">
            <summary>
            Splits the triangles in the z-direction based on the bounding boxes of the triangles.
            </summary>
            <param name="tris">The triangles to split.</param>
            <param name="midZ">The median value of the maximum z-coordinates of the bounding boxes of the
            triangles.</param>
            <param name="node0Tris">The triangles in the first node.</param>
            <param name="node1Tris">The triangles in the second node.</param>
        </member>
        <member name="M:Claron.WIF.OctreeNodeTriangles.GetBoundingBoxOfTriangle(System.Int32[],Claron.WIF.Vector3@,Claron.WIF.Vector3@)">
            <summary>
            Returns the bounding box of the given triangle.
            </summary>
            <param name="tri">The vertex indices of the triangle.</param>
            <param name="min">The minimum corner of the bounding box.</param>
            <param name="max">The maximum corner of the bounding box.</param>
        </member>
        <member name="M:Claron.WIF.OctreeNodeTriangles.GetClosestPoint(Claron.WIF.Vector3,Claron.WIF.Vector3@)">
            <summary>
            Returns the closest point on the triangle set.
            </summary>
            <param name="pt">The point to test.</param>
            <param name="cp">The closest point on the triangles.</param>
        </member>
        <member name="M:Claron.WIF.OctreeNodeTriangles.GetClosestPoint(Claron.WIF.Vector3,System.Double@,Claron.WIF.Vector3@,System.Int32[]@)">
            <summary>
            Returns the closest point on the triangle set.
            </summary>
            <param name="pt">The point to test.</param>
            <param name="cr">The smallest distance to the triangles.</param>
            <param name="cp">The closest point on the triangles.</param>
            <param name="cTriIndexes">The closest triangle (pt indexes)</param>
        </member>
        <member name="M:Claron.WIF.OctreeNodeTriangles.GetClosestPoint(Claron.WIF.Vector3,System.Double@,Claron.WIF.Vector3@)">
            <summary>
            Returns the closest point on the triangle set.
            </summary>
            <param name="pt">The point to test.</param>
            <param name="cr">The smallest distance to the triangles.</param>
            <param name="cp">The closest point on the triangles.</param>
        </member>
        <member name="M:Claron.WIF.OctreeNodeTriangles.GetClosestPointX(Claron.WIF.Vector3,System.Double@,Claron.WIF.Vector3@,System.Int32[]@)">
            <summary>
            Returns the closest point in the triangle set in the x-direction.
            </summary>
            <param name="pt">The point to test.</param>
            <param name="cr">The smallest distance to the triangles.</param>
            <param name="cp">The closest point.</param>
            <param name="cTriIndexes">The closest triangle</param>
        </member>
        <member name="M:Claron.WIF.OctreeNodeTriangles.GetClosestPointY(Claron.WIF.Vector3,System.Double@,Claron.WIF.Vector3@,System.Int32,System.Int32[]@)">
            <summary>
            Returns the closest point in the triangle set in the y-direction.
            </summary>
            <param name="pt">The point to test.</param>
            <param name="cr">The smallest distance to the triangles.</param>
            <param name="cp">The closest point.</param>
            <param name="node">The node.</param>
            <param name="cTriIndexes">The closest triangle</param>
        </member>
        <member name="M:Claron.WIF.OctreeNodeTriangles.GetClosestPointZ(Claron.WIF.Vector3,System.Double@,Claron.WIF.Vector3@,System.Int32,System.Int32[]@)">
            <summary>
            Returns the closest point in the triangle set in the z-direction.
            </summary>
            <param name="pt">The point to test.</param>
            <param name="cr">The smallest distance to the triangles.</param>
            <param name="cp">The closest point.</param>
            <param name="node">The node.</param>
            <param name="cTriIndexes">The closest triangle</param>
        </member>
        <member name="M:Claron.WIF.OctreeNodeTriangles.ComputeTriangleNormal(Claron.WIF.Vector3,Claron.WIF.Vector3,Claron.WIF.Vector3)">
            <summary>
            Calculates the triangle normal vector from the given vertices of the triangle.
            </summary>
        </member>
        <member name="M:Claron.WIF.OctreeNodeTriangles.GetClosestPointOnTriangle(Claron.WIF.Vector3,Claron.WIF.Vector3,Claron.WIF.Vector3,Claron.WIF.Vector3)">
            <summary>
            Returns the closest point on the triangle formed by the vertices vs to the given point r.
            </summary>
            <param name="v0">The first vertex of the triangle.</param>
            <param name="v1">The second vertex of the triangle.</param>
            <param name="v2">The third vertex of the triangle.</param>
            <param name="r">The point to test.</param>
        </member>
        <member name="M:Claron.WIF.OctreeNodeTriangles.GetClosestPointOnTriangleApproximate_Debug(Claron.WIF.Vector3[],Claron.WIF.Vector3)">
            <summary>
            Returns the approximate closest point on the triangle by discretely sampling points on the
            triangle and choosing the point which is closest to the given point. This code is for
            debugging purposes only.
            </summary>
            <param name="vs">The points of the triangle.</param>
            <param name="r">The point to find the closest point on the triangle of.</param>
        </member>
        <member name="F:Claron.WIF.Histogram._counts">
            <summary>
            A histogram of 16b values (32b counters) with the first and last bin also
            keeping all of the overflow
            </summary>
        </member>
        <member name="M:Claron.WIF.Histogram.#ctor(System.Int32,System.Int32)">
            <summary>
            creates a new histogram between BinMin and BinMax. Values added to the
            histogram below the value represented by BinMin are added to BinMin, and similarly
            for BinMax.
            </summary>
            <param name="valueMatchForBinMin">Value that the minimum bin (index 0) represents. </param>
            <param name="valueMatchForBinMax">Value that the maximum bin (index BinMax-BinMin) represents</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Histogram.AddCounts(System.Int16[])">
            <summary>
            Increments the histogram bins according the the values in the array
            </summary>
            <param name="values">An array of values to be included (usually an array of Hu values)</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Histogram.AddCounts(System.Int16[],System.Int32,System.Boolean)">
            <summary>
            Increments the histogram bins according the the values in the array
            </summary>
            <param name="values">An array of values to be included (usually an array of Hu values)</param>
            <param name="valsUbound">The highest index of valid values in the array,
            which can be less than the full array size. If negative, all the values are used. Default value = -1</param>
            <param name="excludeValuesOutsideValidRange">If set to true then values outside the range
            [_valueMatchForBinMin, _valueMatchForBinMax] are ignored and not added to the histogram. Default value = False</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Histogram.AddCounts(System.Int32[])">
            <summary>
            Increments the histogram bins according the the values in the array
            </summary>
            <param name="values">An array of values to be included.</param>
        </member>
        <member name="M:Claron.WIF.Histogram.AddCounts(System.Int32[],System.Int32,System.Boolean)">
            <summary>
            Increments the histogram bins according to the values in the array.
            </summary>
            <param name="values">An array of values to be included (usually an array of Hu values)</param>
            <param name="valsUbound">The highest index of valid values in the array,
            which can be less than the full array size. If negative, all the values are used. Default value = -1</param>
            <param name="excludeValuesOutsideValidRange">If set to true then values outside the range
            [_valueMatchForBinMin, _valueMatchForBinMax] are ignored and not added to the histogram. Default value = False</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Histogram.AddCounts(System.Byte[],System.Int32,System.Boolean)">
            <summary>
            Increments the histogram bins according to the values in the array.
            </summary>
            <param name="values">An array of values to be included (usually an array of bitmap intensity
            values).</param>
            <param name="valsUbound">The highest index of valid values in the array,
            which can be less than the full array size. If negative, all the values are used</param>
            <param name="excludeValuesOutsideValidRange">If set to true then values outside the range
            [_valueMatchForBinMin, _valueMatchForBinMax] are ignored and not added to the histogram.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Histogram.AddHist(System.Int32[],System.Int32)">
            <summary>
            Sets the histogram bin counts according to the values in the array.
            </summary>
            <param name="histCounts">A 'dumb' array of histogram bin counts.</param>
            <param name="valueMatchForExternalBinMin">The value matching the first bin of the histCounts array. Default value = 0</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Histogram.AddHist(System.UInt64[],System.Int32)">
            <summary>
            Sets the histogram bin counts according to the values in the array.
            </summary>
            <param name="histCounts">A 'dumb' array of histogram bin counts.</param>
            <param name="valueMatchForExternalBinMin">The value matching the first bin of the histCounts array. Default value = 0</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Histogram.AddHist(System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets the histogram bin counts according to the values in the array.
            </summary>
            <param name="histCounts">A 'dumb' array of histogram bin counts.</param>
            <param name="valueMatchForExternalBinMin">The value matching the first bin of the histCounts array. Default value = 0</param>
            <param name="kBgn">Bgn index of counts array to be considered</param>
            <param name="kEnd">End index of counts array to be considered</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Histogram.Percentile(System.Int32,System.Boolean)">
            <summary>
            Returns the value below which the given percent of samples lies.
            </summary>
            <param name="Percent"></param>
            <param name="IgnoreEndBins">Default value = False</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Histogram.CountOfVal(System.Int16)">
            <summary>
            The count of values in the bin matching the argumant val
            </summary>
            <param name="val">the Hu value for which the matching bin is wanted</param>
            <returns>the count of the matching bin</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Histogram.CountAtIdx(System.Int16)">
            <summary>
            The count of values in the bin at the given index
            </summary>
            <param name="index">the index for which the bin count is wanted</param>
            <returns>the count of the matching bin</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Histogram.CountSumHigh(System.Int16)">
            <summary>
            the sum of all counts starting at the bin matching the argument value and ending at the maximum bin
            </summary>
            <param name="val">the Hu value for which the matching bin is wanted</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Histogram.ConstrainedBinsHistogram(System.Int16,System.Int16)">
            <summary>
            Computes a sub section of the histogram, dropping the counts before and after.
            All statistics are updated to reflect the new bin value range.
            </summary>
            <param name="newValueMatchForBinMin"></param>
            <param name="newValueMatchForBinMax"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Histogram.ContrastFalloffInterval(System.Int32@,System.Int32@)">
            <summary>
            Computes the interval of the steepest falling slope.
            </summary>
            <param name="k0"></param>
            <param name="k1"></param>
        </member>
        <member name="M:Claron.WIF.Histogram.FirstFallOffKneeInCurve">
            <summary>
            Computes the knee in the curve of the first slope of the histogram count array, 
            i.e. the index that is likely to separate foreground from background.
            </summary>
        </member>
        <member name="M:Claron.WIF.Histogram.FirstRisingKneeInCurveValue">
            <summary>
            Computes the knee in the curve of the first up slope of the histogram count array, 
            i.e. the index that is likely to separate foreground from background in a segmented object.
            </summary>
        </member>
        <member name="M:Claron.WIF.Histogram.op_Addition(Claron.WIF.Histogram,Claron.WIF.Histogram)">
            <summary>
            returns the union of two histograms
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>the combined histogram</returns>
            <remarks>assumes both histograms cover the same value range</remarks>
        </member>
        <member name="M:Claron.WIF.Histogram.op_Subtraction(Claron.WIF.Histogram,Claron.WIF.Histogram)">
            <summary>
            returns the difference of two histograms
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>histogram of a without the counts of b</returns>
            <remarks>assumes both histograms cover the same value range</remarks>
        </member>
        <member name="M:Claron.WIF.Histogram.WriteCountsToCsvFile(System.String)">
            <summary>
            Writes a smoothed version of the histogram cure and its first two derivatives to to a .CSV file.
            Filename: "d:\tmp\hist_[your name parameter]_000.csv".
            </summary>
            <param name="name">histogram identificatrion string, "hist_" will be perpended.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Histogram.WriteCountsToCsvFile(System.String,System.Int32@)">
            <summary>
            Writes a smoothed version of the histogram cure and its first two derivatives to to a .CSV file.
            Filename: "d:\tmp\hist_[your name parameter]_001.csv" where the number from the second argument and gets incremented inside the function.
            </summary>
            <param name="name">histogram identification string, "hist_" will be perpended.</param>
            <param name="fileNumber">ByRef, is incremented inside function.</param>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Histogram.Counts">
            <summary>
            Return (a copy of) the array of bin counts
            </summary>
        </member>
        <member name="F:Claron.WIF.Histogram.Stats.Min">
            <summary> the minimum value </summary>
        </member>
        <member name="F:Claron.WIF.Histogram.Stats.Max">
            <summary> the maximum value </summary>
        </member>
        <member name="F:Claron.WIF.Histogram.Stats.Average">
            <summary> the average value </summary>
        </member>
        <member name="F:Claron.WIF.Histogram.Stats.STD">
            <summary> the standard deviation of the values in the histogam</summary>
        </member>
        <member name="F:Claron.WIF.Histogram.Stats.MostFrequent">
            <summary> the value occurring most frequently </summary>
        </member>
        <member name="F:Claron.WIF.Histogram.Stats.Percentile05">
            <summary> the value the the lowest 5% of all values do not exceed </summary>
        </member>
        <member name="F:Claron.WIF.Histogram.Stats.Percentile10">
            <summary> the value the the lowest 10% of all values do not exceed </summary>
        </member>
        <member name="F:Claron.WIF.Histogram.Stats.Percentile25">
            <summary> the value the the lowest 25% of all values do not exceed </summary>
        </member>
        <member name="F:Claron.WIF.Histogram.Stats.Percentile50">
            <summary> the value the the lowest 50% of all values do not exceed </summary>
        </member>
        <member name="F:Claron.WIF.Histogram.Stats.Percentile75">
            <summary> the value the the lowest 75% of all values do not exceed </summary>
        </member>
        <member name="F:Claron.WIF.Histogram.Stats.Percentile90">
            <summary> the value the the lowest 90% of all values do not exceed </summary>
        </member>
        <member name="F:Claron.WIF.Histogram.Stats.Percentile95">
            <summary> the value the the lowest 95% of all values do not exceed </summary>
        </member>
        <member name="F:Claron.WIF.Histogram.Stats.SumCounts">
            <summary> the count of values of all bins combined </summary>
        </member>
        <member name="M:Claron.WIF.Histogram.Stats.InModalityValues(Claron.WIF.ImageU12)">
            <summary>
            Assuming the statistics were in stored values, converts them to
            the modality values of the given image.
            </summary>
            <param name="OfImage">The image of whose stored values were placed in
            the histogram</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Histogram.Stats.GreyscaleRangeMin">
            <summary> the lower bound of the greyscale values range</summary>
        </member>
        <member name="P:Claron.WIF.Histogram.Stats.GreyscaleRangeMax">
            <summary> the upper bound of the greyscale values range</summary>
        </member>
        <member name="T:Claron.WIF.Histogram2D">
            <summary>
            Class for 2D histograms.
            </summary>
        </member>
        <member name="F:Claron.WIF.Histogram2D._minX">
            <summary>
            The minimum value in the x variable.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Histogram2D._maxX">
            <summary>
            The maximum value in the x variable.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Histogram2D._nBinsX">
            <summary>
            The number of bins in the x-direction.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Histogram2D._widthX">
            <summary>
            The width of the bins in the x-direction. Set automatically by the
            class.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Histogram2D._minY">
            <summary>
            The minimum value in the y variable.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Histogram2D._maxY">
            <summary>
            The maximum value in the y variable.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Histogram2D._nBinsY">
            <summary>
            The number of bins in the y-direction.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Histogram2D._widthY">
            <summary>
            The width of the bins in the y-direction. Set automatically by the
            class.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Histogram2D._samples">
            <summary>
            2D array stores the number of samples in each bin. The first index
            corresponds to the y variable and the second index to the x variable.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Histogram2D.#ctor(System.Double,System.Double,System.Int32,System.Double,System.Double,System.Int32)">
            <summary>
            Creates a new 2D histogram.
            </summary>
            <param name="minX">The minimum value in the x variable.</param>
            <param name="maxX">The maximum value in the y variable.</param>
            <param name="nBinsX">The number of bins in the x range.</param>
            <param name="minY">The minimum value in the y variable.</param>
            <param name="maxY">The maximum value in the y variable.</param>
            <param name="nBinsY">The number of bins in the y range.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Histogram2D.#ctor">
            <summary>
            Creates a new 2D histogram.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Histogram2D.Clone">
            <summary>
            Returns a clone of the space mapper.
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Histogram2D.AddSample(System.Double,System.Double)">
            <summary>
            Adds a new sample.
            </summary>
            <param name="x">The x variable value.</param>
            <param name="y">The y variable value.</param>
            <remarks>If the sample is out of bounds an exception is thrown.
            </remarks>
        </member>
        <member name="M:Claron.WIF.Histogram2D.IncBin(System.Int32,System.Int32)">
            <summary>
            Increases a bin sample value by 1.
            </summary>
            <param name="i">The x variable bin index.</param>
            <param name="j">The y variable bin index.</param>
            <remarks>No bounds checks are made.</remarks>
        </member>
        <member name="M:Claron.WIF.Histogram2D.RemoveSample(System.Double,System.Double)">
            <summary>
            Removes a sample.
            </summary>
            <param name="x">The x variable value.</param>
            <param name="y">The y variable value.</param>
            <remarks>If the sample is out of bounds an exception is thrown.
            </remarks>
        </member>
        <member name="M:Claron.WIF.Histogram2D.DecBin(System.Int32,System.Int32)">
            <summary>
            Decreases a bin sample value by 1.
            </summary>
            <param name="i">The x variable value.</param>
            <param name="j">The y variable value.</param>
            <remarks>No bounds checks are made.</remarks>
        </member>
        <member name="M:Claron.WIF.Histogram2D.Reset">
            <summary>
            Resets the histogram 2D bin samples to 0.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Histogram2D.BinVal(System.Int32,System.Int32)">
            <summary>
            Returns the x and y variable values corresponding to a pair of bin
            indices.
            </summary>
            <param name="i">The x variable bin index.</param>
            <param name="j">The y variable bin index.</param>
            <returns>The x and y variable values are returned in a 1D array.
            </returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Histogram2D.NumberOfSamplesInBin(System.Int32,System.Int32)">
            <summary>
            Returns the number of samples in a bin.
            </summary>
            <param name="i">The x variable bin index.</param>
            <param name="j">The y variable bin index.</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Histogram2D.nBinsX">
            <summary>
            Property to get the number of bins for the x variable.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Histogram2D.nBinsY">
            <summary>
            Property to get the number of bins for the y variable.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Histogram2D.Samples">
            <summary>
            Property for retrieving the samples in each bin.
            </summary>
            <value></value>
            <returns>A 2D array storing the number of samples in each bin.</returns>
            <remarks>The first index corresponds to the y variable and the
            second index to the x variable.</remarks>
        </member>
        <member name="P:Claron.WIF.Histogram2D.TotalNumberOfSamples">
            <summary>
            Returns the total number of samples in the histogram.
            </summary>
            <value></value>
            <returns>The total number of samples in the histogram.</returns>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.Histogram2DInt32">
            <summary>
            Class for 2D histograms in which the x and y variables are integers.
            </summary>
        </member>
        <member name="F:Claron.WIF.Histogram2DInt32._minX">
            <summary>
            The minimum value in the x variable.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Histogram2DInt32._maxX">
            <summary>
            The maximum value in the x variable.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Histogram2DInt32._nBinsX">
            <summary>
            The number of bins in the x-direction.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Histogram2DInt32._widthX">
            <summary>
            The width of the bins in the x-direction. Set automatically by the
            class.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Histogram2DInt32._minY">
            <summary>
            The minimum value in the y variable.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Histogram2DInt32._maxY">
            <summary>
            The maximum value in the y variable.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Histogram2DInt32._nBinsY">
            <summary>
            The number of bins in the y-direction.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Histogram2DInt32._widthY">
            <summary>
            The width of the bins in the y-direction. Set automatically by the
            class.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Histogram2DInt32._samples">
            <summary>
            2D array stores the number of samples in each bin. The first index
            corresponds to the y variable and the second index to the x variable.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Histogram2DInt32._xBinIndices">
            <summary>
            The x variable bin indexes.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Histogram2DInt32._yBinIndices">
            <summary>
            The y variable bin indexes.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Histogram2DInt32.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new 2D histogram.
            </summary>
            <param name="minX">The minimum value in the x variable.</param>
            <param name="maxX">The maximum value in the y variable.</param>
            <param name="nBinsX">The number of bins in the x range.</param>
            <param name="minY">The minimum value in the y variable.</param>
            <param name="maxY">The maximum value in the y variable.</param>
            <param name="nBinsY">The number of bins in the y range.</param>
        </member>
        <member name="M:Claron.WIF.Histogram2DInt32.#ctor">
            <summary>
            Returns a new 2D histogram for Int32 variables.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Histogram2DInt32.Clone">
            <summary>
            Returns a clone of the histogram.
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Histogram2DInt32.CloneWithSamplesSetToZero">
            <summary>
            Returns a clone of the histogram with the sample values
            set to zero.
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Histogram2DInt32.AddSample(System.Int32,System.Int32)">
            <summary>
            Adds a new sample.
            </summary>
            <param name="x">The x variable value.</param>
            <param name="y">The y variable value.</param>
            <remarks>No bounds checking is done.
            </remarks>
        </member>
        <member name="M:Claron.WIF.Histogram2DInt32.IncBin(System.Int32,System.Int32)">
            <summary>
            Increases a bin sample value by 1.
            </summary>
            <param name="i">The x variable bin index.</param>
            <param name="j">The y variable bin index.</param>
            <remarks>No bounds checks are made.</remarks>
        </member>
        <member name="M:Claron.WIF.Histogram2DInt32.RemoveSample(System.Int32,System.Int32)">
            <summary>
            Removes a sample.
            </summary>
            <param name="x">The x variable value.</param>
            <param name="y">The y variable value.</param>
            <remarks>If the sample is out of bounds an exception is thrown.
            </remarks>
        </member>
        <member name="M:Claron.WIF.Histogram2DInt32.DecBin(System.Int32,System.Int32)">
            <summary>
            Decreases a bin sample value by 1.
            </summary>
            <param name="i">The x variable value.</param>
            <param name="j">The y variable value.</param>
            <remarks>No bounds checks are made.</remarks>
        </member>
        <member name="M:Claron.WIF.Histogram2DInt32.Reset">
            <summary>
            Resets the histogram 2D bin samples to 0.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Histogram2DInt32.BinVal(System.Int32,System.Int32)">
            <summary>
            Returns the x and y variable values corresponding to a pair of bin
            indices.
            </summary>
            <param name="i">The x variable bin index.</param>
            <param name="j">The y variable bin index.</param>
            <returns>The x and y variable values are returned in a 1D array.
            </returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Histogram2DInt32.NumberOfSamplesInBin(System.Int32,System.Int32)">
            <summary>
            Returns the number of samples in a bin.
            </summary>
            <param name="i">The x variable bin index.</param>
            <param name="j">The y variable bin index.</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Histogram2DInt32.GetHashCode">
            <summary>
            Returns the hash code for the 2D histogram.
            </summary>
        </member>
        <member name="P:Claron.WIF.Histogram2DInt32.MinX">
            <summary>
            The minimum value in the x variable.
            </summary>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Histogram2DInt32.MaxX">
            <summary>
            The maximum value in the x variable.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Histogram2DInt32.nBinsX">
            <summary>
            Property to get the number of bins for the x variable.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Histogram2DInt32.MinY">
            <summary>
            The minimum value in the y variable.
            </summary>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Histogram2DInt32.MaxY">
            <summary>
            The maximum value in the y variable.
            </summary>
        </member>
        <member name="P:Claron.WIF.Histogram2DInt32.nBinsY">
            <summary>
            Property to get the number of bins for the y variable.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Histogram2DInt32.Samples">
            <summary>
            Property for retrieving the samples in each bin.
            </summary>
            <value></value>
            <returns>A 2D array storing the number of samples in each bin.</returns>
            <remarks>The first index corresponds to the y variable and the
            second index to the x variable.</remarks>
        </member>
        <member name="P:Claron.WIF.Histogram2DInt32.XBinIndices">
            <summary>
            Returns the x-bin indices.
            </summary>
        </member>
        <member name="P:Claron.WIF.Histogram2DInt32.YBinIndices">
            <summary>
            Returns the y-bin indices.
            </summary>
        </member>
        <member name="P:Claron.WIF.Histogram2DInt32.TotalNumberOfSamples">
            <summary>
            Returns the total number of samples in the histogram.
            </summary>
            <value></value>
            <returns>The total number of samples in the histogram.</returns>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.ParzenWindowProbabilityDensityFunction1D">
            <summary>
            Class for estimating the probability density function of a random variable using Parzen
            windowing.
            </summary>
        </member>
        <member name="F:Claron.WIF.ParzenWindowProbabilityDensityFunction1D._h">
            <summary>
            The width of the Gaussian kernel used for smoothing.
            </summary>
        </member>
        <member name="F:Claron.WIF.ParzenWindowProbabilityDensityFunction1D._samplesList">
            <summary>
            The samples list.
            </summary>
        </member>
        <member name="M:Claron.WIF.ParzenWindowProbabilityDensityFunction1D.#ctor(System.Double)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="h">The width of the Gaussian kernel used for smoothing.</param>
        </member>
        <member name="M:Claron.WIF.ParzenWindowProbabilityDensityFunction1D.AddSample(System.Double)">
            <summary>
            Adds a new sample.
            </summary>
            <param name="val">The sample to add.</param>
        </member>
        <member name="M:Claron.WIF.ParzenWindowProbabilityDensityFunction1D.Clear">
            <summary>
            Clears the samples.
            </summary>
        </member>
        <member name="M:Claron.WIF.ParzenWindowProbabilityDensityFunction1D.ProbabilityDensity(System.Double)">
            <summary>
            Returns an estimate of the probability density at the given value.
            </summary>
            <param name="x">The value to estimate the probability density at.</param>
        </member>
        <member name="T:Claron.WIF.SimilarityMeasureTypeEnum">
            <summary>
            The similarity metric type.
            </summary>
        </member>
        <member name="T:Claron.WIF.ISimilarityMetric">
            <summary>
            Interface for similarity metric classes.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ISimilarityMetric.AddSample(System.Double,System.Double)">
            <summary>
            Adds a sample value.
            </summary>
            <param name="vf">The fixed intensity value.</param>
            <param name="vm">The moving intensity value.</param>
        </member>
        <member name="M:Claron.WIF.ISimilarityMetric.AddSample(System.Int32,System.Int32)">
            <summary>
            Adds a sample value.
            </summary>
            <param name="vf">The fixed intensity value.</param>
            <param name="vm">The moving intensity value.</param>
        </member>
        <member name="M:Claron.WIF.ISimilarityMetric.RemoveSample(System.Int32,System.Int32)">
            <summary>
            Removes a sample value.
            </summary>
            <param name="x">The fixed intensity value.</param>
            <param name="y">The moving intensity value.</param>
        </member>
        <member name="M:Claron.WIF.ISimilarityMetric.TotalNumberOfSamples">
            <summary>
            Returns the number of samples taken.
            </summary>
        </member>
        <member name="M:Claron.WIF.ISimilarityMetric.Reset">
            <summary>
            Resets the similarity metric.
            </summary>
        </member>
        <member name="M:Claron.WIF.ISimilarityMetric.Add(Claron.WIF.ISimilarityMetric)">
            <summary>
            Adds the metric values in the given metric to this metric.
            </summary>
        </member>
        <member name="M:Claron.WIF.ISimilarityMetric.Evaluate">
            <summary>
            Evaluates the similarity metric.
            </summary>
        </member>
        <member name="M:Claron.WIF.ISimilarityMetric.Clone">
            <summary>
            Clones the similarity metric.
            </summary>
        </member>
        <member name="M:Claron.WIF.ISimilarityMetric.CloneZero">
            <summary>
            Clones the similarity metric with the samples set to zero.
            </summary>
        </member>
        <member name="P:Claron.WIF.ISimilarityMetric.SimilarityMeasure">
            <summary>
            Property for setting the type of the similarity metric.
            </summary>
        </member>
        <member name="T:Claron.WIF.SimilarityMetricHistogramInt32">
            <summary>
            Similarity metric for images which uses 2D histograms to compute the similarity values.
            </summary>
            <remarks>Uses a Histogram2D object to store sample values.</remarks>
        </member>
        <member name="F:Claron.WIF.SimilarityMetricHistogramInt32._similarityMetricType">
            <summary>
            The similarity measure type.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.SimilarityMetricHistogramInt32._histogram2DInt32">
            <summary>
            The 2D histogram object.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricHistogramInt32.TotalNumberOfSamples">
            <summary>
            Returns the total number of samples.
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricHistogramInt32.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new histogram based similarity metric.
            </summary>
            <param name="minX">The minimum value in the x variable.</param>
            <param name="maxX">The maximum value in the x variable.</param>
            <param name="nBinsX">The number of bins in the x range.</param>
            <param name="minY">The minimum value in the y variable.</param>
            <param name="maxY">The maximum value in the y variable.</param>
            <param name="nBinsY">The number of bins in the y range.</param>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricHistogramInt32.#ctor">
            <summary>
            Creates a new histogram similarity metric.
            </summary>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricHistogramInt32.Clone">
            <summary>
            Clones the similarity metric.
            </summary>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricHistogramInt32.CloneZero">
            <summary>
            Clones the similarity metric.
            </summary>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricHistogramInt32.AddSample(System.Double,System.Double)">
            <summary>
            Adds a new sample.
            </summary>
            <param name="vf">The x variable value.</param>
            <param name="vm">The y variable value.</param>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricHistogramInt32.AddSample(System.Int32,System.Int32)">
            <summary>
            Adds a new sample.
            </summary>
            <param name="vf">The x variable value.</param>
            <param name="vm">The y variable value.</param>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricHistogramInt32.Add(Claron.WIF.ISimilarityMetric)">
            <summary>
            Adds the metric values in the given metric to this metric.
            </summary>
            <param name="metric">The metric whose sample values are to be added
            to this metric.</param>
            <remarks>No checks are made to ensure that the metric which is passed
            into the function has an histogram with the same dimensions as the
            histogram in this metric.</remarks>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricHistogramInt32.RemoveSample(System.Int32,System.Int32)">
            <summary>
            Removes a sample.
            </summary>
            <param name="x">The x variable value.</param>
            <param name="y">The y variable value.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricHistogramInt32.Reset">
            <summary>
            Resets the histogram metric samples to 0.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricHistogramInt32.Evaluate">
            <summary>
            Evaluates the similarity measure.
            </summary>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricHistogramInt32.SumOfAbsoluteDifferences">
            <summary>
            Returns the negative of the sum of absolute differences for the sample values
            for the two variables stored in the histogram.
            </summary>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricHistogramInt32.SumOfSquaredDifferences">
            <summary>
            Returns the negative of the sum of squared differences for the sample
            values for the two variables stored in the histogram.
            </summary>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricHistogramInt32.MutualInformation">
            <summary>
            Returns the mutual information between the two variables.
            </summary>
            <returns>The mutual information between the two variables.</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricHistogramInt32.NormalizedMutualInformation">
            <summary>
            Returns the normalized mutual information between the two variables.
            </summary>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricHistogramInt32.GetHashCode">
            <summary>
            Returns the hash code for this SimilarityMetricHistogramInt32
            object.
            </summary>
        </member>
        <member name="P:Claron.WIF.SimilarityMetricHistogramInt32.Histogram2DInt32">
            <summary>
            Property to get the 2D histogram.
            </summary>
            <value></value>
            <returns>The 2D histogram.</returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.SimilarityMetricHistogramInt32.SimilarityMeasure">
            <summary>
            Sets the similarity metric type.
            </summary>
        </member>
        <member name="T:Claron.WIF.SimilarityMetricHistogramInt32WithGradients">
            <summary>
            Similarity metric for images which use 2D histograms and gradient values in the images 
            to compute the similarity values.
            </summary>
            <remarks>Uses a Histogram2D object to store sample values.</remarks>
        </member>
        <member name="F:Claron.WIF.SimilarityMetricHistogramInt32WithGradients._gf">
            <summary>
            The scaling factor due to the gradients in the images.
            </summary>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricHistogramInt32WithGradients.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new histogram based similarity metric.
            </summary>
            <param name="minX">The minimum value in the x variable.</param>
            <param name="maxX">The maximum value in the x variable.</param>
            <param name="nBinsX">The number of bins in the x range.</param>
            <param name="minY">The minimum value in the y variable.</param>
            <param name="maxY">The maximum value in the y variable.</param>
            <param name="nBinsY">The number of bins in the y range.</param>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricHistogramInt32WithGradients.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricHistogramInt32WithGradients.Clone">
            <summary>
            Clones the similarity metric.
            </summary>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricHistogramInt32WithGradients.CloneZero">
            <summary>
            Clones the similarity metric.
            </summary>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricHistogramInt32WithGradients.AddSample(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Adds a new sample.
            </summary>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricHistogramInt32WithGradients.AddSample(System.Int32,System.Double,System.Double,System.Double,System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            Adds a new sample.
            </summary>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricHistogramInt32WithGradients.GradientContribution(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Calculates the gradient contribution for the given set of gradient components.
            </summary>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricHistogramInt32WithGradients.Add(Claron.WIF.ISimilarityMetric)">
            <summary>
            Adds the metric values in the given metric to this metric.
            </summary>
            <param name="metric">The metric whose sample values are to be added
            to this metric.</param>
            <remarks>No checks are made to ensure that the metric which is passed
            into the function has an histogram with the same dimensions as the
            histogram in this metric.</remarks>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricHistogramInt32WithGradients.RemoveSample(System.Int32,System.Double,System.Double,System.Double,System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            Removes a sample.
            </summary>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricHistogramInt32WithGradients.Reset">
            <summary>
            Resets the histogram metric samples to 0.
            </summary>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricHistogramInt32WithGradients.Evaluate">
            <summary>
            Evaluates the similarity measure.
            </summary>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricHistogramInt32WithGradients.GetHashCode">
            <summary>
            Returns the hash code for this SimilarityMetricHistogramInt32
            object.
            </summary>
        </member>
        <member name="T:Claron.WIF.SimilarityMetricIntensityDifference">
            <summary>
            Similarity metric based on measurement of intensity differences.
            </summary>
        </member>
        <member name="F:Claron.WIF.SimilarityMetricIntensityDifference._similarityMeasure">
            <summary>
            The similarity type.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.SimilarityMetricIntensityDifference._value">
            <summary>
            The total similarity value.
            </summary>
        </member>
        <member name="F:Claron.WIF.SimilarityMetricIntensityDifference._nSamples">
            <summary>
            The number of samples.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricIntensityDifference.AddSample(System.Double,System.Double)">
            <summary>
            Adds a sample value.
            </summary>
            <param name="vf">The fixed image intensity.</param>
            <param name="vm">The moving image intensity.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricIntensityDifference.AddSample(System.Int32,System.Int32)">
            <summary>
            Adds a sample value.
            </summary>
            <param name="x">The fixed image intensity.</param>
            <param name="y">The moving image intensity.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricIntensityDifference.RemoveSample(System.Int32,System.Int32)">
            <summary>
            Removes a sample value.
            </summary>
            <param name="x">The fixed image intensity.</param>
            <param name="y">The moving image intensity.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricIntensityDifference.Add(Claron.WIF.ISimilarityMetric)">
            <summary>
            Adds the similarity metric values in the given metric to this metric.
            </summary>
            <param name="metric">The similarity metric to add.</param>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricIntensityDifference.Reset">
            <summary>
            Resets the similarity measure.
            </summary>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricIntensityDifference.Evaluate">
            <summary>
            Evaluates the similarity measure.
            </summary>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricIntensityDifference.Clone">
            <summary>
            Clones the similarity metric.
            </summary>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricIntensityDifference.CloneZero">
            <summary>
            Clones with the samples set to zero.
            </summary>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricIntensityDifference.TotalNumberOfSamples">
            <summary>
            Returns the total number of samples.
            </summary>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricIntensityDifference.GetHashCode">
            <summary>
            Returns the hash code for this SimilarityMetricIntensityDifference
            object.
            </summary>
        </member>
        <member name="P:Claron.WIF.SimilarityMetricIntensityDifference.Value">
            <summary>
            The total similarity value.
            </summary>
        </member>
        <member name="P:Claron.WIF.SimilarityMetricIntensityDifference.nSamples">
            <summary>
            The number of samples.
            </summary>
        </member>
        <member name="P:Claron.WIF.SimilarityMetricIntensityDifference.SimilarityMeasure">
            <summary>
            Property for getting/setting the similarity metric type.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.SimilarityMetricIntensityDifferenceWithGradients">
            <summary>
            Similarity metric based on measurement of intensity differences.
            </summary>
        </member>
        <member name="F:Claron.WIF.SimilarityMetricIntensityDifferenceWithGradients._gf">
            <summary>
            The scaling factor due to the gradients in the images.
            </summary>
        </member>
        <member name="F:Claron.WIF.SimilarityMetricIntensityDifferenceWithGradients._similarityMeasure">
            <summary>
            The similarity type.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.SimilarityMetricIntensityDifferenceWithGradients._value">
            <summary>
            The total similarity value.
            </summary>
        </member>
        <member name="F:Claron.WIF.SimilarityMetricIntensityDifferenceWithGradients._nSamples">
            <summary>
            The number of samples.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricIntensityDifferenceWithGradients.AddSample(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Adds a sample value with gradient contribution.
            </summary>
            <param name="vf">The fixed image intensity.</param>
            <param name="gfx">Gradient at fixed image sample, x component</param>
            <param name="gfy">Gradient at fixed image sample, y component</param>
            <param name="gfz">Gradient at fixed image sample, z component</param>
            <param name="vm">The moving image intensity.</param>
            <param name="gmx">Gradient at moving image sample, x component</param>
            <param name="gmy">Gradient at moving image sample, y component</param>
            <param name="gmz">Gradient at moving image sample, z component</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricIntensityDifferenceWithGradients.AddSample(System.Int32,System.Double,System.Double,System.Double,System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            Adds a sample value with gradient contribution.
            </summary>
            <param name="vf">The fixed image intensity.</param>
            <param name="gfx">Gradient at fixed image sample, x component</param>
            <param name="gfy">Gradient at fixed image sample, y component</param>
            <param name="gfz">Gradient at fixed image sample, z component</param>
            <param name="vm">The moving image intensity.</param>
            <param name="gmx">Gradient at moving image sample, x component</param>
            <param name="gmy">Gradient at moving image sample, y component</param>
            <param name="gmz">Gradient at moving image sample, z component</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricIntensityDifferenceWithGradients.GradientContribution(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Calculates the gradient contribution for the given set of gradient components.
            </summary>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricIntensityDifferenceWithGradients.RemoveSample(System.Int32,System.Double,System.Double,System.Double,System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            Removes a sample value with gradient contribution.
            </summary>
            <param name="vf">The fixed image intensity.</param>
            <param name="gfx">Gradient at fixed image sample, x component</param>
            <param name="gfy">Gradient at fixed image sample, y component</param>
            <param name="gfz">Gradient at fixed image sample, z component</param>
            <param name="vm">The moving image intensity.</param>
            <param name="gmx">Gradient at moving image sample, x component</param>
            <param name="gmy">Gradient at moving image sample, y component</param>
            <param name="gmz">Gradient at moving image sample, z component</param>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricIntensityDifferenceWithGradients.Add(Claron.WIF.ISimilarityMetric)">
            <summary>
            Adds the similarity metric values in the given metric to this metric.
            </summary>
            <param name="metric">The similarity metric to add.</param>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricIntensityDifferenceWithGradients.Reset">
            <summary>
            Resets the similarity measure.
            </summary>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricIntensityDifferenceWithGradients.Evaluate">
            <summary>
            Evaluates the similarity measure.
            </summary>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricIntensityDifferenceWithGradients.Clone">
            <summary>
            Clones the similarity metric.
            </summary>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricIntensityDifferenceWithGradients.CloneZero">
            <summary>
            Clones with the samples set to zero.
            </summary>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricIntensityDifferenceWithGradients.TotalNumberOfSamples">
            <summary>
            Returns the total number of samples.
            </summary>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricIntensityDifferenceWithGradients.GetHashCode">
            <summary>
            Returns the hash code for this SimilarityMetricIntensityDifference
            object.
            </summary>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricIntensityDifferenceWithGradients.AddSample(System.Double,System.Double)">
            <summary>
            Adds a sample value.
            </summary>
            <param name="vf">The fixed intensity value.</param>
            <param name="vm">The moving intensity value.</param>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricIntensityDifferenceWithGradients.AddSample(System.Int32,System.Int32)">
            <summary>
            Adds a sample value.
            </summary>
            <param name="vf">The fixed intensity value.</param>
            <param name="vm">The moving intensity value.</param>
        </member>
        <member name="M:Claron.WIF.SimilarityMetricIntensityDifferenceWithGradients.RemoveSample(System.Int32,System.Int32)">
            <summary>
            Removes a sample value.
            </summary>
            <param name="x">The fixed intensity value.</param>
            <param name="y">The moving intensity value.</param>
        </member>
        <member name="P:Claron.WIF.SimilarityMetricIntensityDifferenceWithGradients.Value">
            <summary>
            The total similarity value.
            </summary>
        </member>
        <member name="P:Claron.WIF.SimilarityMetricIntensityDifferenceWithGradients.nSamples">
            <summary>
            The number of samples.
            </summary>
        </member>
        <member name="P:Claron.WIF.SimilarityMetricIntensityDifferenceWithGradients.SimilarityMeasure">
            <summary>
            Property for getting/setting the similarity metric type.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.Image4Vu">
            <summary>
            Image4Vu represents a group of four ImageVU objects generated by mutually orthogonal views of
            the contents of a data volume (front, back, left, right).
            The class is mainly used in registering a volume (SliceStack objects) to an Image4Vu atlas
            to which manually-drawn curves were added. Following the registration, the curves are copied
            from the atlas to the Image4Vu being registered. The curves can subsequently be used to
            apply cookie-cuts from multiple directions to isolate an anatomical region for further
            processing.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Image4Vu._views">
            <summary>
            The 4-view images in the order front, back, left, and right.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Image4Vu._curves">
            <summary>
            The curves associated with each of the four views.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Image4Vu.ViewGet(Claron.WIF.Image4Vu.ViewSideEnum)">
            <summary>
            Returns the image corresponding to the given view direction.
            </summary>
        </member>
        <member name="M:Claron.WIF.Image4Vu.#ctor(Claron.WIF.ImageVu[],System.Collections.Generic.Dictionary{System.String,Claron.WIF.Curve}[])">
            <summary>
            Creates a new 4-view image from the given set of images.
            </summary>
            <param name="views"></param>
            <param name="curves"> Default value = null </param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Image4Vu.#ctor">
            <summary>
            Creates a new empty 4-view image.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Image4Vu.Read(System.String)">
            <summary>
            Reads a 4-view image.
            1. If application has IAngioLib.dll in its run directory - just load atlas from DLL.
            2. If application doesn't have IAngioLib.dll in its run directory then searches for Atlases
            directory starting from run directory and traversing upwards in folder hierarchy. When folder
            is found atlas is loaded from that directory. If Atlases directory is not found then an
            exception is thrown.
            </summary>
            <param name="name">The name of the atlas to load.</param>
        </member>
        <member name="M:Claron.WIF.Image4Vu.Read(System.String,System.Boolean)">
            <summary>
            Reads a 4-view image.
            1. If application has IAngioLib.dll in its run directory - just load atlas from DLL.
            2. If application doesn't have IAngioLib.dll in its run directory then searches for Atlases
            directory starting from run directory and traversing upwards in folder hierarchy. When folder
            is found atlas is loaded from that directory. If Atlases directory is not found then an
            exception is thrown.
            </summary>
            <param name="name">The name of the atlas to load.</param>
            <param name="forceReadFromFile"></param>
        </member>
        <member name="M:Claron.WIF.Image4Vu.DeserializeFromStream(System.IO.Stream)">
            <summary>
            Loads a vu image from a stream.
            </summary>
            <param name="stream"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Image4Vu.Write(System.String)">
            <summary>
            Writes the 4 view image.
            </summary>
            <param name="filePath">The file path to store the 4-view image in.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Image4Vu.Write(System.String,System.Boolean)">
             <summary>
             Writes the 4 view image.
             </summary>
             <param name="filePath">The file name to store the 4-view image in.
             </param>
             <param name="compress">Whether to compress the file using gzip. A .gz file name extension is recommended when
             compression is used.</param>
             <remarks>The file format is as follows:
            
             * The first 8 bytes are the string "Image4Vu".
             * This is followed by a table of 128 entries giving information about
               whether optional data appears at the end of the file after the
               image data itself. The table is made up of two columns, a string
               identifying the type of data, and whether it is present at the end of
               the file.
             * The 4-view images appear next.
             * The optional data at the end.
             </remarks>
        </member>
        <member name="M:Claron.WIF.Image4Vu.ToBitmap">
            <summary>
            Converts the image to a bitmap image.
            </summary>
        </member>
        <member name="M:Claron.WIF.Image4Vu.Clone">
            <summary>
            Returns a clone of this 4 view image.
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Image4Vu.RedimYMm(System.Int32,System.Int32)">
            <summary>
            Re-dimensions all the views to include only the range of lines specified.
            </summary>
            <param name="yMinMm">The y-min position in mm.</param>
            <param name="yMaxMm">The y-max position in mm.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Image4Vu.RedimY(System.Int32,System.Int32)">
            <summary>
            Re-dimensions all the views to include only the range of lines specified
            </summary>
            <param name="yMinI">The index of first line to preserve</param>
            <param name="yMaxI">The index of the last line to preserve</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Image4Vu.AddMarginsMm(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Re-dimensions the image with margins around its current periphery
            </summary>
            <param name="OnLeft">MM margin on the left (below current x=0)</param>
            <param name="OnRight"></param>
            <param name="OnTop"></param>
            <param name="OnBottom"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Image4Vu.SetMipBackgroundPixelsToZero">
            <summary>
            Sets the MIP values in the image to zero if they are background pixels. Uses depth data to
            determine which pixels are in background.
            </summary>
        </member>
        <member name="M:Claron.WIF.Image4Vu.MirrorMeY">
            <summary>
            Mirrors the image in the y-axis.
            </summary>
        </member>
        <member name="M:Claron.WIF.Image4Vu.AverageDown(System.Int32,System.Int32)">
            <summary>
            Averages down the image based on the pixel size scaling factor.
            </summary>
            <param name="sxf">The scaling factor in the x-direction.</param>
            <param name="syf">The scaling factor in the y-direction.</param>
        </member>
        <member name="M:Claron.WIF.Image4Vu.GetHashCode">
            <summary>
            Returns the hash code for the image vu object.
            </summary>
        </member>
        <member name="P:Claron.WIF.Image4Vu.Front">
            <summary>
            Returns the front view image.
            </summary>
        </member>
        <member name="P:Claron.WIF.Image4Vu.Back">
            <summary>
            Returns the back view image.
            </summary>
        </member>
        <member name="P:Claron.WIF.Image4Vu.Left">
            <summary>
            Returns the left view image.
            </summary>
        </member>
        <member name="P:Claron.WIF.Image4Vu.Right">
            <summary>
            Returns the right view image.
            </summary>
        </member>
        <member name="P:Claron.WIF.Image4Vu.Views">
            <summary>
            Returns all 4 views.
            </summary>
        </member>
        <member name="P:Claron.WIF.Image4Vu.HasEmptyView">
            <summary>
            Returns true if one of the views is empty.
            </summary>
        </member>
        <member name="P:Claron.WIF.Image4Vu.IsEmpty">
            <summary>
            Returns true if all of the views are empty images.
            </summary>
        </member>
        <member name="P:Claron.WIF.Image4Vu.Curves">
            <summary>
            Returns the curves defined in the 4-view image for the 4 views.
            The index order is per ViewSide. Never returns Nothing.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.Image4Vu.ViewSideEnum">
            <summary>
            The indexes of the view sides.
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.ImageVu">
            <summary>
            A Vu image represents a 2D projection of a 3D volume of data to a surface,
            generated by a Camera object in an iso-surface rendering mode. Each 2D location
            stores the depth (distance from the projection plane) and the 3D surface normal
            transformed to the projection direction.
            The class was designed for use in speeding up the registration of two 3D volumes using
            one or more 2D projections of their contents.
            </summary>
        </member>
        <member name="F:Claron.WIF.ImageVu._nx">
            <summary>
            The number of pixels in the x-direction.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.ImageVu._ny">
            <summary>
            The number of pixels in the y-direction.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.ImageVu._sx">
            <summary>
            The spacing of pixels in the x-direction.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.ImageVu._sy">
            <summary>
            The spacing of pixels in the y-direction.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.ImageVu._origin">
            <summary>
            The location of pixel with index (0, 0).
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.ImageVu._mmZ">
            <summary>
            The ratio between mm and depth values (i.e., mm per depth unit).
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.ImageVu._maxD">
            <summary>
            The maximum depth value.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.ImageVu._matrix">
            <summary>
            The 4 x 4 matrix which maps positions in the image to the coordinate
            system of the 3D slice stack.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.ImageVu._imatrix">
            <summary>
            The inverse of the above transformation matrix.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.ImageVu._ddata">
            <summary>
            Image data which stores depth to voxel with specified HU unit.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.ImageVu._xdata">
            <summary>
            x-component of normal data.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.ImageVu._ydata">
            <summary>
            y-component of normal data.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.ImageVu._zdata">
            <summary>
            z-component of normal data.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.ImageVu._mipData">
            <summary>
            The MIP data.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVu.#ctor(System.Int32,System.Int32,System.Double,System.Double,System.Double,System.Double[])">
            <summary>
            Creates a new VU image.
            </summary>
            <param name="nx">The number of pixels in the x-direction.</param>
            <param name="ny">The number of pixels in the y-direction.</param>
            <param name="sx">The spacing of pixels in the x-direction.</param>
            <param name="sy">The spacing of pixels in the y-direction.</param>
            <param name="mmZ">The ratio between mm and depth values (i.e., mm
            per depth unit).</param>
            <param name="matrix">The 4 x 4 matrix which maps positions in the image
            to the coordinate system of the 3D slice stack.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVu.#ctor(System.Int32,System.Int32,System.Double,System.Double,System.Double,System.Double[],System.Single[])">
            <summary>
            Creates a new VU image.
            </summary>
            <param name="nx">The number of pixels in the x-direction.</param>
            <param name="ny">The number of pixels in the y-direction.</param>
            <param name="sx">The spacing of pixels in the x-direction.</param>
            <param name="sy">The spacing of pixels in the y-direction.</param>
            <param name="mmZ">The ratio between mm and depth values (i.e., mm
            per depth unit).</param>
            <param name="matrix">The 4 x 4 matrix which maps positions in the image
            to the coordinate system of the 3D slice stack.</param>
            <param name="isoSurface">The depth and normal data.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVu.#ctor">
            <summary>
            Creates a new empty Vu image.
            </summary>
            <remarks>Needed for Clone() function.</remarks>
        </member>
        <member name="M:Claron.WIF.ImageVu.GetHashCode">
            <summary>
            Returns hash code for ImageVu objects.
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageVu.SetMipData(Claron.WIF.ImageU12)">
            <summary>
            Sets the MIP data for the 4-view image image assuming that the given CT image contains enough
            values to fill in the MIP data array.
            </summary>
            <param name="ImageU12">The CT image from which to copy the MIP values.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVu.SetMipBackgroundPixelsToZero">
            <summary>
            Sets the MIP values in the image to zero if they are background pixels. Uses depth data to
            determine which pixels are in background.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVu.ToBitmap">
            <summary>
            Converts the image to a a bitmap image.
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageVu.Clone">
            <summary>
            Returns a clone of this 4-view image.
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVu.RedimYMm(System.Double,System.Double)">
            <summary>
            Re-dimensions the image to include only the range of lines specified.
            </summary>
            <param name="yMinMm">The position of the first line to preserve.</param>
            <param name="yMaxMm">The position of the second line to preserve.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVu.RedimY(System.Int32,System.Int32)">
            <summary>
            Re-dimensions the image to include only the range of lines specified.
            </summary>
            <param name="yMinI">The index of first line to preserve</param>
            <param name="yMaxI">The index of the last line to preserve</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVu.AddMarginsMm(System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>
            Re-dimensions the image with margins around its current periphery.
            </summary>
            <param name="OnLeft">MM margin on the left (below current x=0). May be modified slightly on return
            to accommodate round off errors.</param>
            <param name="OnTop"></param>
            <param name="OnRight"></param>
            <param name="OnBottom"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVu.InterpolateNND(System.Double,System.Double)">
            <summary>
            Interpolates at the specified point using NN interpolation.
            </summary>
            <param name="x">The x-coordinate of the point to do the interpolation
            at.</param>
            <param name="y">The y-coordinate of the point to do the interpolation
            at.</param>
            <returns>The interpolated depth value.</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVu.InterpolateNNX(System.Double,System.Double)">
            <summary>
            Interpolates at the specified point using NN interpolation.
            </summary>
            <param name="x">The x-coordinate of the point to do the interpolation
            at.</param>
            <param name="y">The y-coordinate of the point to do the interpolation
            at.</param>
            <returns>The interpolated x-component of the normal.</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVu.InterpolateNNY(System.Double,System.Double)">
            <summary>
            Interpolates at the specified point using NN interpolation.
            </summary>
            <param name="x">The x-coordinate of the point to do the interpolation
            at.</param>
            <param name="y">The y-coordinate of the point to do the interpolation
            at.</param>
            <returns>The interpolated y-component of the normal.</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVu.InterpolateNNZ(System.Double,System.Double)">
            <summary>
            Interpolates at the specified point using NN interpolation.
            </summary>
            <param name="x">The x-coordinate of the point to do the interpolation
            at.</param>
            <param name="y">The y-coordinate of the point to do the interpolation
            at.</param>
            <returns>The interpolated z-component of the normal.</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVu.InterpolateNNMip(System.Double,System.Double)">
            <summary>
            Interpolates at the specified point using NN interpolation.
            </summary>
            <param name="x">The x-coordinate of the point to do the interpolation
            at.</param>
            <param name="y">The y-coordinate of the point to do the interpolation
            at.</param>
            <returns>The interpolated MIP component.</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVu.InterpolateNN(System.Double,System.Double,System.Single[])">
            <summary>
            Interpolates the given data which must have the same size as the image.
            No bounds checks are made.
            </summary>
            <param name="x">The x-coordinate of the point to do the interpolation
            at.</param>
            <param name="y">The y-coordinate of the point to do the interpolation
            at.</param>
            <param name="data">The data to interpolate.</param>
            <returns>The NN interpolated value.</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVu.InterpolateLinearD(System.Double,System.Double)">
            <summary>
            Interpolates at the specified point using linear interpolation, ignoring inputs with negative depth.
            </summary>
            <param name="x">The x-coordinate of the point to do the interpolation
            at.</param>
            <param name="y">The y-coordinate of the point to do the interpolation
            at.</param>
            <returns>The interpolated depth value. To get the depth value in mm
            multiply the resultant value by the property MmZ.
            If the point is background, then -1 is returned
            </returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVu.InterpolateLinearX(System.Double,System.Double)">
            <summary>
            Interpolates at the specified point using linear interpolation.
            </summary>
            <param name="x">The x-coordinate of the point to do the interpolation
            at.</param>
            <param name="y">The y-coordinate of the point to do the interpolation
            at.</param>
            <returns>The interpolated x-component of the normal, or -1 if background.</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVu.InterpolateLinearY(System.Double,System.Double)">
            <summary>
            Interpolates at the specified point using linear interpolation.
            </summary>
            <param name="x">The x-coordinate of the point to do the interpolation
            at.</param>
            <param name="y">The y-coordinate of the point to do the interpolation
            at.</param>
            <returns>The interpolated y-component of the normal, or -1 if background.</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVu.InterpolateLinearZ(System.Double,System.Double)">
            <summary>
            Interpolates at the specified point using linear interpolation.
            </summary>
            <param name="x">The x-coordinate of the point to do the interpolation
            at.</param>
            <param name="y">The y-coordinate of the point to do the interpolation
            at.</param>
            <returns>The interpolated z-component of the normal, or -1 if background.</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVu.InterpolateLinearMip(System.Double,System.Double)">
            <summary>
            Interpolates at the specified point using linear interpolation.
            </summary>
            <param name="x">The x-coordinate of the point to do the interpolation
            at.</param>
            <param name="y">The y-coordinate of the point to do the interpolation
            at.</param>
            <returns>The interpolated MIP component, or -1 if background.</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVu.GetLinearInterpolationWeights(System.Double,System.Double,System.Int32@,System.Int32@,System.Double[])">
            <summary>
            Returns the linear interpolation weights for the specified point in
            image coordinates.
            </summary>
            <param name="x">The x-coordinate of the point to do the interpolation
            at.</param>
            <param name="y">The y-coordinate of the point to do the interpolation
            at.</param>
            <param name="i">The x-coordinate floored.</param>
            <param name="j">The y-coordinate floored.</param>
            <param name="w">The 4 element array to return the weights in.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVu.InterpolateLinear(System.Double,System.Double,System.Single[])">
            <summary>
            Interpolates the given data which must have the same size as the image
            at the specified point.
            </summary>
            <param name="x">The x-coordinate of the point to do the interpolation
            at.</param>
            <param name="y">The y-coordinate of the point to do the interpolation
            at.</param>
            <param name="data"></param>
            <returns>The interpolated z-component of the normal, or -1 if background.</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVu.ComputeGradientValues(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Calculates the gradient image. Note that the values returned in the arrays must be divided by
            2 * sx (or 2 * sy) to get the true gradient in the x-direction (or y direction).
            </summary>
            <param name="calcDepthImage">Whether to calculate the depth gradient values. Default value = True</param>
            <param name="calcNxImage">Whether to calculate the nx gradient values. Default value = True</param>
            <param name="calcNyImage">Whether to calculate the ny gradient values. Default value = True</param>
            <param name="calcNzImage">Whether to calculate the nz gradient values. Default value = True</param>
            <param name="calcMipImage"> Default value = True</param>
            <returns>Returns an array of Array2D objects containing the gradient values in the order
            depth_x, depth_y, nx_x, nx_y, ny_x, ny_y, nz_x, nz_y. Nothing is returned for those components
            whose gradient values are not to be calculated.</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVu.ComputeGradientValuesX(System.Single[])">
            <summary>
            Calculates the x-component of the gradient image for the given values.
            </summary>
            <param name="vals"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVu.ComputeGradientValuesY(System.Single[])">
            <summary>
            Calculates the y-component of the gradient image for the given values.
            </summary>
            <param name="vals"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVu.ImageToReference(System.Double@,System.Double@,System.Double@)">
            <summary>
            Converts from image space to reference coordinate space.
            </summary>
            <param name="x">The x-coordinate of the pixel in image space.</param>
            <param name="y">The y-coordinate of the pixel in image space.</param>
            <param name="z">The z-coordinate is used as an output parameter and
            is calculated by transforming the depth value at the (x, y) position in
            image space.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVu.ReferenceToImage(System.Double@,System.Double@,System.Double@)">
            <summary>
            Converts from reference coordinate space to image space.
            </summary>
            <param name="x">The x-coordinate in reference space.</param>
            <param name="y">The y-coordinate in reference space.</param>
            <param name="z">The z-coordinate in reference space.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVu.ReferenceToPhysical(System.Double@,System.Double@,System.Double@)">
            <summary>
            Converts from reference coordinate space to physical image space (ie, in mm dimensions).
            </summary>
            <param name="x">The x-coordinate in reference space.</param>
            <param name="y">The y-coordinate in reference space.</param>
            <param name="z">The z-coordinate in reference space.</param>
        </member>
        <member name="M:Claron.WIF.ImageVu.ImageToPhysical(System.Double@,System.Double@)">
            <summary>
            Converts from image to physical coordinates.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVu.PhysicalToImage(System.Double@,System.Double@)">
            <summary>
            Converts from physical to image coordinates.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVu.ResampleImage(System.Int32,System.Int32)">
            <summary>
            Resamples the image so that it has the given size.
            </summary>
            <param name="nx">The number of pixels in the x-direction.</param>
            <param name="ny">The number of pixels in the y-direction.</param>
            <remarks>Uses linear interpolation to do the resampling.</remarks>
        </member>
        <member name="M:Claron.WIF.ImageVu.AverageDown(System.Int32,System.Int32)">
            <summary>
            Averages down the image based on the pixel size scaling factor.
            </summary>
            <param name="sxf">The scaling factor in the x-direction.</param>
            <param name="syf">The scaling factor in the y-direction.</param>
        </member>
        <member name="M:Claron.WIF.ImageVu.CalculateCentroid(System.Double@,System.Double@)">
            <summary>
            Calculates the centroid of the image in physical coordinates.
            </summary>
            <param name="x">The x-coordinate of the centroid.</param>
            <param name="y">The y-coordinate of the centroid.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVu.CalculatePrincipalAxes(Claron.WIF.VectorN[]@,System.Double[]@,System.Double[]@,System.Double,System.Double)">
            <summary>
            Calculates the principal axes of inertia of the image. Useful for registering kidney images to each other
            by calculating the initial global transformation needed.
            </summary>
            <param name="axes">The principal axes.</param>
            <param name="values">The eigenvalues corresponding to the principal axes.</param>
            <param name="radii"></param>
            <param name="cx">The x-coordinate of the center to calculate the principal axes about. Default value = 0</param>
            <param name="cy">The y-coordinate of the center to calculate the principal axes about. Default value = 0</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVu.ClearFromForegroundEdge(System.Boolean,System.Double)">
            <summary>
            Sets to "background" all pixels that are more than a given distance from the
            edge of foreground objects.
            </summary>
            <param name="FromLeftEdge">If true(false) starts from left(right) and clear to the left(right)</param>
            <param name="StartDistanceMM">Skips this distance from the edge before clearing</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVu.ClearInsideCurve(Claron.WIF.Curve)">
            <summary>
            Clears inside the given curve.
            </summary>
            <param name="curve">The curve to clear inside of. The vertices of the curve
            must be in physical coordinates.</param>
        </member>
        <member name="M:Claron.WIF.ImageVu.ClearOutsideCurve(Claron.WIF.Curve)">
            <summary>
            Clears outside the given curve.
            </summary>
            <param name="curve">The curve to clear outside of. The vertices of the curve
            must be in physical coordinates.</param>
        </member>
        <member name="M:Claron.WIF.ImageVu.MirrorMeY">
            <summary>
            Mirrors the image in the y-axis.
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageVu.Read(System.IO.Stream,System.Runtime.Serialization.Formatters.Binary.BinaryFormatter)">
            <summary>
            Reads the image using the specified stream and formatter.
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageVu.Write(System.IO.Stream,System.Runtime.Serialization.Formatters.Binary.BinaryFormatter)">
            <summary>
            Writes the image using the specified stream and formatter.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVu.CreateOverlappingFreeFormTransformation(System.Double,System.Double,Claron.WIF.ImageVu,Claron.WIF.AffineTransformation2D,Claron.WIF.AffineTransformation2D,System.Double,System.Double)">
            <summary>
            Creates a new free-form transformation with the control point grid
            placed on the overlapping region between this image and the specified
            moving image.
            </summary>
            <param name="sx">The spacing of control points desired in the
            x-direction.</param>
            <param name="sy">The spacing of control points desired in the
            y-direction.</param>
            <param name="moving">The moving image.</param>
            <param name="affine0">The transformation to use to map points in
            this image to the moving image.</param>
            <param name="affine1">An optional second xform that is assumed to apply
            at the lower end (maxy) region of the moving image.</param>
            <param name="affine0centerY"></param>
            <param name="affine1centerY"></param>
            <returns>The free-form transformation defined on the overlapping
            region.</returns>
            <remarks>If there are two xforms, (RX,RY) is used to indicate where the center
            of each xform is in this image.</remarks>
        </member>
        <member name="P:Claron.WIF.ImageVu.NX">
            <summary>
            The number of pixels in the x-direction.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.ImageVu.NY">
            <summary>
            The number of pixels in the y-direction.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.ImageVu.SX">
            <summary>
            The spacing of pixels in the x-direction in Mm.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.ImageVu.SpacingMm">
            <summary>
            The spacing between pixels in Mm. In Z, it is the Mm size of depth value unit.
            </summary>
        </member>
        <member name="P:Claron.WIF.ImageVu.SY">
            <summary>
            The spacing of pixels in the y-direction.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.ImageVu.MmZ">
            <summary>
            The ratio between mm and depth values (i.e., mm per depth unit).
            </summary>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.ImageVu.Matrix">
            <summary>
            The 4 x 4 matrix which maps positions in the image to the coordinate
            system of the 3D slice stack (the reference coordinate system).
            </summary>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.ImageVu.IMatrix">
            <summary>
            The 4 x 4 matrix which maps positions in the coordinate system of the
            3D slice stack (the reference coordinate system) into image space.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.ImageVu.DData">
            <summary>
            Image data which stores depth to voxel with specified HU unit.
            </summary>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.ImageVu.IsEmpty">
            <summary>
            Returns whether the image is empty or not.
            </summary>
        </member>
        <member name="P:Claron.WIF.ImageVu.XData">
            <summary>
            Property to get/set the x component of the normals.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.ImageVu.YData">
            <summary>
            Property to get/set the y component of the normals.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.ImageVu.ZData">
            <summary>
            Property to get/set the z component of the normals.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.ImageVu.MipData">
            <summary>
            Property to get/set the MIP data in the image.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.ImageVu.MinPixelValueD">
            <summary>
            Returns the minimum depth value in the image.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.ImageVu.MinPixelValueDNonNegative">
            <summary>
            Returns the minimum nonnegative depth value in the image.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.ImageVu.MaxPixelValueD">
            <summary>
            Returns the maximum depth value in the image.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.ImageVu.MinPixelValueMip">
            <summary>
            Returns the minimum pixel value for the MIP component.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.ImageVu.MinPixelValueMipDNonNegative">
            <summary>
            Returns the minimum pixel value for the MIP component for pixels where the depth is
            non-negative.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.ImageVu.MaxPixelValueMip">
            <summary>
            Returns the maximum pixel value for the MIP component.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.ImageVu.HeightMM">
            <summary>
            The distance, in mm, between the y=0 and y=NY-1
            </summary>
        </member>
        <member name="P:Claron.WIF.ImageVu.WidthMM">
            <summary>
            The distance, in mm, between the x=0 and x=NX-1
            </summary>
        </member>
        <member name="T:Claron.WIF.ImageVuTransformer">
            <summary>
            Class to transform a Vu image. If no transformation is specified then the
            image is resampled into the image space of the output image.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.ImageVuTransformer._input">
            <summary>
            The input image.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.ImageVuTransformer._output">
            <summary>
            The output image.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.ImageVuTransformer._transformation">
            <summary>
            The transform.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.ImageVuTransformer._interpolationType">
            <summary>
            The interpolation type.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVuTransformer.#ctor(Claron.WIF.ImageVu,Claron.WIF.ImageVu,Claron.WIF.ImageVuTransformer.InterpolationModeEnum,Claron.WIF.ITransformation2D)">
            <summary>
            Creates the resampler.
            </summary>
            <param name="input">The input image.</param>
            <param name="output">The output image.</param>
            <param name="interpolationType">The interpolation type.</param>
            <param name="transformation">The transformation to apply. Default value = null</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVuTransformer.UpdateOutputImage">
            <summary>
            Updates the output image.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVuTransformer.UpdateOutputImageUsingLinearInterpolation">
            <summary>
            Updates the output image using linear interpolation.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVuTransformer.UpdateOutputImageUsingLinearInterpolationThreadSub(System.Object)">
            <summary>
            Updates the output image using linear interpolation.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVuTransformer.UpdateOutputImageUsingNearestNeighborInterpolation">
            <summary>
            Updates the output image using nearest neighbor interpolation.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVuTransformer.UpdateOutputImageUsingNearestNeighborInterpolationThreadSub(System.Object)">
            <summary>
            Updates the output image using nearest neighbor interpolation.
            </summary>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.ImageVuTransformer.Input">
            <summary>
            Returns the input image.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.ImageVuTransformer.Output">
            <summary>
            Returns the output image.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.ImageVuTransformer.Transformation">
            <summary>
            Returns the transformation.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.ImageVuTransformer.InterpolationType">
            <summary>
            Returns the interpolation type.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.ImageVuTransformer.InterpolationModeEnum">
            <summary>
            Enum for the interpolation mode.
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.ImageVuTransformer.TransformImageThreadParams">
            <summary>
            Thread parameters structure for transforming the image.
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.ImageVuToBitmapConverter">
            <summary>
            Class to convert a Vu image into a bitmap.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.ImageVuToBitmapConverter._input">
            <summary>
            The image to convert.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.ImageVuToBitmapConverter._component">
            <summary>
            The component in the Vu image to convert and display in the image.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.ImageVuToBitmapConverter._output">
            <summary>
            The bitmap of the Vu image.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVuToBitmapConverter.#ctor(Claron.WIF.ImageVu,Claron.WIF.ImageVuToBitmapConverter.ComponentTypeEnum)">
            <summary>
            Creates a new Vu image to bitmap converter.
            </summary>
            <param name="image">The image to convert.</param>
            <param name="type">The component in the Vu image to convert and
            display in the bitmap.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageVuToBitmapConverter.UpdateBitmap">
            <summary>
            Updates the bitmap of the Vu image.
            </summary>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.ImageVuToBitmapConverter.Component">
            <summary>
            Property to get/set the component in the Vu image to convert and
            display in the output bitmap.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.ImageVuToBitmapConverter.Input">
            <summary>
            Returns the Vu image.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.ImageVuToBitmapConverter.Output">
            <summary>
            Property to retrieve the Vu image as a bitmap.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.ImageVuToBitmapConverter.ComponentTypeEnum">
            <summary>
            The component in the Vu image to convert and display in the bitmap.
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.Lumen">
             <summary>
             A model of a vessel lumen, consisting of a centerline and (optionally) an inner and 
             outer walls surrounding it.
            
             The centerline is represented as a sequence of equidistant sample locations. Each location
             has its own coordinate system, with Z pointing roughly toward the next sample in the sequence,
             and the X and Y axes are pointing in a similar direction to the X and Y of the previous sample.
            
             A wall is represented as a rectangular grid of samples, organized along longitudinal
             and latitudinal lines. Longitudinal lines (constant longitude index) go along the length
             of the lumen, while latitudinal lines (constant latitude index) go laterally,
             around the lumen, forming a "ring" around each centerline sample point in clockwise order.
            
             Methods are provided to support displaying and editing the centerline and walls of the lumen.
            
             The volume included by the walls of the lumen may be exported as a 3D using a fast scan-conversion
             algorithm.
            
                     +   -latitudeI- =0     +
                    +    -latitudeI- =1      +
                    +      ...               +
               |     +                      +    |
               l     +                      +    l
               o     +                      +    o
               n     +                      +    n
               g    +                        +   g
               i    +                        +   i
               t    +                       +    t
               u     +                      +    u
               d     +                      +    d
               e     +                      +    e
               I    +                        +   I
               |    +                        +   |
                    +                       +
               =     +                      +    =
                    +                      +
               0     +                      +    N/2+1
                    +                        +   ( max(|longitudeI|) = contour samples count )
                    +                        +
                    +                       +
                     +   -latitudeI- = max +     ( max(-latitudeI-) = centerline samples count )
             </summary>
             <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Lumen._name">
            <summary>The name / label of the lumen.</summary>
        </member>
        <member name="F:Claron.WIF.Lumen._Centerline">
            <summary>THE list (not copy) of ToPatientScan SpaceMappers that define
            the centerline. Should not be modified by the client (for read use only).</summary>
        </member>
        <member name="F:Claron.WIF.Lumen._centerlineSpacingMm">
            <summary> The distance between centerline/latitudinal sample points. ''' </summary>
        </member>
        <member name="F:Claron.WIF.Lumen._longitudinalsCount">
            <summary> The number of points along a cross-section contour of a wall. 
            Must be even to accommodate ribbon displays. ''' </summary>
        </member>
        <member name="F:Claron.WIF.Lumen._wallOuter">
            <summary>
            The array of samples describing the outer wall of the lumen.
            It is indexed by: LatitudinalI * _longitudinalsCount + LongitudinalI.
            The radii are in the XY plane of the centerline point with the same latitude index.
            Radius 0 is pointing in the X direction, and subsequent radii rotate clockwise
            when viewed in the Z direction.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Lumen._wallInner">
            <summary>
            The array of samples describing the inner wall of the lumen.
            It is indexed by: LatitudinalI * _longitudinalsCount + LongitudinalI.
            The radii are in the XY plane of the centerline point with the same latitude index.
            Radius 0 is pointing in the X direction, and subsequent radii rotate clockwise
            when viewed in the Z direction.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.LongitudinalRollRadians(System.Int32)">
            <summary>
            The roll angle, in radians, of a given Longitudinal index.
            </summary>
            <param name="LongitudinalI"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.LongitudinalI(System.Double)">
            <summary>
            The closest longitudinal index to a given angle, in radians
            </summary>
        </member>
        <member name="M:Claron.WIF.Lumen.OuterWallArray">
            <summary>
            Provides direct access to the array holding the wall samples. If the client modified it,
            it is responsible for call Updated() afterwards.
            </summary>
            <remarks>Index samples using  LongitudinalI * LatitudinalsCount + LatitudinalI </remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.SetOuterWallArray(Claron.WIF.Lumen.WallSample[])">
            <summary>
            Sets the outer wall array.
            </summary>
        </member>
        <member name="M:Claron.WIF.Lumen.InnerWallGet(System.Int32,System.Int32)">
            <summary>
            A sample of the inner wall.
            </summary>
            <param name="LongitudinalI"></param>
            <param name="LatitudinalI"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.InnerWallSet(System.Int32,System.Int32,Claron.WIF.Lumen.WallSample)">
            <summary>
            A sample of the inner wall.
            </summary>
            <param name="LongitudinalI">The index into the array of ribbon lines. Must be non-negative.</param>
            <param name="LatitudinalI">The index into the array of contours. Clamped to the valid range.</param>
            <param name="NewValue"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.InnerWallArray">
            <summary>
            Provides direct access to the array holding the wall samples. If the client modified it,
            it is responsible for calling Updated() afterwards.
            </summary>
            <remarks>Index samples using  LongitudinalI * LatitudinalsCount + LatitudinalI </remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.SetInnerWallArray(Claron.WIF.Lumen.WallSample[])">
            <summary>
            Sets the inner wall array samples.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.WallSurface(System.Boolean,Claron.WIF.GridBox)">
            <summary>
            Exports a polygonal surface description of the inner wall in PatientScan RCS Coordinates
            </summary>
            <param name="ofInnerWall">If True then the inner wall surface is returned, 
            otherwise the outer wall surface is returned.</param>
            <param name="grid" />
            <returns>A new Surface object. May be empty of the wall is not defined.</returns>
        </member>
        <member name="M:Claron.WIF.Lumen.ToPolyArray(System.Boolean)">
            <summary>
            Exports a polygonal surface description of the inner wall in PatientScan RCS Coordinates
            </summary>
            <param name="ofInnerWall">If True then the inner wall surface is returned, otherwise the
            outer wall surface is returned.</param>
            <returns>A new Surface object. May be empty of the wall is not defined.</returns>
        </member>
        <member name="F:Claron.WIF.Lumen._InnerRadiiPatch">
            <summary>
            The inner lumen radii patch.
            </summary>
        </member>
        <member name="F:Claron.WIF.Lumen._OuterRadiiPatch">
            <summary>
            The outer radii patch.
            </summary>
        </member>
        <member name="M:Claron.WIF.Lumen.UpdateCenterline(System.Collections.Generic.IEnumerable{Claron.WIF.Vector3})">
            <summary>
            Updates the centerline from a set of new coordinates, preserving the lumen wall radii
            at a similar distance along the line (if defined).
            </summary>
            <param name="centerlinePointsProximalToDistalPr">Positions along the centerline in patient scan RCS (PR). Proximal to distal.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.CenterlineReplace(System.Collections.Generic.IEnumerable{Claron.WIF.Vector3},System.Double)">
            <summary>
            Replaces the centerline and its spacing from a set of new coordinates, preserving the lumen wall radii
            at a similar distance along the line (if defined).
            </summary>
            <param name="centerlinePointsProximalToDistalPr">Positions along the centerline in patient scan RCS (PR). Proximal to distal.</param>
            <param name="newCenterlineSpacingMmAssumedTomatchNewVertices">new Centerline SpacingMm Assumed To match New Vertices</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.#ctor(System.String,Claron.WIF.Vector3[],System.Double,System.Double,System.Double,System.Int32,System.Boolean)">
            <summary>
            Creates a lumen from a set of centerline points and matching average radii.
            Distal to proximal order.
            </summary>
            <param name="name">Name of the lumen (for client use).</param>
            <param name="centerlinePointsProximal2DistalPr">Positions along the centerline in patient scan RCS (PR). proximal to distal order.</param>
            <param name="constantRadiusMmInner">Constant inner radius along the centerline.</param>
            <param name="constantRadiusMmOuter">Constant outer radius along the centerline.</param>
            <param name="sampleSpacingMm">Desired lumen centerline point spacing. Suggested value = 0.5</param>
            <param name="longitudinalsCount">longitudinalsCount for the new lumen. Suggested value = 16</param>
            <param name="smoothCenterline">Should smooth centerline or not? Suggested value = True.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.#ctor(System.String,Claron.WIF.SpaceMapperSimilarity[],System.Double,System.Double,System.Int32)">
            <summary>
            Creates a lumen around a given set of equally-spaced centerline space mappers to Patient RCS (Pr).
            </summary>
            <param name="name">Name of the lumen (for client use).</param>
            <param name="Centerline">An array of mappers from centerline space to patient space (Pr) at each point 
            (Z oriented towards the next point, X and Y vary smoothly from one point to the next.
            The array is not copied - it is used directly.</param>
            <param name="constantRadiusMmInner">Constant inner radius along the centerline.</param>
            <param name="constantRadiusMmOuter">Constant outer radius along the centerline.</param>
            <param name="longitudinalsCount">longitudinalsCount for the new lumen. Suggested value = 16</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.#ctor(System.String,Claron.WIF.Vector3[],System.Double,System.Int32)">
            <summary>
            Lumen without wall and Without smoothing
            </summary>
            <param name="name"></param>
            <param name="centerlinePointsProximal2DistalPr"></param>
            <param name="sampleSpacingMm"></param>
            <param name="longitudinalsCount"></param>
        </member>
        <member name="M:Claron.WIF.Lumen.#ctor(Claron.WIF.Curve,Claron.WIF.Vector3)">
            <summary>
            Creates a Lumen from a centerline curve, with a fixed X axis direction in the patient
            (with Y perpendicular to X and Z is close as possible to being along the centerline).
            </summary>
            <param name="EquidistantlySampledCurvePr">The curve in Patient RCS (Pr) coordinates, with at least 2 vertices</param>
            <param name="CenterlineXinPr">The direction vector of the X axis of the centerline in patient RCS</param>
        </member>
        <member name="M:Claron.WIF.Lumen.#ctor(Claron.WIF.SpaceMapperSimilarity[],System.String)">
            <summary>
            Creates a Lumen from a given equidistantly sampled and properly oriented centerline, 
            </summary>
            <param name="CenterLine">An array of mappers from centerline space to patient space (Pr) at each point 
            (Z oriented towards the next point, X and Y vary smoothly from one point to the next.</param>
            <param name="Name">Optional name</param>
        </member>
        <member name="M:Claron.WIF.Lumen.#ctor(System.String,Claron.WIF.Vector3[],System.Double[],System.Int32,System.Double,Claron.WIF.SpaceMapperSimilarity,System.Boolean)">
            <summary>
            Creates a lumen from a set of centerline points and matching average radii.
            Distal to proximal order.
            </summary>
            <param name="name">Name of the lumen.</param>
            <param name="centerlinePointsPr">Positions along the centerline in patient scan RCS (PR). Distal to proximal order.</param>
            <param name="radiiMm">Radii (of inner wall) along the centerline (one per centerline point). Distal to proximal order.</param>
            <param name="LongitudinalsCountMultiplier">Specifies a factor to multiply the default longitunidals count by.</param>
            <param name="SampleSpacingMm">Desired lumen centerline point spacing. Default value = 0.5</param>
            <param name="xDirSpaceMapper">Default value = null.</param>
            <param name="smoothCenterline">Should smooth centerline or not? Default value = True.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.#ctor(System.String,Claron.WIF.SpaceMapperSimilarity[],System.Double[],System.Int32,System.Double)">
            <summary>
            Initializes a new lumen with precomputed data.
            </summary>
            <param name="name">The name of the lumen.</param>
            <param name="centerlineMappersPr">The centerline mappers.</param>
            <param name="radii">The radii.</param>
            <param name="LongitudinalsCountMultiplier">Specifies a factor to multiply the default longitunidals count by.</param>
            <param name="sampleSpacingMm"></param>
        </member>
        <member name="M:Claron.WIF.Lumen.#ctor(System.String,Claron.WIF.Vector3[],Claron.WIF.Vector3,System.Double,System.Double)">
             <summary>
             Creates a lumen from a centerline and a special bifurcationPointPr, indicating where the lumen splits into two.
            
             Algorithm:
             The initial smoothing and is done iteratively with holding the bifurcationPointPr fixed,
               i.e. by resetting the bifurcationPointPr after each laplace smoothing iteration.
             The equidistant resampling is not started at a centerline end,
               but instead started at the bifurcation point and then extended from there in both directions
               to ensure that there is no inconsistency of the samples gap sizes at the bifurcationPointPr
             The resampled points are partitioned into before and after the bifurcationPointPr.
             The parent lumen part is first converted into the matching array of spacemappers with minimum roll,
               thus no centerline points of the child lumen have any influence on the orientation of the last
               spacemapper at the bifurcationPointPr
             The child lumen part is then converted with the spacemapper at the bifurcationPointPr as starting spacemapper,
               thus continuity across the bifurcationPointPr is ensured.
             </summary>
             <param name="name">The name of this Lumen</param>
             <param name="centerlinePointsProximal2DistalPr"></param>
             <param name="bifurcationPointPr"></param>
             <param name="maxRadiusMm"></param>
             <param name="sampleSpacingMm"></param>
             <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.#ctor(System.String,Claron.WIF.SpaceMapperSimilarity[],Claron.WIF.Lumen.WallSample[],Claron.WIF.Lumen.WallSample[],System.Double)">
            <summary>
            Creates a lumen from a set of spacemappers and matching wall samples.
            Distal to proximal order.
            No modification of the input parameters is done, they are just copied.
            </summary>
            <param name="name">Name of the lumen.</param>
            <param name="centerlineSpacemappers">Spacemappers along the centerline. Proximal to distal order. </param>
            <param name="wallSamplesInner">Inner contour WallSamples along the centerline (one contour set per centerline point). 
            Proximal to distal order. Can also by null, if the wall is not needed.</param>
            <param name="wallSamplesOuter">Outer contour WallSamples along the centerline (one contour set per centerline point). 
            Proximal to distal order. Ignored if wallSamplesInner is null.</param>
            <param name="SampleSpacingMm">Source lumen centerline point spacing. Default value = 0.5</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.Clone">
            <summary>
            Returns a clone of the lumen.
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.CopyGeometryShallowFrom(Claron.WIF.Lumen)">
            <summary>
            Returns a clone of the lumen.
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.ReSmooth">
            <summary>
            Calls InitSmoothAndResampleVoxelCenters() for all centerline points.
            Call refine walls after this.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.InitSpacemappers(System.Collections.Generic.List{Claron.WIF.Vector3},System.Double,Claron.WIF.SpaceMapperSimilarity)">
            <summary>
            Initializes the spacemappers along the centerline.
            Each points z-direction is found as the difference vector between the centerline points +/-5mm
            from the current point.
            </summary>
            <param name="Vs">A list of centerline points. This is assumed to already be smoothed/curvature limited.</param>
            <param name="SampleSpacingMm">The Spacing between centerline points.</param>
            <param name="xDirSpaceMapper">The desired x-axis orientation of the first spacemapper. Default value = null</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.CreateWallPatchFromRadii(System.Int32,System.Int32,System.Double,System.Int32,System.Int32,Claron.WIF.Lumen.Wall)">
            <summary>
            Creates a averaged lumen wall patch from the input radii.
            </summary>
            <param name="oLngs">The number of longitudes in the output patch.</param>
            <param name="oLats">The number of latitudes in the output patch.</param>
            <param name="len">The length of the patch.</param>
            <param name="iLngs">The number of longitudes in the input radii array.</param>
            <param name="iLats">The number of latitudes in the input radii array.</param>
            <param name="wall">The input radii.</param>
        </member>
        <member name="M:Claron.WIF.Lumen.CenterlinePosPr(System.Int32)">
            <summary>
            Returns the position in PatientScan RCS of an indexed location along the centerline
            </summary>
            <param name="indexAlongCenterline"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Lumen.CenterlineFragment(System.Double,System.Double,System.Double,System.Double,System.Boolean)">
            <summary>
            Obtains a resampled section of the centerline symmetrical around a center position.
            Sample Locations where there is no centerline contain "Nothing".
            The fragment always contains an odd number of samples.
            </summary>
            <param name="MidPositionMm">The distance along the centerline where the middle position is.</param>
            <param name="HalfLengthMm"></param>
            <param name="SpacingMm">If not 0, </param>
            <param name="RollRadians">Optional additional roll (clockwise when viewed in the +Z direction) of the
            source coordinates around the centerline's axis.</param>
            <param name="isRibbonCurved"></param>
            <returns></returns>
            <remarks>The actual length of the returned fragment may actually be a bit
            shorter than 2*HalfLengthMm because of the restriction that samples are SpacingMm
            apart</remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.WallFragment(System.Double,System.Double,System.Double,System.Int32,System.Boolean)">
            <summary>
            Obtains a resampled section of the inner or outer wall longitudinal (corresponds to CenterlineFragment)
            Will raise an exception of the wall has never been set.
            </summary>
            <param name="MidPositionMm">The distance along the centerline where the middle position is.</param>
            <param name="SpacingMm">Distance between the samples to be taken, in mm</param>
            <param name="HalfLengthMm">Half the length of the fragment, in mm</param>
            <param name="LongitudinalI">The index of the longitudinal</param>
            <param name="OfInnerWall">True: get inner wall fragment, False: get outer wall fragment.</param>
            <returns>An array of the samples of the inner wall. If the sample is outside the lumen, then its RadiusMm is negative.</returns>
        </member>
        <member name="M:Claron.WIF.Lumen.WallFragmentFromWallPatch(System.Double,System.Double,System.Double,System.Double,System.Boolean)">
            <summary>
            Interpolates the radii of the lumen radii patch at the given longitudinal index.
            </summary>
        </member>
        <member name="M:Claron.WIF.Lumen.ControlVerticesFromWallPatch(System.Double,System.Boolean)">
            <summary>
            Returns the control vertices of the lumen radii patch in an array of Vector2's. The second
            component holds the distance along the lumen and the first the radius at that position.
            </summary>
        </member>
        <member name="M:Claron.WIF.Lumen.InnerOuterWallFragmentApplyEdits(System.Double,System.Double,System.Double,System.Int32,System.Int32,System.Int32,System.Collections.Generic.List{System.Double},System.Boolean)">
            <summary>
            Applies edits (radius changes) to the wall fragment obtained earlier using WallFragment.
            </summary>
            <param name="midPositionMm">The distance along the centerline where the middle position is.</param>
            <param name="SpacingMm">Distance between the samples to be taken, in mm</param>
            <param name="halfLengthMm">Half the length of the fragment, in mm</param>
            <param name="LongitudinalI">The index of the longitudinal</param>
            <param name="FirstI">The first index in the section samples where radii were edited</param>
            <param name="LastI">The last index in the section samples where radii were edited</param>
            <param name="RadiusChangesMm">A list of the radius changes to the samples in the section
            between FirstI and LastI</param>
            <param name="innerWallEdit">If true do an inner wall edit otherwise do outer wall edit.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.InnerWallCrossSectionStats(System.Double)">
            <summary>
            Obtains statistics about a cross section of the inner wall at a given location along 
            the centerline.
            </summary>
            <param name="PositionMm">The distance along the centerline where the cross section is.</param>
            <returns>If the sample is outside the lumen or no walls are defined, then its AreaMmSq is negative.</returns>
        </member>
        <member name="M:Claron.WIF.Lumen.OuterWallCrossSectionStats(System.Double)">
            <summary>
            Obtains statistics about a cross section of the outer wall at a given location along the centerline.
            </summary>
            <param name="PositionMm">The distance along the centerline where the cross section is.</param>
            <returns>The stats. If the sample is outside the lumen, then its AreaMmSq is negative.</returns>
        </member>
        <member name="M:Claron.WIF.Lumen.InnerWallCrossSectionStats(System.Int32)">
            <summary>
            Obtains statistics about a cross section of the inner wall at a given location along the centerline.
            </summary>
            <param name="positionI">The index into the cross-sectional array.</param>
            <returns>The stats. If the sample is outside the lumen, then its AreaMmSq is negative.</returns>
        </member>
        <member name="M:Claron.WIF.Lumen.InnerWallFragmentStats(System.Double,System.Double,System.Double)">
            <summary>
            Obtains statistics of a resampled section of the inner wall (corresponds to CenterlineFragment)
            </summary>
            <param name="MidPositionMm">The distance along the centerline where the middle position is.</param>
            <param name="SpacingMm">Distance between the samples to be taken, in mm</param>
            <param name="HalfLengthMm">Half the length of the fragment, in mm</param>
            <returns>An array of stats along the inner wall. If the sample is outside the lumen, then its AreaMmSq is negative.</returns>
        </member>
        <member name="M:Claron.WIF.Lumen.WallCrossSection(System.Double,System.Double,System.Int32,System.Boolean)">
            <summary>
            Obtains a resampled cross section of the inner/outer wall, at equi-angularly spaced samples.
            </summary>
            <param name="centerlinePositionMm">The distance along the centerline of the cross section.</param>
            <param name="startRollRadians">The roll angle in which sample index 0 is to be taken</param>
            <param name="samplesCount">The number of samples to be obtained, spaced at 2*PI/SamplesCount angle from each other.</param>
            <param name="OfInnerWall"></param>
            <returns>An array of samples of the inner wall. If the position is outside the lumen, Nothing is returned.</returns>
        </member>
        <member name="M:Claron.WIF.Lumen.WallCrossSection(Claron.WIF.SpaceMapperSimilarity,System.Int32,System.Boolean)">
            <summary>
            Obtains a resampled cross section of the inner/outer wall, at equi-angularly spaced samples.
            </summary>
            <param name="sm">The space mapper on the centerline at which to obtain the cross section.</param>
            <param name="samplesCount">The number of samples to be obtained, spaced at 2*PI/SamplesCount angle from each other.</param>
            <param name="OfInnerWall"></param>
            <returns>An array of samples of the inner wall. If the position is outside the lumen, Nothing is returned.</returns>
        </member>
        <member name="M:Claron.WIF.Lumen.WallCrossSectionFromWallPatch(System.Double,System.Double,System.Int32,System.Boolean)">
            <summary>
            Returns a resample cross-section of the inner/outer wall, at equi-angularly spaced samples using
            the lumen radii patch.
            </summary>
            <param name="centerlinePositionMm">The distance along the centerline of the cross section.</param>
            <param name="startRollRadians">The roll angle in which sample index 0 is to be taken</param>
            <param name="samplesCount">The number of samples to be obtained, spaced at 2*PI/SamplesCount angle from each other.</param>
            <param name="OfInnerWall"></param>
            <returns>An array of samples of the inner wall. If the position is outside the lumen, Nothing is returned.</returns>
        </member>
        <member name="M:Claron.WIF.Lumen.WallCrossSectionApplyEdits(System.Double,System.Boolean,System.Double[])">
            <summary>
            Applies new wall cross-section edits at the two wall cross-section latitude indices whose
            centerline position is closest to the given centerline position so that the interpolated
            radii are equal to the given radii. Assumes number of radii samples equals the longitudinal
            count. Also ensures that the inner and outer wall contours do not cross over each other.
            </summary>
            <param name="centerlinePositionMm">The position along the centerline at which to apply the
            edits.</param>
            <param name="innerWall">Whether the inner wall is being edited?</param>
            <param name="radii">The new radii.</param>
        </member>
        <member name="M:Claron.WIF.Lumen.TopSuspiciousPositionsMm">
            <summary>
            Returns an orderd list of positions where the cross-section area deviates more than a certain ratio
            from the smoothed area. Caches prior computation results (so no need to cache on the client side).
            </summary>
            <returns>A list of positions, ordered from the most suspicious (largest ratio) to the least suspicuous</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.MedianInnerWallRadiusMm(System.Int32)">
            <summary>
            The median radius of the inner wall contour at the specified centerline position.
            </summary>
            <param name="latitudinalI">The index into the list of contours.</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.ExtrapolateCenterlineEnd">
            <summary>
            Extrapolates the centerline to obtain the next point along the centerline
            outside the current range, at the current centerline point spacing.
            </summary>
            <returns>The extrapolated centerline point in the patient RCS</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.ExtendCenterlineEnd(Claron.WIF.SpaceMapperSimilarity,System.Double,Claron.WIF.Lumen.WallSample.WallSampleOrigin)">
            <summary>
            Extends the centerline with an already optimized next space mapper, and a uniform inner wall radius.
            </summary>
            <param name="sm">The SpaceMapperSimilarity to extend the centerline with.</param>
            <param name="medianInnerWallRadius">The median inner wall radius at the new lumen extension location.</param>
            <param name="origin">Origin on the radius value.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.ExtendCenterlineEnd(System.Collections.Generic.List{Claron.WIF.SpaceMapperSimilarity})">
            <summary>
            Extends the centerline with additional space mappers, already optimizied.
            Warning: the walls are not extended, only the centerline!
            </summary>
            <param name="Mappers">The list of SpaceMapperSimilarity object to extend the centerline with.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.CenterlineToPatient(System.Double,System.Double,System.Boolean)">
            <summary>
            Obtains the mapping between the lumen and the patient at a specific location along the
            centerline. Returns null if the position is outside the centerline
            </summary>
            <param name="PositionMm">The distance, in mm, from the lumen's start along the centerline</param>
            <param name="RollRadians">Optional additional roll (clockwise when viewed in the +Z direction) of the
            source coordinates around the centerline's axis. Default value = 0</param>
            <param name="isRibbonCurved"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.CenterlineIndexToPatient(System.Int32)">
            <summary>
            Obtains the mapping between the lumen and the patient at specific centerline sample index.
            Returns Nothing if the position is outside the centerline
            </summary>
            <param name="index">The centerline list index.</param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Lumen.CenterlineAsCurve">
            <summary>
            Converts the stored centerline to a Curve and returns it
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.CenterlineAsCurve(System.Double)">
            <summary>
            Converts the stored centerline to a Curve and returns it
            Does this starting only from the given offset.
            </summary>
            <param name="centerlineMmOffsetBgn">The mm distance into the centerline at which to start the conversion to the curve.</param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Lumen.CenterlineOrientToPatientView(Claron.WIF.Camera.PatientViewDirection,System.Double)">
            <summary>
            Rotates each mapper along the centerline around its Z axis as needed to make
            the lumen appear as desired when rendered as a ribbon with no roll.
            </summary>
            <param name="RibbonViewDir"></param>
            <param name="ApplyOrientationSmoothing0to1">(Optional, 0.5) Controls how much the mapper orientations are
            smoothed after the operation (mainly to ensure a continuous ribbon image when rendered)</param>
        </member>
        <member name="M:Claron.WIF.Lumen.CenterlineRoll(System.Double)">
            <summary>
            Rotates each mapper along the centerline around its Z axis by the given angle 
            </summary>
            <param name="AngleRadian">Positive->clockwise when looking in the Z direction</param>
        </member>
        <member name="M:Claron.WIF.Lumen.CenterlineNearestToPatient(System.Double)">
            <summary>
            Returns the location in Patient RCS of the centerline point that is closest to the given position (in mm from the
            first point on centerline)
            </summary>
            <param name="positionMm"></param>
            <returns>Spacemapper for the nearest centerline point</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.CenterlineNearestPositionMm(Claron.WIF.Vector3)">
            <summary>
            Returns the centerline point nearest to the given pntPr.
            Does not interpolate along the centerline for continues output, but snaps to existing centerline points only
            </summary>
            <param name="pntPr">Point in Pr (Patient Reference Coordinates)</param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Lumen.CenterlineNearestPositionMmExact(Claron.WIF.Vector3)">
            <summary>
            Returns the centerline point nearest to the given pntPr.
            Does interpolate along the centerline for continues output, no snapping to existing centerline points.
            </summary>
            <param name="pntPr">Point in Pr (Patient Reference Coordinates)</param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Lumen.Reverse">
            <summary>
            Reverse the lumen model switching the meaning of begin and end and reversing the contours.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.DeleteNewEndI(System.Int32)">
            <summary>
            Shrinks the lumen from the end such that the given uindex becomes the new last centerline index.
            </summary>
        </member>
        <member name="M:Claron.WIF.Lumen.DeleteEnd(System.Int32)">
            <summary>
            Shrinks the lumen from the end by the number of points to delete.
            </summary>
            <param name="numCenterlinePointsToDelete"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.DeleteBgn(System.Int32)">
            <summary>
            Shrinks the lumen from the bgn by the number of points to delete.
            This also makes the index at that number the new first (zero) index.
            </summary>
            <param name="numCenterlinePointsToDelete"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.TiltSpaceMapperToPos(System.Double,Claron.WIF.Vector3)">
            <summary>
            Tilts the nearest space mapper toward the given position P,
            such that the local lumen z axis becomes the center-P vector.
            </summary>
            <param name="centerlineDistMm">The distance along the lumen identifying the spacemapper to be changed.</param>
            <param name="posPatRcs">The new heading position.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.WallsFixOutliersSlidingWindowStdDevAndCurvature(Claron.WIF.Lumen.WallTypes,System.Double)">
            <summary>
            fix outrageous outliers inner and limit curvature adaptively
            </summary>
            <param name="wallType">Inner or outer</param>
            <param name="smoothness">in range [0.5, 2] the larger the smoother the result</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.RefineCenterlineFromContour(Claron.WIF.Lumen.WallTypes,System.Double,System.Boolean)">
            <summary>
            Recomputes the centerline to be in the middle of the current contour.
            Assumes some contour optimization was computed before,
            and another contour optimization will be computed after
            Does assume the prior center is inside the desired lumen, i.e. lumen bubbles bulging out are likely outliers.
            </summary>
            <param name="wallType"></param>
            <param name="avgRadiusToCurvatureRadiusMultiplier">=2 for lumens, =4 for vertebras</param>
            <param name="averageRadii"></param>
            <returns>A list of Vector3 objects containing the updated centerlines.</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.RefineCenterlineFromContourUnconstraintCenter(Claron.WIF.Lumen.WallTypes,System.Double,System.Boolean)">
            <summary>
            Recomputes the centerline to be in the middle of the current contour.
            Assumes some contour optimization was computed before,
            and another contour optimization will be computed after.
            Does NOT assume the prior center is inside the desired lumen, i.e. the lumen could be a bubble bulging out and the desired center is in the middle of the bubble.
            </summary>
            <param name="wallType"></param>
            <param name="avgRadiusToCurvatureRadiusMultiplier">=2 for lumens, =4 for vertebras</param>
            <returns>A list of Vector3 objects containing the updated centerlines.</returns>
            <param name="averageRadii"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.FindCenterPointMaxDistanceFromBoundary(Claron.WIF.Vector3[])">
            <summary>
            Finds the center point in the closed polygon with the given vertices which is furthest from
            the boundary.
            </summary>
            <returns>The center point.</returns>
            <remarks>Uses simplex optimization method to find the center point. Initial trials are
            chosen so that updated point moves closer to the desired center point.</remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.GetTrialPoints(Claron.WIF.Vector3,Claron.WIF.Vector3[],System.Double,System.Double,System.Double,Claron.WIF.Vector3)">
            <summary>
            Returns the trial points used for finding the center point.
            <seealso>FindCenterPointMaxDistanceFromBoundary()</seealso>
            </summary>
        </member>
        <member name="M:Claron.WIF.Lumen.GetIntersectionPoints(Claron.WIF.Vector3,Claron.WIF.Vector3[],System.Double,System.Double,System.Double,Claron.WIF.Vector3)">
            <summary>
            Returns the point on the curve closest to the centroid, and the point on the curve opposite to
            the closest point which passes through the line joining the centroid and the closest point.
            </summary>
            <param name="centroid">The centroid</param>
            <param name="curvePts">The points on the curve.</param>
            <param name="rmsRadius"></param>
            <param name="minRadius"></param>
            <param name="maxRadius"></param>
            <param name="closestPoint"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.CalculateMinimuDistanceSquaredToPoints(Claron.WIF.Vector3,Claron.WIF.Vector3[])">
            <summary>
            Calculates the minimum distance squared of cp to the points in samplePts.
            </summary>
        </member>
        <member name="M:Claron.WIF.Lumen.ToBitVol(Claron.WIF.GridBox,System.Boolean)">
            <summary>
            Scan-converts a lumen (inner or outer wall) into a bit volume.
            </summary>
            <param name="grid">The grid of the target bit volume.</param>
            <param name="UseInnerWall">Indicates whether to use inner or outer wall surface</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.CenterlineToBitVol(Claron.WIF.GridBox)">
            <summary>
            Scan-converts a centerline into a bit volume where each centerline point
            is set to 1 (but not locations between them!).
            </summary>
            <param name="grid">The grid of the target bit volume.</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.ToCylinder3dArrayLowRes(Claron.WIF.SliceStack,Claron.WIF.BitVol,System.Double,System.Double,Claron.WIF.Vector3_I32@,Claron.WIF.Vector3@,System.Int16[]@)">
            <summary>
            Renders all ribbon views for the given lumen and transfers the result pixels
            into a 3d array of modality values with one "slice" per half ribbon,
            always having the centerline on the left edge of the slice.
            </summary>
            <param name="ss">The slice stack to render from.</param>
            <param name="nonBoneBv">The lumen to get the ribbon geometry info from.</param>
            <param name="radialSpacingMm">The spacing between cylinder samples in the radial direction.</param>
            <param name="cylinderRadiusExtensionMm">radial cylinder extension past the max outer wall radius.</param>
            <param name="cylinderDims">ByRef, return data size.
              The 3d coordinates are interpreted as
              x =  r  = along radial axis,
              y = phi = along angular axis with implicit wrap around from last to first,
              z =  z  = along cylinder centerline.</param>
            <param name="cylinderSpacingMm">ByRef, return data spacing.</param>
            <param name="cylinderData">ByRef, return data.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.ToCylinder3dArray(Claron.WIF.SliceStack,Claron.WIF.BitVol,System.Double,Claron.WIF.Vector3_I32@,Claron.WIF.Vector3@,System.Int16[]@)">
            <summary>
            Renders all ribbon views for the given lumen and transfers the result pixels
            into a 3d array of modality values with one "slice" per half ribbon,
            always having the centerline on the left edge of the slice.
            </summary>
            <param name="ss">The slice stack to render from.</param>
            <param name="nonBoneBv">The region in which to allow the data gathering.</param>
            <param name="cylinderRadiusExtensionMm">radial cylinder extension past the max outer wall radius.</param>
            <param name="cylinderDims">ByRef, return data size.
              The 3d coordinates are interpreted as
              x =  r  = along radial axis,
              y = phi = along angular axis with implicit wrap around from last to first,
              z =  z  = along cylinder centerline.</param>
            <param name="cylinderSpacingMm">ByRef, return data spacing.</param>
            <param name="cylinderData">ByRef, return data.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.ToCylinder3dArray(Claron.WIF.SliceStack,Claron.WIF.BitVol,System.Double,System.Double,Claron.WIF.Vector3_I32@,Claron.WIF.Vector3@,System.Int16[]@)">
            <summary>
            Renders all ribbon views for the given lumen and transfers the result pixels
            into a 3d array of modality values with one "slice" per half ribbon,
            always having the centerline on the left edge of the slice.
            </summary>
            <param name="ss">The slice stack to render from.</param>
            <param name="nonBoneBv">The region in which to allow the data gathering.</param>
            <param name="radialSpacingMm">overriden for AutoSpine use</param>
            <param name="cylinderRadiusExtensionMm">radial cylinder extension past the max outer wall radius.</param>
            <param name="cylinderDims">ByRef, return data size.
              The 3d coordinates are interpreted as
              x =  r  = along radial axis,
              y = phi = along angular axis with implicit wrap around from last to first,
              z =  z  = along cylinder centerline.</param>
            <param name="cylinderSpacingMm">ByRef, return data spacing.</param>
            <param name="cylinderData">ByRef, return data.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.WallComputedHalo(Claron.WIF.GridBox)">
            <summary>
            Computes a 3 voxel layer halo just outside the inner wall of the lumen,
            but only in areas where the inner wall was confidently computed.
            </summary>
            <param name="grid">The grid to use for the resulting bitvol.</param>
            <returns>The halo as bitvol.</returns>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Lumen._debugLmnIdx">
            <summary> Global value for enabling debug serialization of BitVols (even in release mode, but turned off by default) </summary>
        </member>
        <member name="M:Claron.WIF.Lumen.DebugWallsImg(Claron.WIF.SliceStack,System.Double,System.String)">
            <summary>
            Save to disk .png image of lumen, presenting all wall
            samples(Inner and Outer)
            </summary>
            <param name="ss"></param>
            <param name="lmnSpacingMmR"></param>
            <param name="step"></param>
        </member>
        <member name="M:Claron.WIF.Lumen.Concatenate(Claron.WIF.Lumen)">
            <summary>
            Returns a new lumen which is a concatenation of this and a subsequent ones.
            The wall samples correspondend with the input lumens unless the two 
            lumens being combined have different numbers of longitudinals.
            </summary>
            <param name="Subsequent">The lumen to be contatenated to this one, with same mm spacing
            between centerline point and with its first
            centerline point within 0.1mm of the last point of this one.</param>
            <returns>The combined lumen, with the name this.Name + " and " + Subsequent.Name</returns>
        </member>
        <member name="P:Claron.WIF.Lumen.SerializeAllFields">
            <summary>
            Property to get/set whether all fields in the Lumen should be serialized. Needed for state
            save/restore.
            </summary>
        </member>
        <member name="P:Claron.WIF.Lumen.Name">
            <summary>The name / label of the lumen for client use.</summary>
        </member>
        <member name="P:Claron.WIF.Lumen.DefaultLongitudinalsCount">
            <summary>
            The default value used in creating new lumens (must be even).
            </summary>
        </member>
        <member name="P:Claron.WIF.Lumen.LongitudinalsCount">
            <summary>
            The number of angular sampling increments per PI radians through the lumen
            used in wall descriptors. Must be even (to accommodate ribbon displays).
            </summary>
        </member>
        <member name="P:Claron.WIF.Lumen.LatitudinalsCount">
            <summary>
            The number of latitudinals (= centerline samples count)
            </summary>
        </member>
        <member name="P:Claron.WIF.Lumen.IsInnerWallDefined">
            <summary>
            Indicates whether an inner wall descriptor exists
            </summary>
        </member>
        <member name="P:Claron.WIF.Lumen.IsOuterWallDefined">
            <summary>
            Indicates whether an outer wall descriptor exists
            </summary>
            <returns></returns>
        </member>
        <member name="P:Claron.WIF.Lumen.IsAnyWallDefined">
            <summary>
            Indicates whether either an inner or an outer wall descriptor exists
            </summary>
            <returns></returns>
        </member>
        <member name="P:Claron.WIF.Lumen.InnerRadiiPatch">
            <summary>
            Returns the inner lumen radii patch.
            </summary>
        </member>
        <member name="P:Claron.WIF.Lumen.OuterRadiiPatch">
            <summary>
            Returns the outer lumen radii patch.
            </summary>
        </member>
        <member name="P:Claron.WIF.Lumen.DebugLmnIdx">
            <summary> Global property for enabling debug data collection,
            i.e. log info, ing write out or BitVol write out
            (even in release mode) </summary>
        </member>
        <member name="T:Claron.WIF.Lumen.WallSample">
            <summary>
            Description of a single sample point on a tubular wall structure
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Lumen.WallSample.RadiusMm">
            <summary>
            Distance from the centerline
            </summary>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Lumen.WallSample.Origin">
            ' <summary>
            ' The source of the wall sample (how it was set)
            ' </summary>
        </member>
        <member name="T:Claron.WIF.Lumen.Wall">
            <summary>
            A complete tubular wall structure.
            Designed to be used in parallel to the array of SpaceMappers of the Lumen class
            which give the local coordinate system for each center point
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Lumen.Wall._ws">
            <summary> The array of WallSample containing radiiMm from center for each roll angle and each center point.</summary>
        </member>
        <member name="F:Claron.WIF.Lumen.Wall._centersCnt">
            <summary> The count of centers. (Latitudinals count)</summary>
        </member>
        <member name="F:Claron.WIF.Lumen.Wall._rollAnglCnt">
            <summary> The count of roll angles. (Longitudinals count)</summary>
        </member>
        <member name="M:Claron.WIF.Lumen.Wall.WallSampleGet(System.Int32,System.Int32)">
            <summary>
            The count of roll angles.
            </summary>
            <param name="centerI"></param>
            <param name="rollAngleI"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.Wall.WallSampleSet(System.Int32,System.Int32,Claron.WIF.Lumen.WallSample)">
            <summary>
            The count of roll angles.
            </summary>
            <param name="centerI"></param>
            <param name="rollAngleI"></param>
            <param name="ws"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.Wall.#ctor(Claron.WIF.Lumen.WallSample[],System.Int32,System.Int32)">
            <summary>
            Initializes a Wall structure.
            No memory is allocated, only references set to an already existing WallSample array
            </summary>
            <param name="wallSampleArray"></param>
            <param name="centersCnt">The count of centers. (Latitudinals count)</param>
            <param name="rollAnglCnt">The count of roll angles. (Longitudinals count)</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.Wall.OriginInit(Claron.WIF.Lumen.WallSample.WallSampleOrigin)">
            <summary>
            initializes all WallSampleOrigin values in the wall to the given value
            </summary>
            <param name="origin"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Lumen.Wall.RadiiReplicateEdgeValues">
            <summary>
            Fills the first two and last two radii sets with the values from the 3rd and 3rd last set.
            </summary>
        </member>
        <member name="M:Claron.WIF.Lumen.Wall.RadiiFixOutliersSlidingWindowStdDevAndCurvature(System.Double)">
            <summary>
            fix outrageous outliers and limit curvature adaptively
            </summary>
            <param name="smoothness">in range [0.5, 2] the larger the smoother the result</param>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Lumen.Wall.CentersCnt">
            <summary> The count of centers. (Latitudinals count)</summary>
        </member>
        <member name="P:Claron.WIF.Lumen.Wall.CentersMaxI">
            <summary> The max index along the centers.</summary>
        </member>
        <member name="P:Claron.WIF.Lumen.Wall.RollAnglCnt">
            <summary> The count of roll angles. (Longitudinals count)</summary>
        </member>
        <member name="P:Claron.WIF.Lumen.Wall.RollAnglMaxI">
            <summary> The max index along the roll angles.</summary>
        </member>
        <member name="M:Claron.WIF.Lumen.WallCrossSectionStats.InBetween(Claron.WIF.Lumen.WallCrossSectionStats,System.Double)">
            <summary>
            Return interpolated stats between me and the other stats sample
            </summary>
        </member>
        <member name="F:Claron.WIF.Lumen.WallTypes.Inner">
            <summary> Inner wall type </summary>
        </member>
        <member name="F:Claron.WIF.Lumen.WallTypes.Outer">
            <summary> Outer wall type </summary>
        </member>
        <member name="T:Claron.WIF.Lumen.LumenLengthComparer">
            <summary>
            Compares lumen lengths.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.LumenWallPatch._nLats">
            <summary>
            The number of latitudes.
            </summary>
        </member>
        <member name="F:Claron.WIF.LumenWallPatch._nLngs">
            <summary>
            The number of longitudes.
            </summary>
        </member>
        <member name="F:Claron.WIF.LumenWallPatch._radii">
            <summary>
            The lumen radii defining the lumen wall.
            </summary>
        </member>
        <member name="F:Claron.WIF.LumenWallPatch._Length">
            <summary>
            The length of the lumen.
            </summary>
        </member>
        <member name="F:Claron.WIF.LumenWallPatch._CR">
            <summary>
            Lookup table for the Catmull-Rom spline basis functions.
            </summary>
        </member>
        <member name="M:Claron.WIF.LumenWallPatch.#ctor(System.Int32,System.Int32,System.Double)">
            <summary>
            Creates a new lumen patch.
            </summary>
            <param name="nLngs">The number of longitudes.</param>
            <param name="nLats">The number of latitudes.</param>
            <param name="length">The length of the lumen.</param>
        </member>
        <member name="M:Claron.WIF.LumenWallPatch.InitializeLookupTables">
            <summary>
            Initializes the lookup tables.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.LumenWallPatch.OnDeserializedMethod(System.Runtime.Serialization.StreamingContext)">
            <summary>
            Called after the class has been deserialized.
            </summary>
        </member>
        <member name="M:Claron.WIF.LumenWallPatch.InterpolateRadiusLngLat(System.Double,System.Double,System.Double@)">
            <summary>
            Interpolates the radius at the given longitude and latitude.
            </summary>
        </member>
        <member name="M:Claron.WIF.LumenWallPatch.InterpolateRadiusDistAng(System.Double,System.Double,System.Double@)">
            <summary>
            Interpolates the radius at the given distance along the length of the lumen and the angle.
            </summary>
        </member>
        <member name="P:Claron.WIF.LumenWallPatch.LatitudinalsCount">
            <summary>
            The latitudinals count.
            </summary>
        </member>
        <member name="P:Claron.WIF.LumenWallPatch.LongitudinalsCount">
            <summary>
            The longitudinals count.
            </summary>
            <value></value>
        </member>
        <member name="P:Claron.WIF.LumenWallPatch.Radii">
            <summary>
            Returns the radii at the control points.
            </summary>
        </member>
        <member name="P:Claron.WIF.LumenWallPatch.Length">
            <summary>
            The length of the lumen.
            </summary>
        </member>
        <member name="P:Claron.WIF.LumenWallPatch.LatitudeSpacingMm">
            <summary>
            Returns the spacing in mm between latitudes.
            </summary>
        </member>
        <member name="P:Claron.WIF.LumenWallPatch.LongitudeSpacingRad">
            <summary>
            Returns the longitude spacing in radians.
            </summary>
        </member>
        <member name="P:Claron.WIF.ColormapPostWindowed.Name">
            <summary>
            default UI name from file
            </summary>
        </member>
        <member name="P:Claron.WIF.ColormapPostWindowed.ID">
            <summary>
            ID, can be used for transaltion
            </summary>
        </member>
        <member name="P:Claron.WIF.ColormapPostWindowed.ArgbData">
            <summary>
            ARGB 256 entries colormap
            </summary>
        </member>
        <member name="T:Claron.WIF.ColormapsPostWindowed">
            <summary>
            allows loading from WIFRootPath\DataTypes\Resources\ColormapsPostWindowed.xml a set of color pallettes
            the "ArgbData" property of an individual colormap can be applied to Camera's ColormapPostWindowed property to obtain a colormapped (windowed) image.
            Used by pet/nm modalities
            </summary>
        </member>
        <member name="T:Claron.WIF.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Claron.WIF.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Claron.WIF.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Claron.WIF.Properties.Resources.CT_Abdomen_D1">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;RenderingPreset xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
              &lt;LastUpdateTicks&gt;1293756&lt;/LastUpdateTicks&gt;
              &lt;UID&gt;1.2.826.0.1.3680043.214.334726925006853008511497746535267209962&lt;/UID&gt;
              &lt;OpacityPoints&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0.234188035&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSing [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Claron.WIF.Properties.Resources.CT_Abdomen_D2">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;RenderingPreset xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
              &lt;LastUpdateTicks&gt;4042513&lt;/LastUpdateTicks&gt;
              &lt;UID&gt;1.2.826.0.1.3680043.214.156853892184396688012428916269289555144&lt;/UID&gt;
              &lt;OpacityPoints&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0.264224678&lt;/Value&gt;
                  &lt;Data&gt;0.0215827338&lt;/Data&gt;
                &lt;/Control [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Claron.WIF.Properties.Resources.CT_Bones_Default">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;RenderingPreset xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
              &lt;LastUpdateTicks&gt;327737&lt;/LastUpdateTicks&gt;
              &lt;UID&gt;1.2.826.0.1.3680043.214.37137910399069401111816572074052956320&lt;/UID&gt;
              &lt;OpacityPoints&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0.262515277&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Claron.WIF.Properties.Resources.CT_Bones_Hard_surface">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;RenderingPreset xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
              &lt;LastUpdateTicks&gt;986862&lt;/LastUpdateTicks&gt;
              &lt;UID&gt;1.2.826.0.1.3680043.214.156791359338781927229324162413898617653&lt;/UID&gt;
              &lt;OpacityPoints&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0.252258867&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingl [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Claron.WIF.Properties.Resources.CT_Bones_Softer">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;RenderingPreset xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
              &lt;LastUpdateTicks&gt;501570&lt;/LastUpdateTicks&gt;
              &lt;UID&gt;1.2.826.0.1.3680043.214.1233648345380128422310313599023668761782&lt;/UID&gt;
              &lt;OpacityPoints&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0.258608073&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSing [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Claron.WIF.Properties.Resources.CT_Bones_Softer2">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;RenderingPreset xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
              &lt;LastUpdateTicks&gt;429662&lt;/LastUpdateTicks&gt;
              &lt;UID&gt;1.2.826.0.1.3680043.214.154676693662087618010718914957224986995&lt;/UID&gt;
              &lt;OpacityPoints&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0.258608073&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingl [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Claron.WIF.Properties.Resources.CT_Cardiac_D2">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;RenderingPreset xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
              &lt;LastUpdateTicks&gt;4042511&lt;/LastUpdateTicks&gt;
              &lt;UID&gt;1.2.826.0.1.3680043.214.1832987575948373449113683512891339206100&lt;/UID&gt;
              &lt;OpacityPoints&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0.260073274&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSin [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Claron.WIF.Properties.Resources.CT_Cardiac_Default">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;RenderingPreset xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
              &lt;LastUpdateTicks&gt;2757313&lt;/LastUpdateTicks&gt;
              &lt;UID&gt;1.2.826.0.1.3680043.214.27185738271701631312456216357025649973&lt;/UID&gt;
              &lt;OpacityPoints&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0.2517156&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle&gt; [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Claron.WIF.Properties.Resources.CT_Cardiac_Thick_coronaries">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;RenderingPreset xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
              &lt;LastUpdateTicks&gt;4042473&lt;/LastUpdateTicks&gt;
              &lt;UID&gt;1.2.826.0.1.3680043.214.776326124451510769113441540661184203598&lt;/UID&gt;
              &lt;OpacityPoints&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0.161660567&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSing [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Claron.WIF.Properties.Resources.CT_Chest_Default">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;RenderingPreset xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
              &lt;LastUpdateTicks&gt;1548986&lt;/LastUpdateTicks&gt;
              &lt;UID&gt;1.2.826.0.1.3680043.214.1674595948553773401411362514719216617329&lt;/UID&gt;
              &lt;OpacityPoints&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0.06178266&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSing [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Claron.WIF.Properties.Resources.CT_Chest_Lungs">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;RenderingPreset xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
              &lt;LastUpdateTicks&gt;857568&lt;/LastUpdateTicks&gt;
              &lt;UID&gt;1.2.826.0.1.3680043.214.783592691635757168812845141345730562379&lt;/UID&gt;
              &lt;OpacityPoints&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0.0446886458&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSing [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Claron.WIF.Properties.Resources.CT_Chest_VBR">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;RenderingPreset xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
              &lt;LastUpdateTicks&gt;921296&lt;/LastUpdateTicks&gt;
              &lt;UID&gt;1.2.826.0.1.3680043.214.151567434839923922849915962277183894214&lt;/UID&gt;
              &lt;OpacityPoints&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0.01904762&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Claron.WIF.Properties.Resources.CT_Chest_VBR_2">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;RenderingPreset xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
              &lt;LastUpdateTicks&gt;4042526&lt;/LastUpdateTicks&gt;
              &lt;UID&gt;1.2.826.0.1.3680043.214.1398510760317290309011923962711492451082&lt;/UID&gt;
              &lt;OpacityPoints&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0.0227106232&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSi [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Claron.WIF.Properties.Resources.CT_CTA_D4">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;RenderingPreset xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
              &lt;LastUpdateTicks&gt;3221040&lt;/LastUpdateTicks&gt;
              &lt;UID&gt;1.2.826.0.1.3680043.214.1083633502883081581412420509450492359489&lt;/UID&gt;
              &lt;OpacityPoints&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0.230036631&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSin [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Claron.WIF.Properties.Resources.CT_CTA_Default">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;RenderingPreset xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
              &lt;LastUpdateTicks&gt;4250098&lt;/LastUpdateTicks&gt;
              &lt;UID&gt;1.2.826.0.1.3680043.214.1147199464490764195710170937703387579209&lt;/UID&gt;
              &lt;OpacityPoints&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0.253724784&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSin [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Claron.WIF.Properties.Resources.CT_CTA_Hard_vessels">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;RenderingPreset xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
              &lt;LastUpdateTicks&gt;5760131&lt;/LastUpdateTicks&gt;
              &lt;UID&gt;1.2.826.0.1.3680043.214.79622410267920200412700909408186669425&lt;/UID&gt;
              &lt;OpacityPoints&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0.267870247&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingl [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Claron.WIF.Properties.Resources.CT_CTA_Head_vessels">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;RenderingPreset xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
              &lt;LastUpdateTicks&gt;6175006&lt;/LastUpdateTicks&gt;
              &lt;UID&gt;1.2.826.0.1.3680043.214.90019020730513921312684085930722473110&lt;/UID&gt;
              &lt;OpacityPoints&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0.259598464&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingl [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Claron.WIF.Properties.Resources.CT_CTA_Vessels">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;RenderingPreset xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
              &lt;LastUpdateTicks&gt;4042549&lt;/LastUpdateTicks&gt;
              &lt;UID&gt;1.2.826.0.1.3680043.214.835936487043355528212752528656943955634&lt;/UID&gt;
              &lt;OpacityPoints&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0.258852273&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSing [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Claron.WIF.Properties.Resources.CT_CTA_VesselsWithCalc">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;RenderingPreset xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
              &lt;LastUpdateTicks&gt;5564609&lt;/LastUpdateTicks&gt;
              &lt;UID&gt;1.2.826.0.1.3680043.214.1560589929009232358812763072284602955865&lt;/UID&gt;
              &lt;OpacityPoints&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0.265384376&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSin [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Claron.WIF.Properties.Resources.CT_CTA_Yellowish">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;RenderingPreset xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
              &lt;LastUpdateTicks&gt;4499771&lt;/LastUpdateTicks&gt;
              &lt;UID&gt;1.2.826.0.1.3680043.214.228183790746686486312524327622099463065&lt;/UID&gt;
              &lt;OpacityPoints&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0.2568941&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Claron.WIF.Properties.Resources.CT_General_BoneThresh">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;RenderingPreset xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
              &lt;LastUpdateTicks&gt;1589244&lt;/LastUpdateTicks&gt;
              &lt;UID&gt;1.2.826.0.1.3680043.214.809884553610941469613016133154575120461&lt;/UID&gt;
              &lt;OpacityPoints&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0.2843261&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Claron.WIF.Properties.Resources.CT_General_D2">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;RenderingPreset xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
              &lt;LastUpdateTicks&gt;657311&lt;/LastUpdateTicks&gt;
              &lt;UID&gt;1.2.826.0.1.3680043.214.158204288740545502111072546006580628507&lt;/UID&gt;
              &lt;OpacityPoints&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0.0412698425&lt;/Value&gt;
                  &lt;Data&gt;0.007194245&lt;/Data&gt;
                &lt;/ControlP [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Claron.WIF.Properties.Resources.CT_General_Def3">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;RenderingPreset xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
              &lt;LastUpdateTicks&gt;278598&lt;/LastUpdateTicks&gt;
              &lt;UID&gt;1.2.826.0.1.3680043.214.28224959129722756289813280558511068419&lt;/UID&gt;
              &lt;OpacityPoints&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0.190054089&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Claron.WIF.Properties.Resources.CT_General_Default">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;RenderingPreset xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
              &lt;LastUpdateTicks&gt;980&lt;/LastUpdateTicks&gt;
              &lt;UID&gt;1.2.826.0.1.3680043.214.197464370613225138013610407665878637599&lt;/UID&gt;
              &lt;OpacityPoints&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0.257142872&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle&gt;
             [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Claron.WIF.Properties.Resources.CT_Vessels_Default">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;RenderingPreset xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
              &lt;LastUpdateTicks&gt;4042574&lt;/LastUpdateTicks&gt;
              &lt;UID&gt;1.2.826.0.1.3680043.214.1498753952215264745012583239085416547903&lt;/UID&gt;
              &lt;OpacityPoints&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0.2813187&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingl [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Claron.WIF.Properties.Resources.CT_Vessels_Hard_vessels">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;RenderingPreset xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
              &lt;LastUpdateTicks&gt;4042540&lt;/LastUpdateTicks&gt;
              &lt;UID&gt;1.2.826.0.1.3680043.214.1133820074386196318612167412097435523222&lt;/UID&gt;
              &lt;OpacityPoints&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0.2732601&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingl [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Claron.WIF.Properties.Resources.CT_Vessels_Stent">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;RenderingPreset xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
              &lt;LastUpdateTicks&gt;4042554&lt;/LastUpdateTicks&gt;
              &lt;UID&gt;1.2.826.0.1.3680043.214.106263346067657643611346394294123309145&lt;/UID&gt;
              &lt;OpacityPoints&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0.264713079&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSing [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Claron.WIF.Properties.Resources.CT_Vessels_Vessels">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;RenderingPreset xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
              &lt;LastUpdateTicks&gt;4042484&lt;/LastUpdateTicks&gt;
              &lt;UID&gt;1.2.826.0.1.3680043.214.1637654311143140889513131450856978992061&lt;/UID&gt;
              &lt;OpacityPoints&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0.258852273&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSin [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Claron.WIF.Properties.Resources.US_General_Default">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;RenderingPreset xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
              &lt;LastUpdateTicks&gt;1177716&lt;/LastUpdateTicks&gt;
              &lt;UID&gt;1.2.826.0.1.3680043.214.1484011238250435766613241843244157678210&lt;/UID&gt;
              &lt;OpacityPoints&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle&gt;
                &lt;ControlPointOfSingle&gt;
                  &lt;Value&gt;0.317647&lt;/Value&gt;
                  &lt;Data&gt;0&lt;/Data&gt;
                &lt;/ControlPointOfSingle [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="T:Claron.WIF.RenderingPreset">
             <summary>
             The RenderingPreset class represents a configuration of a subset of the Camera class properties
             optimized for a particular type of acquisition (anatomy, modality, etc.).
            
             The main property managed by a RenderingPreset is the transfer function mapping between
             modality values and 4x8b ARGB (opacity/alpha + red, green, blue color).
             The opacity and color mappings are described using control points in normalized
             ranges (input and output values from 0 to 1): OpacityPoints and ColorPoints.
             They two function are exported together as a 12->32b look-up table
             for mapping stored values of a specific SliceStack, using piecewise linear
             interpolation between the control points (see UpdateArgbLut()).
            
             To allow easy interactive tweaking of the transfer function, two easy tweaking parameters
             are provided, named ValueShift and OpacityScale. ValueShift shifts the color and opacity
             curves to a higher or lower modality value range, while the OpacityScale reduces or increases
             the opacity of the whole curve, making object appear more or less transparent without changing
             their relative opacity and their color.
            
             RenderingPresets are designed to be persisted, classified by modality
             and study type (anatomy/application). This allows the application to provide users with a fast
             and easy method for applying presets matching the data being viewed, thus simplifying the UI.
             By default, the presets are persisted as resources in this class's assembly and are obtained
             from the assembly itself. Once a preset is modified, it is stored back (and later retrieved)
             in a file in a presents directory. The path of the presets directory is set to be the UI
             assembly's resources directory of one exists (ie, during development), or to a folder
             in the application all-users data directory.
             
             The RenderingPresest of a special "Windowing" category are used for non-linear windowing, 
             rather than for rendering, control. In this case, the opacity transfer function is used for
             mapping to grey levels (0-255) instead, and the tweaking is done by ValueShift 
             (= Windowing Center) and ValueExpand around the middle control point (= Windowing Width).
             
             </summary>
        </member>
        <member name="M:Claron.WIF.RenderingPreset.TweakingModifiersReset">
            <summary>
            Resets ValueShift, ValueScale and OpacityScale to their default (untweaked)
            settings.
            </summary>
        </member>
        <member name="M:Claron.WIF.RenderingPreset.OpacityPointsSetToRamp(System.Double,System.Double)">
            <summary>
            Updates the opacity curve to a simple ramp according to the given wc/ww parameters.
            </summary>
            <param name="wcNormalized01">0 at beginning of modality value range, 1 at end of range</param>
            <param name="wwNormalized01">0 for step function, 1 for whole modality value range.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.RenderingPreset.ModalityToNormalized(System.Double,System.Double,System.Double)">
            <summary>
            Converts a modality value to a normalized, 0 to 1, value
            </summary>
        </member>
        <member name="M:Claron.WIF.RenderingPreset.NormalizedToModality(System.Double,System.Double,System.Double)">
            <summary>
            Converts a normalized modality value to a modality value
            </summary>
        </member>
        <member name="M:Claron.WIF.RenderingPreset.#ctor(System.UInt32[],System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:Claron.WIF.RenderingPreset"/> given a LUT
            </summary>
            <param name="ARGBLUT">The LUT values to create the control points from</param>
            <param name="name">A preset name</param>
            <param name="category">The category</param>
            <param name="modality">Modality</param>
        </member>
        <member name="M:Claron.WIF.RenderingPreset.#ctor(System.String,System.Collections.Generic.IList{Claron.WIF.ControlPoint{System.Single}},System.Collections.Generic.IList{Claron.WIF.ControlPoint{Claron.WIF.RgbTriad}},System.String,System.String)">
            <summary>
            Create a new preset by specifying a name (+ modality and category) and transfer functions
            (note normalized, ie, [0,1], values)
            </summary>
            <param name="name">The name of the preset</param>
            <param name="opacityData">A list of opacity control points. Must contain at least two points.</param>
            <param name="colorData">A list of color control points. Must contain at least two points.</param>
            <param name="Modality"></param>
            <param name="Category"></param>
        </member>
        <member name="M:Claron.WIF.RenderingPreset.SetAs(Claron.WIF.RenderingPreset)">
            <summary>
            Sets the properties of this camera to the same values as another.
            Input objects that may be shared with other cameras are not copied, only their references.
            </summary>
            <remarks>Temporary buffers are cleared/erased</remarks>
        </member>
        <member name="M:Claron.WIF.RenderingPreset.#ctor(System.String,System.Int32,System.Int32,System.String,System.String)">
            <summary>
            Create a new named preset for CT with a simple ramp transfer function
            </summary>
            <param name="name">The name of the preset</param>
            <param name="RampBgnHU">The HU value (MinValue..MaxValue - 1) of the opacity ramp's start (opacity=0)</param>
            <param name="RampEndHU">The HU value (RampStartHU+1..MaxValue) of the opacity ramp's end (opacity=1)</param>
            <param name="Modality"></param>
            <param name="Category"></param>
        </member>
        <member name="M:Claron.WIF.RenderingPreset.#ctor(System.String,System.Double,System.Double,System.String,System.String)">
            <summary>
            Create a new named preset for CT with a simple ramp transfer function
            </summary>
            <param name="name">The name of the preset</param>
            <param name="RampBgn01">The range [0,1] value of the opacity ramp's begin (opacity=0)</param>
            <param name="RampEnd01">The range [0,1] value of the opacity ramp's end (opacity=1)</param>
            <param name="Modality"></param>
            <param name="Category"></param>
        </member>
        <member name="M:Claron.WIF.RenderingPreset.Load(System.String,System.String,System.String)">
            <summary>
            Loads a preset with a specified modality, category and name from the presets directory
            </summary>
            <remarks>
            Immediately after calling this method the Unsaved property will return false.
            </remarks>
            <returns>The loaded preset, or Nothing, if failed.</returns>
        </member>
        <member name="M:Claron.WIF.RenderingPreset.Load(System.String)">
            <summary>
            Loads a preset from file if it exists, otherwise looks in the DLL for a matching resource.
            </summary>
            <remarks>
            Immediately after calling this method the Unsaved property will return false.
            </remarks>
            <param name="presetFileNameNoPathNoExtension">name of the preset file name to be loaded, without the path, with or without .xml extension</param>
            <returns>The loaded preset, or Nothing, if failed.</returns>
        </member>
        <member name="M:Claron.WIF.RenderingPreset.LoadEmbedded(System.String,System.String,System.String)">
            <summary>
            Loads a preset from embedded resources (compiled xml file)
            </summary>
            <remarks>
            Immediately after calling this method the Unsaved property will return false.
            </remarks>
            <param name="Name">The name of the preset to be loaded</param>
            <param name="Category">The category of the preset</param>
            <param name="Modality">The 2-letter modality string (see ModalityEnum), eg, "CT"</param>
            <returns>The loaded preset, or Nothing, if failed.</returns>
        </member>
        <member name="F:Claron.WIF.RenderingPreset._loadEmbeddedResourceNotFound">
            <summary>
            Only produce the warning once as it is not possible to recover programmatically
            from the error condition.
            </summary>
        </member>
        <member name="M:Claron.WIF.RenderingPreset.LoadEmbedded(System.String)">
            <summary>
            Loads a preset from embedded resources (compiled xml file).
            If the preset doesn't exist or is badly formatted, it will throw an exception.
            </summary>
            <remarks>
            Immediately after successfully executing this method, the Unsaved property will return false.
            </remarks>
            <param name="FileName">The file name of the preset to be loaded</param>
            <returns>The loaded preset.</returns>
        </member>
        <member name="M:Claron.WIF.RenderingPreset.PresetsInCategory(System.String,System.String)">
            <summary>
            Returns all the presets in the given category sorted by name
            </summary>
        </member>
        <member name="M:Claron.WIF.RenderingPreset.PresetCategories(System.String)">
            <summary>
            Returns an alphabetically sorted list of all the preset categories for a given modality.
            The category "Windowing" is hidden.
            </summary>
        </member>
        <member name="M:Claron.WIF.RenderingPreset.PresetCategories(System.String,System.String)">
            <summary>
            Returns an alphabetically sorted list of all the preset categories for a given modality.
            The category "Windowing" is hidden.
            </summary>
        </member>
        <member name="M:Claron.WIF.RenderingPreset.FileExists(System.String)">
            <summary>
            Return True iff a file for this preset already exists in the given folder
            </summary>
        </member>
        <member name="M:Claron.WIF.RenderingPreset.Save(System.String,System.String,System.String)">
            <summary>
            Saves the preset to the file [modality]_[category]_[name] in the PresetsDirPath directory.
            The modality, category and name become the current properties of this preset.
            Overwrites any file that might be present at the same implied path.
            </summary>
            <param name="modality"></param>
            <param name="category">The category in which to save the preset</param>
            <param name="name">The name under which to save the preset. Underscores are
            reserved, and will be silently replaced by blanks</param>
            <remarks>
            Immediately after calling this method the Unsaved property will return false.
            </remarks>
        </member>
        <member name="M:Claron.WIF.RenderingPreset.Save(System.String)">
            <summary>
            Saves the preset to a file.
            Overwrites any existing file with the same path.
            </summary>
            <param name="fullPath">The full path of the file to be written (or over-written)</param>
            <remarks>Immediately after calling this method the Unsaved property will return false.</remarks>
        </member>
        <member name="M:Claron.WIF.RenderingPreset.Save(System.String,System.String)">
            <summary>
            Tweaked points are set as the "original" points and tweaking modifiers are reset,
            then the preset is saved to a file. 
            Overwrites any existing file with the same path.
            </summary>
            <param name="fullPath">The full path of the file to be written (or over-written)</param>
            <param name="collageStatePath">path of the Collage state saving folder, where the current preset
            will be saved. This used only in client/server mode collage state saving.</param>
            <remarks>Immediately after calling this method the Unsaved property will return false.</remarks>
        </member>
        <member name="M:Claron.WIF.RenderingPreset.OpacityPointsSetToSolid">
            <summary>
            Sets the opacity points so that all values in the transfer function will appear
            solid (no transparency).
            </summary>
        </member>
        <member name="M:Claron.WIF.RenderingPreset.UpdateArgbLut(System.UInt32[]@,System.Int16,System.Int16)">
            <summary>
            Updates a look-up table (LUT) from stored value to ARGB (32b) opacity/color values
            based on the current transfer functions (color and opacity) state. 
            </summary>
            <param name="ARGBLUT">The pre-allocated LUT to update - all its entries will be set.</param>
            <param name="StoredValueRangeMin">The stored value corresponding to normalized value 0. Usually obtained from SliceStack. </param>
            <param name="StoredValueRangeMax">The stored value corresponding to normalized value 1. Usually obtained from SliceStack. </param>
            <remarks>Table entries with indexes that map below the first control point
            get the same ARGB as for the first control point. Similarly for entries mapped to normalized values
            higher than the last control point.</remarks>
        </member>
        <member name="M:Claron.WIF.RenderingPreset.UpdateWindowingLut(System.UInt32[]@,System.Int16,System.Int16)">
            <summary>
            Updates a windowing look-up table (LUT) from stored value to ARGB (32b) color values
            based on the current transfer functions (color and opacity) state. Opacity is set to
            fully opaque, and the RGB values are the color curve values attenuated by the opacity
            values (so use a uniform white color curve to get gray-level windowing).
            </summary>
            <param name="ARGBLUT">The pre-allocated LUT to update - all its entries will be set.</param>
            <param name="StoredValueRangeMin">The stored value corresponding to normalized value 0. Usually obtained from SliceStack. </param>
            <param name="StoredValueRangeMax">The stored value corresponding to normalized value 1. Usually obtained from SliceStack. </param>
            <remarks>Table entries with indexes that map below the first control point
            get the same ARGB as for the first control point. Similarly for entries mapped to normalized values
            higher than the last control point.</remarks>
        </member>
        <member name="P:Claron.WIF.RenderingPreset.ValueShift">
            <summary>
            A tweaking factor which shifts the transfer function (both color and opacity)
            up or down by a given normalized (0 to 1) delta value
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.RenderingPreset.ValueScaleCenteredOnMaxSlope">
            <summary>
            A tweaking control which determines whether the value scale expansion/contraction
            is done around the location of maximum curve slope or (if false) around the origin (0).
            Usually it is set to true when doing non-linear windowing, and to false when doing shaded
            rendering tweaking.
            </summary>
        </member>
        <member name="P:Claron.WIF.RenderingPreset.ValueScale">
            <summary>
            Value scale emulates "width" of windowing by expanding/contracting the
            values around the value which changes the fastest (the center of the line segment with the
            steepest slope).
            </summary>
        </member>
        <member name="P:Claron.WIF.RenderingPreset.OpacityScale">
            <summary>
            A tweaking factor applied to the opacity values in the transfer function.
            To ensure a "reasonable" modification and prevent excessive rendering times
            at low opacities, it is clamped to the range 0.5..3.0.
            </summary>
        </member>
        <member name="P:Claron.WIF.RenderingPreset.OpacitySupersamplingFactor">
            <summary>
            The ratio of sampling rate to the default rate (higher -> shorter sampling interval) to 
            correct the conversion to ARGB for an increased frequency of sampling along each ray 
            (super-sampling).
            </summary>
        </member>
        <member name="P:Claron.WIF.RenderingPreset.BackgroundARGB">
            <summary>
            Gets or sets the background color of the rendered image
            </summary>
        </member>
        <member name="P:Claron.WIF.RenderingPreset.GlassFxColor">
            <summary>
            Gets or sets the color and opacity of the Glass FX layer
            </summary>
        </member>
        <member name="P:Claron.WIF.RenderingPreset.RandomColorNoiseAmplitude">
            <summary>
            Indicates the amount (0-100, clamped) of random additions to the three color channels in the exported
            color table, designed to make the 3D image appear more "natural". The additions are distributed
            using noise having a Gaussian distribution with the given amplitude STD.
            </summary>
        </member>
        <member name="P:Claron.WIF.RenderingPreset.HeadLightIntensity">
            <summary>
            Gets or sets the HeadLightIntensity value
            </summary>
            <remarks>
            If this property is modified directly while the preset is being displayed in a
            PresetEditor control, you must set the CurrentPreset property of the PresetEditor control
            immediately afterwards. Not doing so will result in the PresetEditor control being out of date
            </remarks>
        </member>
        <member name="P:Claron.WIF.RenderingPreset.ShadowStrength0to1IsoSurface">
            <summary>
            Determines the strength (amount of darkening) of penumbra shadows to be added to the image in
            Isosurface mode. If 0, no shadows are cast.
            </summary>
        </member>
        <member name="P:Claron.WIF.RenderingPreset.ShadowStrength0to1Shaded">
            <summary>
            Determines the strength (amount of darkening) of penumbra shadows to be added to the image in
            Isosurface mode. If 0, no shadows are cast.
            </summary>
        </member>
        <member name="P:Claron.WIF.RenderingPreset.ShadowCastingMaxRadiusPixels">
            <summary>
            Determines the radius, in image pixel units, over which shadow casting is computed.
            Shadow computation time increases with the square of this value.
            </summary>
        </member>
        <member name="P:Claron.WIF.RenderingPreset.AmbientLightIntensity">
            <summary>
            Gets or sets the AmbientLightIntensity
            </summary>
            <remarks>
            If this property is modified directly while the preset is being displayed in a
            PresetEditor control, you must set the CurrentPreset property of the PresetEditor control
            immediately afterwards. Not doing so will result in the PresetEditor control being out of date
            </remarks>
        </member>
        <member name="P:Claron.WIF.RenderingPreset.Shininess">
             <summary>
             Gets or sets the Shininess
             </summary>
             <remarks>
             If this property is modified directly while the preset is being displayed in a
             PresetEditor control, you must set the CurrentPreset property of the PresetEditor control
             immediately afterwards. Not doing so will result in the PresetEditor control being out of date
             </remarks>
            
        </member>
        <member name="P:Claron.WIF.RenderingPreset.ShadingEnhancement">
            <summary>
            Gets or sets the amount of enhancement of the shading
            </summary>
            <remarks>
            If this property is modified directly while the preset is being displayed in a
            PresetEditor control, you must set the CurrentPreset property of the PresetEditor control
            immediately afterwards. Not doing so will result in the PresetEditor control being out of date
            </remarks>
        </member>
        <member name="P:Claron.WIF.RenderingPreset.ValueOfInterest">
            <summary>
            The value of interest is used by the editor to mark the center of the
            magnified region in the value range, where the user last edited the curve.
            </summary>
            <value></value>
        </member>
        <member name="P:Claron.WIF.RenderingPreset.Modality">
            <summary>
            Gets the modality of the preset (set when created) as a 2-letter string (see ModalityEnum)
            </summary>
        </member>
        <member name="P:Claron.WIF.RenderingPreset.Category">
            <summary>
            Gets the category of the preset (set when created)
            </summary>
        </member>
        <member name="P:Claron.WIF.RenderingPreset.Name">
            <summary>
            Gets the name of the preset (set when created)
            </summary>
        </member>
        <member name="P:Claron.WIF.RenderingPreset.Unsaved">
            <summary>
            Gets whether the preset has been modified since it was last saved or loaded
            </summary>
        </member>
        <member name="P:Claron.WIF.RenderingPreset.FromFile">
            <summary>
            Returns true if the preset has been loaded from or saved to a file. Returns false
            if the preset is newly created.
            </summary>
        </member>
        <member name="F:Claron.WIF.ControlPointCollection`1.OriginalValueScaleCenter">
            <summary>
            The (original) value around which ValueScale expands/contracts
            </summary>
        </member>
        <member name="M:Claron.WIF.ControlPointCollection`1.Original(System.Int32)">
            <summary>
            Returns the indexed control point before tweaking.
            </summary>
        </member>
        <member name="P:Claron.WIF.ControlPointCollection`1.ValueScale">
            <summary>
            Value scale emulates "width" of windowing by expanding/contracting the
            values around the value which changes the fastest (the center of the line segment with the
            steepest slope).
            </summary>
        </member>
        <member name="P:Claron.WIF.ControlPointCollection`1.Item(System.Int32)">
            <summary>
            Returns the tweaked value of the item, and sets both the original and the
            </summary>
            <param name="index"></param>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.ControlPoint`1.Value">
            <summary>
            Normalized voxel value (0 to 1)
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.RgbTriad.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Constructor from three [0,1] range RGB values.
            </summary>
            <param name="r0to1">Red in range [0,1]</param>
            <param name="g0to1">Green in range [0,1]</param>
            <param name="b0to1">Blue in range [0,1]</param>
        </member>
        <member name="F:Claron.WIF.RgbTriad._r">
            <summary>Red in range [0,1]</summary>
        </member>
        <member name="F:Claron.WIF.RgbTriad._g">
            <summary>Green in range [0,1]</summary>
        </member>
        <member name="F:Claron.WIF.RgbTriad._b">
            <summary>Blue in range [0,1]</summary>
        </member>
        <member name="P:Claron.WIF.RgbTriad.Red">
            <summary>Red in range [0,1]</summary>
        </member>
        <member name="P:Claron.WIF.RgbTriad.Green">
            <summary>Green in range [0,1]</summary>
        </member>
        <member name="P:Claron.WIF.RgbTriad.Blue">
            <summary>Blue in range [0,1]</summary>
        </member>
        <member name="F:Claron.WIF.RgbaQuad._r">
            <summary>Red in range [0,1]</summary>
        </member>
        <member name="F:Claron.WIF.RgbaQuad._g">
            <summary>Green in range [0,1]</summary>
        </member>
        <member name="F:Claron.WIF.RgbaQuad._b">
            <summary>Blue in range [0,1]</summary>
        </member>
        <member name="F:Claron.WIF.RgbaQuad._a">
            <summary>Alpha in range [0,1]</summary>
        </member>
        <member name="P:Claron.WIF.RgbaQuad.Red">
            <summary>Red in range [0,1]</summary>
        </member>
        <member name="P:Claron.WIF.RgbaQuad.Green">
            <summary>Green in range [0,1]</summary>
        </member>
        <member name="P:Claron.WIF.RgbaQuad.Blue">
            <summary>Blue in range [0,1]</summary>
        </member>
        <member name="P:Claron.WIF.RgbaQuad.Alpha">
            <summary>Alpha in range [0,1]</summary>
        </member>
        <member name="M:Claron.WIF.PathHelper.GetSubFolderNames(System.String,System.String)">
             <summary>
            
             </summary>
             <param name="folderPath"></param>
             <param name="SearchPattern">Default value = "*"</param>
             <returns></returns>
             <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.RTStructureSet">
             <summary>
             Radiotherapy Structure Set class imports/exports RT Structure Set ROI/Contour objects from/to
             DICOM RT Structure Set objects in DICOM P10 file format
            
             The following is an example illustrating how the class is used to decode/encode the RTSS objects.
            
             ' Using contours/attributes from an existing RTSS set for this demo
             Dim rtssSetFile As String = "SourceRtssDataSet.dcm"
             Dim existingRtss As New RTStructureSet(rtssSetFile)
            
             ' Create a new RTStructureSet object, label, date and time are mandatory attributes
             Dim newRtss As New RTStructureSet("MyRTSS Label", DateTime.Now, DateTime.Now)
            
             ' Manufacturer, optional attribute
             newRtss.Manufacturer = "Claron Technology Inc."
            
             ' Now create new ROIs, again, use existing ROIs from source RTSS for demo
             Dim roiNum As Integer = 1
             For Each existingRoi As RTStructureSetRoi In existingRtss.RoiList
            
                 ' Create a new ROI, ROI number is a mandatory attribute starts from 1
                 Dim newRoi As New RTStructureSetRoi(System.Math.Max(System.Threading.Interlocked.Increment(roiNum), roiNum - 1))
            
                 ' Optional ROI color
                 newRoi.DisplayColor = existingRoi.DisplayColor
            
                 ' Create contours for the new ROI, use existing ROI's contours' as source data for demo
                 For Each srcContour As RTStructureSetContour In existingRoi.ContourList
                     ' Create new contour, use existing contour's data as demo source, Contour (Curve) and GemotricType is mandatory
                     ' attributes for creating a new contour.
                     Dim contour As New RTStructureSetContour(srcContour.Contour, srcContour.GeometricType)
            
                     ' Other optional attributes
                     contour.GeometricType = srcContour.GeometricType
                     contour.NumberOfContourPoints = srcContour.NumberOfContourPoints
                     contour.ReferencedSopInstnaceUids = srcContour.ReferencedSopInstnaceUids
                     contour.Contour = srcContour.Contour
            
                     ' Add the contour to the ROI's contour list
                     newRoi.AddContour(contour)
                 Next
            
                 ' Add the the ROI to the Structure Set's ROI list
                 newRtss.AddRoi(newRoi)
             Next
            
             ' Create optional ROIInfo, using existing RoiInfos as source for demo
             For Each info As RTStructureSetRoiInfo In existingRtss.RoiInfoList
                 ' Create a ROI info object
                 Dim newRoiInfo As New RTStructureSetRoiInfo(info.ReferencedRoiNumber, info.ReferencedFrameRefUid, info.Name, info.RoiGenerationAlgorithm)
                 newRoiInfo.Description = "RTSS Test ROI Info Description"
            
                 newRtss.AddRoiInfo(newRoiInfo)
             Next
            
             ' ROI observation
             For Each ob As RTStructureSetRoiObservation In existingRtss.RoiObservations
                 Dim newOb As New RTStructureSetRoiObservation(ob.ObservationNumber, ob.ReferencedRoiNumber, ob.RoiInterpretedType, ob.Interpreter)
                 newRtss.AddRoiObservation(newOb)
             Next
            
             ' Source image dataset that provides source patient/study/series attributes
             ' Note the new RT Structure Set will be created as a new series that derives the patient/study level attributes
             ' from the source image series
             Dim srcImage As New DicomFile("SourceImage.dcm")
             srcImage.Load()
            
             ' Now save the RT Structure Set
             newRtss.Save(srcImage, "NewRtssDataSet.dcm")
             </summary>
        </member>
        <member name="F:Claron.WIF.RTStructureSet.PatientModuleAttributes">
            <summary>
            Radiotherapy Patient Module
            </summary>
        </member>
        <member name="F:Claron.WIF.RTStructureSet.StudyModuleAttributes">
            <summary>
            Study module attributes, including General Study and Patient Study module
            </summary>
        </member>
        <member name="M:Claron.WIF.RTStructureSet.#ctor(System.String)">
            <summary>
            Create a RT Structure Set object from a DICOM file/dataset
            </summary>
            <param name="filename"></param>
        </member>
        <member name="M:Claron.WIF.RTStructureSet.#ctor(ClearCanvas.Dicom.DicomFile)">
            <summary>
            Create a RT Structure Set object from a ClearCanvas DicomFile object
            </summary>
            <param name="dcmFile"></param>
        </member>
        <member name="M:Claron.WIF.RTStructureSet.#ctor(System.String,System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Create a new RT Structure Set object
            </summary>
        </member>
        <member name="M:Claron.WIF.RTStructureSet.GetRoiInfo(System.Int32)">
            <summary>
            Get optional ROI informations with given ROI number
            </summary>
            <param name="roiNumber"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.RTStructureSet.AddRoi(Claron.WIF.RTStructureSetRoi)">
            <summary>
            Add a new RT StructureSet ROI to the RT Structure Set
            </summary>
            <param name="roi">The ROI to add</param>
            <returns>ROI number for the new ROI</returns>
        </member>
        <member name="M:Claron.WIF.RTStructureSet.AddRoiInfo(Claron.WIF.RTStructureSetRoiInfo)">
            <summary>
            Add additional information for ROI
            </summary>
            <param name="roiInfo"></param>
        </member>
        <member name="M:Claron.WIF.RTStructureSet.AddRoiObservation(Claron.WIF.RTStructureSetRoiObservation)">
            <summary>
            Add an ROI observation
            </summary>
            <param name="observation"></param>
        </member>
        <member name="M:Claron.WIF.RTStructureSet.Save(ClearCanvas.Dicom.DicomFile,System.String,System.String)">
            <summary>
            Save radiotherapy structure set in DICOM P10 format
            </summary>
            <param name="srcImage">DICOM dataset that contains source images patient and study modules</param>
            <param name="contourFileName">Full path name of file with reference contours to save</param>
            <param name="userName"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.RTStructureSet.SetupSopCommon(ClearCanvas.Dicom.DicomAttributeCollection)">
            <summary>
            Setup SOP Common module
            </summary>
            <param name="dataSet"></param>
        </member>
        <member name="M:Claron.WIF.RTStructureSet.SetupMetaInfo(ClearCanvas.Dicom.DicomFile)">
            <summary>
            Adding storage meta info to the DICOM P10 file
            </summary>
            <param name="dcmFile"></param>
        </member>
        <member name="M:Claron.WIF.RTStructureSet.SaveRTModules(ClearCanvas.Dicom.DicomAttributeCollection,ClearCanvas.Dicom.DicomAttributeCollection)">
            <summary>
            Set up standard attributes
            </summary>
            <param name="srcDataSet"></param>
            <param name="dataSet"></param>
        </member>
        <member name="M:Claron.WIF.RTStructureSet.Load(ClearCanvas.Dicom.DicomFile)">
            <summary>
            Load StructureSet file from a DICOM file object
            </summary>
            <param name="dcmFile"></param>
        </member>
        <member name="M:Claron.WIF.RTStructureSet.LoadGeneralProperties(ClearCanvas.Dicom.DicomFile)">
            <summary>
            Load general properties
            </summary>
            <param name="dcmFile"></param>
        </member>
        <member name="M:Claron.WIF.RTStructureSet.LoadRois(ClearCanvas.Dicom.DicomAttributeSQ)">
            <summary>
            Load ROI contours
            </summary>
            <param name="roisSeq"></param>
        </member>
        <member name="M:Claron.WIF.RTStructureSet.LoadRoiInfos(ClearCanvas.Dicom.DicomAttributeSQ)">
            <summary>
            Update optional information of the ROIs
            </summary>
            <param name="structureRoiSeq"></param>
        </member>
        <member name="M:Claron.WIF.RTStructureSet.LoadObservations(ClearCanvas.Dicom.DicomAttributeSQ)">
            <summary>
            Load RT Structure Set ROI Observations
            </summary>
            <param name="observationRoiSeq"></param>
        </member>
        <member name="M:Claron.WIF.RTStructureSet.LoadReferencedFrameOfReferenceSeq(ClearCanvas.Dicom.DicomAttributeSQ)">
            <summary>
            Load Referenced Frame Of Reference Sequence
            </summary>
            <param name="rfrs"></param>
        </member>
        <member name="M:Claron.WIF.RTStructureSet.ValidateDataSet(ClearCanvas.Dicom.DicomFile)">
            <summary>
            Validate the DICOM data set
            </summary>
            <param name="dcmFile"></param>
        </member>
        <member name="P:Claron.WIF.RTStructureSet.RoiList">
            <summary>
            Radiotherapy Structure Set Region Of Interests
            </summary>
        </member>
        <member name="P:Claron.WIF.RTStructureSet.RoiInfoList">
            <summary>
            ROI Info list
            </summary>
        </member>
        <member name="P:Claron.WIF.RTStructureSet.RoiObservations">
            <summary>
            ROI Observations list
            </summary>
        </member>
        <member name="P:Claron.WIF.RTStructureSet.Label">
            <summary>
            RT Structure set label
            </summary>
        </member>
        <member name="P:Claron.WIF.RTStructureSet.DateTime">
            <summary>
            Date at which structure set was last modified
            </summary>
        </member>
        <member name="P:Claron.WIF.RTStructureSet.Time">
            <summary>
            Time at witch structure set was last modified
            </summary>
        </member>
        <member name="P:Claron.WIF.RTStructureSet.Manufacturer">
            <summary>
            Manufacturer
            </summary>
        </member>
        <member name="P:Claron.WIF.RTStructureSet.FrameOfReferenceUid">
            <summary>
            Frame Of Reference UID, Uniquely identifies Frame of Reference within Structure Set.
            </summary>
        </member>
        <member name="P:Claron.WIF.RTStructureSet.ReferencedStudyInstanceUid">
            <summary>
            Referenced Study Instance Uid
            </summary>
        </member>
        <member name="P:Claron.WIF.RTStructureSet.ReferencedSeriesInstanceUid">
            <summary>
            Referenced Series Instance Uid
            </summary>
        </member>
        <member name="P:Claron.WIF.RTStructureSet.SopInstanceUid">
            <summary>
            SOP Instance UID
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.RTStructureSetContour">
            <summary>
            RT Structure Set Contour class
            </summary>
        </member>
        <member name="M:Claron.WIF.RTStructureSetContour.#ctor(ClearCanvas.Dicom.DicomSequenceItem)">
            <summary>
            Create a RT Structure Set Contour object from DICOM RT Structure Set Contour Sequence
            </summary>
            <param name="contourSeqItem">Contour Sequence Item</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.RTStructureSetContour.#ctor(Claron.WIF.Curve,Claron.WIF.ContourGeometricType)">
            <summary>
            Create a RT Structure Set Contour object from a curve object
            </summary>
            <param name="geoType"></param>
            <param name="contour"></param>
        </member>
        <member name="M:Claron.WIF.RTStructureSetContour.Load(ClearCanvas.Dicom.DicomSequenceItem)">
            <summary>
            Load contour sequence
            </summary>
            <param name="contourSeqItem"></param>
        </member>
        <member name="M:Claron.WIF.RTStructureSetContour.ToContourSeqItem">
            <summary>
            Convert the RTStructureSetContour to Contour Sequence Item
            </summary>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.RTStructureSetContour.LoadReferencedSopInstanceUids(ClearCanvas.Dicom.DicomSequenceItem)">
            <summary>
            Load SOP Instance UIDs referenced by the contour
            </summary>
            <param name="contourSeq"></param>
        </member>
        <member name="M:Claron.WIF.RTStructureSetContour.DcmCodeStringToContourGeometricType(System.String)">
            <summary>
            Convert DICOM Contour Geometric Type code string to ContourGeometricType enumeration
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.RTStructureSetContour.ContourGeometricTypeToDcmCodeString(Claron.WIF.ContourGeometricType)">
            <summary>
            Convert ContourGeometricType enumeration to DICOM Contour Geometric Type code string
            </summary>
            <param name="geoType"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.RTStructureSetContour.ReferencedSopInstanceUids">
            <summary>
            Referenced Sop Instance Uid
            </summary>
        </member>
        <member name="P:Claron.WIF.RTStructureSetContour.GeometricType">
            <summary>
            Geometric type of the contour
            </summary>
        </member>
        <member name="P:Claron.WIF.RTStructureSetContour.NumberOfContourPoints">
            <summary>
            Number of points in the contour
            </summary>
        </member>
        <member name="P:Claron.WIF.RTStructureSetContour.Contour">
            <summary>
            Sequence of (x,y,z) triplets defining a contour in the patient based coordinate
            </summary>
        </member>
        <member name="T:Claron.WIF.ContourGeometricType">
            <summary>
            Contour Geometric Type
            </summary>
        </member>
        <member name="F:Claron.WIF.ContourGeometricType.Point">
            <summary>
            A Contour Geometric Type of Point indicates that the contour is a single point,
            defining a specific location of significance
            </summary>
        </member>
        <member name="F:Claron.WIF.ContourGeometricType.OpenPlanar">
            <summary>
            A Contour Geometric Type of OpenPlanar indicates that the last vertex shall not be connected to the first point,
            and that all points in Contour Data shall be coplanar
            </summary>
        </member>
        <member name="F:Claron.WIF.ContourGeometricType.OpenNonPlanar">
            <summary>
            A Contour Geometric Type of OpenNonPlanar indicates that the last vertex shall not be connected to
            the first point, and that the points in Contour Data may be non-coplanar
            </summary>
        </member>
        <member name="F:Claron.WIF.ContourGeometricType.ClosedPlanar">
            <summary>
            A Contour Geometric Type of ClosedPlanar indicates that the last point shall be connected to the
            first point, where the first point is not repeated in the Contour Data. All points in Contour Data
            shall be coplanar.
            </summary>
        </member>
        <member name="T:Claron.WIF.StructureSetDecodingException">
            <summary>
            Radiotherapy Structure Set Decoding Exception
            </summary>
        </member>
        <member name="M:Claron.WIF.StructureSetDecodingException.#ctor">
            <summary>
            Standard ctor
            </summary>
        </member>
        <member name="M:Claron.WIF.StructureSetDecodingException.#ctor(System.String)">
            <summary>
            Standard ctor.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Claron.WIF.StructureSetDecodingException.#ctor(System.String,System.Exception)">
            <summary>
            Standard ctor
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="T:Claron.WIF.StructureSetEncodingException">
            <summary>
            Radiotherapy Structure Set Decoding Exception
            </summary>
        </member>
        <member name="M:Claron.WIF.StructureSetEncodingException.#ctor">
            <summary>
            Standard ctor
            </summary>
        </member>
        <member name="M:Claron.WIF.StructureSetEncodingException.#ctor(System.String)">
            <summary>
            Standard ctor.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Claron.WIF.StructureSetEncodingException.#ctor(System.String,System.Exception)">
            <summary>
            Standard ctor
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="T:Claron.WIF.RTStructureSetRoi">
            <summary>
            Radiotherapy Structure Set Region Of Interests class
            </summary>
        </member>
        <member name="M:Claron.WIF.RTStructureSetRoi.#ctor(ClearCanvas.Dicom.DicomSequenceItem)">
            <summary>
            Create a new RT ROI object from ROI a DICOM Contour Sequence
            </summary>
            <param name="roiItem"></param>
        </member>
        <member name="M:Claron.WIF.RTStructureSetRoi.#ctor(System.Int32)">
            <summary>
            Create a new RT ROI
            </summary>
            <param name="roiNumber">ROI number</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.RTStructureSetRoi.ToRoiContourSeqItem">
            <summary>
            Save a RTStructureSetContour object as a DICOM ROI Structure Set ROI Contour sequence
            </summary>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.RTStructureSetRoi.AddContour(Claron.WIF.RTStructureSetContour)">
            <summary>
            Add a contour to the ROI
            </summary>
            <param name="contour"></param>
        </member>
        <member name="M:Claron.WIF.RTStructureSetRoi.Load(ClearCanvas.Dicom.DicomSequenceItem)">
            <summary>
            Load attributes for the ROI
            </summary>
            <param name="roiItem"></param>
        </member>
        <member name="M:Claron.WIF.RTStructureSetRoi.LoadContour(ClearCanvas.Dicom.DicomSequenceItem)">
            <summary>
            Load a contour that is associated with the ROI
            </summary>
            <param name="contourSeqItem"></param>
        </member>
        <member name="P:Claron.WIF.RTStructureSetRoi.RoiNumber">
            <summary>
            Referenced ROI number
            </summary>
        </member>
        <member name="P:Claron.WIF.RTStructureSetRoi.DisplayColor">
            <summary>
            Display color of the ROI
            </summary>
        </member>
        <member name="P:Claron.WIF.RTStructureSetRoi.ContourList">
            <summary>
            ROI Contours
            </summary>
        </member>
        <member name="T:Claron.WIF.RTStructureSetRoiInfo">
            <summary>
            Optional RT Structure Set ROI information
            </summary>
        </member>
        <member name="M:Claron.WIF.RTStructureSetRoiInfo.#ctor(System.Int32,System.String,System.String,System.String)">
            <summary>
            Create a RT Structure Set ROI Info object
            </summary>
            <param name="roiNumber">ROI number</param>
            <param name="refFrameOfRefUid">Referenced Frame Of Reference UID</param>
            <param name="name"></param>
            <param name="roiGenerationAlgorithm"></param>
        </member>
        <member name="M:Claron.WIF.RTStructureSetRoiInfo.#ctor(ClearCanvas.Dicom.DicomSequenceItem)">
            <summary>
            Create a RT Structure Set ROI Info object from an RT Structure Set ROI Sequence Item
            </summary>
            <param name="rtssRoiSeqItem"></param>
        </member>
        <member name="M:Claron.WIF.RTStructureSetRoiInfo.ToStructureSetRoiSeqItem">
            <summary>
            Save a RTStructureSetContour object as a DICOM ROI Structure Set ROI Contour sequence
            </summary>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.RTStructureSetRoiInfo.Load(ClearCanvas.Dicom.DicomSequenceItem)">
            <summary>
            Load the RT Structure Set Info object from an RT Structure Set ROI Sequence Item
            </summary>
            <param name="rtssRoiSeqItem"></param>
        </member>
        <member name="P:Claron.WIF.RTStructureSetRoiInfo.ReferencedRoiNumber">
            <summary>
            ROI Number
            </summary>
        </member>
        <member name="P:Claron.WIF.RTStructureSetRoiInfo.ReferencedFrameRefUid">
            <summary>
            Uniquely identifies Frame of Reference in which ROI is definedReferenced Frame Of Reference UID
            </summary>
        </member>
        <member name="P:Claron.WIF.RTStructureSetRoiInfo.Name">
            <summary>
            Name of the ROI
            </summary>
        </member>
        <member name="P:Claron.WIF.RTStructureSetRoiInfo.RoiGenerationAlgorithm">
            <summary>
            ROI Generation Algorithm
            </summary>
        </member>
        <member name="P:Claron.WIF.RTStructureSetRoiInfo.Volume">
            <summary>
            Volume of the ROI, optional
            </summary>
        </member>
        <member name="P:Claron.WIF.RTStructureSetRoiInfo.Description">
            <summary>
            Description of the ROI
            </summary>
        </member>
        <member name="T:Claron.WIF.RTStructureSetRoiObservation">
            <summary>
            The RT ROI Observations module specifies the identification and interpretation of an ROI specified in
            the Structure Set and ROI Contour modules.
            </summary>
        </member>
        <member name="M:Claron.WIF.RTStructureSetRoiObservation.#ctor(System.Int32,System.Int32,System.String,System.String)">
            <summary>
            Create a new RT Structure Set ROI Observation object
            </summary>
            <param name="observationNumber"></param>
            <param name="refRoiNumber"></param>
            <param name="interpretedType"></param>
            <param name="interpreter"></param>
        </member>
        <member name="M:Claron.WIF.RTStructureSetRoiObservation.#ctor(ClearCanvas.Dicom.DicomSequenceItem)">
            <summary>
            Create a RT Structure Set ROI Observation object from an RT Structure Set ROI Observation Sequence Item
            </summary>
            <param name="obSeqItem">The RT Structure Set Observation Sequence Item</param>
        </member>
        <member name="M:Claron.WIF.RTStructureSetRoiObservation.ToStructureSetRoiObservationSeqItem">
            <summary>
            Save a RTStructureSetRoiObservation object as a DICOM ROI Structure Set ROI Observation sequence item
            </summary>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.RTStructureSetRoiObservation.Load(ClearCanvas.Dicom.DicomSequenceItem)">
            <summary>
            Load RT Structure Set ROI Observation object from an RT Structure Set ROI Observation Sequence Item
            </summary>
            <param name="obSeqItem"></param>
        </member>
        <member name="P:Claron.WIF.RTStructureSetRoiObservation.ObservationNumber">
            <summary>
            Identification number of the Observation
            </summary>
        </member>
        <member name="P:Claron.WIF.RTStructureSetRoiObservation.ReferencedRoiNumber">
            <summary>
            ROI number that the observation is associated with
            </summary>
        </member>
        <member name="P:Claron.WIF.RTStructureSetRoiObservation.RoiInterpretedType">
            <summary>
            ROI Interpreted type
            </summary>
        </member>
        <member name="P:Claron.WIF.RTStructureSetRoiObservation.Interpreter">
            <summary>
            ROI Interpreter
            </summary>
        </member>
        <member name="T:Claron.WIF.SliceStack">
            <summary>
            Represents a stacked array of images.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.SliceStack._brickMaxValSs">
            <summary>
            Slice stack to hold the maximum stored value in each brick of the current slice stack.
            </summary>
        </member>
        <member name="F:Claron.WIF.SliceStack._SliceImages">
            <summary>
            Slice images for the slice stack.
            </summary>
        </member>
        <member name="F:Claron.WIF.SliceStack.LastLoadDirPath">
            <summary>
            The directory/folder from which the images were loaded (if were loaded)
            </summary>
            
        </member>
        <member name="F:Claron.WIF.SliceStack.LastLoadFileNames">
            <summary>
            The names of the files in LastLoadDirPath that were loaded (not full paths), sorted by the
            Z dimension of the stack.
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.InfoGet(Claron.WIF.DicomStuff.InfoTag)">
            <summary>
            General property for accessing informational (usually DICOM) fields
            </summary>
            <param name="Tag">The field's enum (identical to DicomTags constants)</param>
            <returns>The field's value string, or an empty string ("") if none was provided</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.InfoSet(Claron.WIF.DicomStuff.InfoTag,System.String)">
            <summary>
            General property for accessing informational (usually DICOM) fields
            </summary>
            <param name="Tag">The field's enum (identical to DicomTags constants)</param>
            <param name="NewValue">New value for that field</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.Modality">
            <summary>
            Returns a 2-letters string representing the stack's modality (see ModalityEnum)
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.GetStored2ModalityParams(System.Double@,System.Double@)">
            <summary>
            Obtains the parameters for translating between stored pixel values and modality
            values (eg, HU), according to the following formula:
             [modality value] = Stored2ModalitySlope * [stored value] + Stored2ModalityIntercept.
            </summary>
            <param name="outStored2ModalitySlope">
            Output: The ratio between the modality and stored voxel values.
            </param>
            <param name="outStored2ModalityIntercept">
            Output: The modality value of stored voxel value 0
            <returns>returns a Boolean flag indicating 
            for IsUsing Remoter if cached values are used
            and otherwise if the slope+intercep come from the first image (if false thene they come from the first image with actual values) </returns>
            </param>
        </member>
        <member name="M:Claron.WIF.SliceStack.SetStored2ModalityParams(System.Double,System.Double)">
            <summary>
            Sets the parameters for translating between stored pixel values and modality
            values (eg, HU), according to the following formula:
             [modality value] = Stored2ModalitySlope * [stored value] + Stored2ModalityIntercept.
            These are usually obtained from the DICOM header on loading, but need to be set
            if the SliceStack is created programmatically.
            </summary>
            <param name="newStored2ModalitySlope">
            The ratio between the modality and stored voxel values.
            </param>
            <param name="NewStored2ModalityIntercept">
            The modality value of stored voxel value 0
            </param>
        </member>
        <member name="F:Claron.WIF.SliceStack._Grid">
            <summary>
             Contains all the geometrical/dimensional properties of the stack.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.SampleDimensionsMm">
            <summary>
            Returns the dimensions of a voxel sample. Note that it is the same as
            SpacingMm in X and Y, but not in Z, where the slice thickness may not be
            the same as slice spacing.
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.SliceImageGet(System.Int32)">
            <summary>
            Get: The slice image indexed i (not a copy!), Set: copies the pixels from the value to the slice
            </summary>
            <param name="i"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.SliceImageSet(System.Int32,Claron.WIF.ImageU12)">
            <summary>
            Get: The slice image indexed i (not a copy!), Set: copies the pixels from the value to the slice
            </summary>
            <param name="i"></param>
            <param name="NewValue"></param>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.SliceStack._maxInconsistentSlices">
             <summary>
             The maximum number of slices which can be missing, have an inconsistent spacing, or have an
             inconsistent tilt which will be corrected. If non-zero then any missing slices will be
             interpolated, any inconsistencies in spacing will be corrected, and any inconsistencies in
             tilt will also be corrected up to the maximum number of slices set.
            
             The recommended value for this property is 0, so that no correction will be made. In this case
             the largest contiguous block of consistently spaced and tilted slices will be loaded. If
             however it is very important that all slices be loaded then it is recommended to set this
             property value to either 1, 2, or 3 at a maximum.
             </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.VoxelGet(System.Int32,System.Int32,System.Int32)">
            <summary>
            Gets the stored value of the voxel at a given (0-based) index. Not very fast!
            </summary>
            <param name="Xindex">The volume index</param>
            <param name="Yindex">The row index</param>
            <param name="Zindex">The slice index</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.VoxelSet(System.Int32,System.Int32,System.Int32,System.Int16)">
            <summary>
            sets the stored value of the voxel at a given (0-based) index. Not very fast!
            </summary>
            <param name="Xindex">The volume index</param>
            <param name="Yindex">The row index</param>
            <param name="Zindex">The slice index</param>
            <param name="NewValue"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.VoxelGet(Claron.WIF.Vector3_I32)">
            <summary>
            Gets the stored value of the voxel at a given (0-based) index. Not very fast!
            </summary>
            <param name="vIdx">The index position of the Voxel.</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.VoxelGetLocalNoBoundsCheck(Claron.WIF.Vector3_I32)">
            <summary>
            Gets the stored value of the voxel at a given (0-based) index without
            checking for remoting or stack boundary.
            </summary>
            <param name="vIdx">The index position of the Voxel.</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.VoxelSet(Claron.WIF.Vector3_I32,System.Int16)">
            <summary>
            sets the stored value of the voxel at a given (0-based) index. Not very fast!
            </summary>
            <param name="vIdx">The index position of the Voxel.</param>
            <param name="NewValue"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.VoxelGet(Claron.WIF.Vector3)">
            <summary>
            Gets the stored value of the nearest voxel at a given position.
            For a trilinearly interpolated value at the exact location, use GetInterpolatedVoxelValue().
            </summary>
            <param name="vPatRcs"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.VoxelSet(Claron.WIF.Vector3,System.Int16)">
            <summary>
            sets the stored value of the nearest voxel at a given position. Not very fast!
            </summary>
            <param name="vPatRcs"></param>
            <param name="NewValue"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.VoxelModalityGet(Claron.WIF.Vector3_I32)">
            <summary>
             Gets the modality (eg, HU for CT) value of the voxel at a given grid index. Not very fast!
            </summary>
            <param name="vSi">The vector position in SliceStack Index coordinates (Si).</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.VoxelModalitySet(Claron.WIF.Vector3_I32,System.Int32)">
            <summary>
            sets the modality (eg, HU for CT) value of the voxel at a given grid index. Not very fast!
            </summary>
            <param name="vSi">The vector position in SliceStack Index coordinates (Si).</param>
            <param name="NewValue"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.VoxelModalityGet(System.Int32,System.Int32,System.Int32)">
            <summary>
            Gets the modality (eg, HU for CT) value of the voxel at a given (0-based) index. Not very fast!
            </summary>
            <param name="Xindex">The volume index</param>
            <param name="Yindex">The row index</param>
            <param name="Zindex">The slice index</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.VoxelModalitySet(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            sets the modality (eg, HU for CT) value of the voxel at a given (0-based) index. Not very fast!
            </summary>
            <param name="Xindex">The volume index</param>
            <param name="Yindex">The row index</param>
            <param name="Zindex">The slice index</param>
            <param name="value"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.StoredValueRangeMin">
            <summary>
            Returns the low end of the valid stored value range. May fall outside the U12 range!
            Independent of the actual values stored in the stack.
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.StoredValueRangeMax">
            <summary>
            Returns the high end of the valid stored value range. May fall outside the U12 range!
            Independent of the actual values stored in the stack.
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.StoredValueRangeCount">
            <summary>
            Returns the number of stored values in the valid range.
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.AddValueInMask(Claron.WIF.BitVol,System.Int16)">
            <summary>
            Adds an increment to the stored values in a region in a bitvol mask
            (useful for debugging).
            The value is not clipped to a valid range.
            </summary>
            <param name="mask"></param>
            <param name="addedValue"></param>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.SliceStack.RCSUID">
            <summary>
            The coordinate system identifier obtained from the DICOM header.
            Can also be set by the client if not loaded from DICOM.
            </summary>
        </member>
        <member name="F:Claron.WIF.SliceStack._AllHeaderTags">
            <summary> The AllHeaderTags property is extracted from the first slice upon loading a new stack. </summary>
        </member>
        <member name="F:Claron.WIF.SliceStack._AllHeaderTagsLast">
            <summary> The AllHeaderTags property is extracted from the last slice upon loading a new stack. </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.HistogramGet(System.Int32)">
            <summary>
            Returns the histogram (64K entries) of all stored values in the stack, with
            entry 0 corresponding to StoredValueRangeMin.
            Optimized to avoid re-calculation.
            </summary>
            <param name="SubSampleRate">If N>1, only every Nth sample in each dimension is used</param>
            <returns></returns>
            <remarks>Value wrap-around: negative value N is added to bin N+64K</remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.PercentileStoredValue(System.Double,System.Boolean,System.Int32)">
            <summary>
            Returns the stored value at the given percentile within the valid stored value range.
            May need to calculate a histogram if none calculated so far.
            </summary>
            <param name="percent">the percent [0,100] of pixels below the returned value.</param>
            <param name="IgnoreZeroBin">If true, the bin of StoredValueRangeMin will be ignored (it's usually background)</param>
            <param name="SubSampleRate">If N>1, only every Nth sample in each dimension is used to
            assess voxel distribution</param>
            <returns>The stored value at the given percentile</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.#ctor">
            <summary>
            Create an empty slice-stack
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.#ctor(System.Collections.Generic.List{Claron.WIF.ImageU12},System.Collections.Generic.List{Claron.WIF.ImageU12}@,System.Collections.Generic.List{System.String}@)">
            <summary>
            Create a new slice-stack and use an array of provided ImageU12 objects as its data.
            The slices are filtered and sorted first (ie, some slices may be left out).
            The new stack adopts all the DICOM properties of the slices (including series UID).
            The stack is assumed to be for viewing, so the slice values may be remapped to ensure
            they fit in the 12b value range.
            </summary>
            <param name="slices">A list of the slices to be used for the slice stack. MAY BE MODIFIED BY
            THE CALL.</param>
            <param name="outRemainingSlices">optional Output: fills the given list with the slices
            in the input list that were not used (from which
            perhaps other SliceStacks can be created). Ignored if Nothing.</param>
            <param name="outErrorMessages"></param>
        </member>
        <member name="M:Claron.WIF.SliceStack.#ctor(System.Collections.Generic.List{Claron.WIF.ImageU12},System.Collections.Generic.List{Claron.WIF.ImageU12}@,System.Collections.Generic.List{System.String}@,System.Boolean)">
            <summary>
            Create a new slice-stack and use an array of provided ImageU12 objects as its data.
            The slices are filtered and sorted first (ie, some slices may be left out).
            The new stack adopts all the DICOM properties of the slices (including series UID).
            The stack is assumed to be for viewing, so the slice values may be remapped to ensure
            they fit in the 12b value range.
            </summary>
            <param name="slices">A list of the slices to be used for the slice stack. MAY BE MODIFIED BY
            THE CALL.</param>
            <param name="outRemainingSlices">optional Output: fills the given list with the slices
            in the input list that were not used (from which
            perhaps other SliceStacks can be created). Ignored if Nothing.</param>
            <param name="outErrorMessages"></param>
            <param name="diffRcsUidOverride"></param>
        </member>
        <member name="M:Claron.WIF.SliceStack.#ctor(System.Collections.Generic.List{Claron.WIF.ImageU12},System.Collections.Generic.List{Claron.WIF.ImageU12}@,System.Collections.Generic.List{System.String}@,System.Double,System.Boolean)">
            <summary>
            Create a new slice-stack and use an array of provided ImageU12 objects as its data.
            The slices are filtered and sorted first (ie, some slices may be left out).
            The new stack adopts all the DICOM properties of the slices (including series UID).
            The stack is assumed to be for viewing, so the slice values may be remapped to ensure
            they fit in the 12b value range.
            </summary>
            <param name="slices">A list of the slices to be used for the slice stack. MAY BE MODIFIED BY
            THE CALL.</param>
            <param name="outRemainingSlices">optional Output: fills the given list with the slices
            in the input list that were not used (from which
            perhaps other SliceStacks can be created). Ignored if Nothing.</param>
            <param name="outErrorMessages"></param>
            <param name="sliceSpacingTolerance"></param>
            <param name="diffRcsUidOverride"></param>
        </member>
        <member name="M:Claron.WIF.SliceStack.#ctor(System.Collections.Generic.List{Claron.WIF.ImageU12},System.Collections.Generic.List{Claron.WIF.ImageU12}@,System.Collections.Generic.List{System.String}@,System.Boolean,System.Boolean)">
            <summary>
            Create a new slice-stack and use an array of provided ImageU12 objects as its data.
            The slices are filtered and sorted first (ie, some slices may be left out).
            The new stack adopts all the DICOM properties of the slices (including series UID).
            </summary>
            <param name="slices">A list of the slices to be used for the slice stack. MAY BE MODIFIED BY
            THE CALL.</param>
            <param name="outRemainingSlices">optional Output: fills the given list with the slices
            in the input list that were not used (from which
            perhaps other SliceStacks can be created). Ignored if Nothing.</param>
            <param name="outErrorMessages"></param>
            <param name="ForViewing">If true, the slice data may be remapped to ensure it
            can be displayed by the Camera class (U12 pixels only)</param>
            <param name="diffRcsUidOverride"></param>
        </member>
        <member name="M:Claron.WIF.SliceStack.#ctor(System.Collections.Generic.List{Claron.WIF.ImageU12})">
            <summary>
            Create a new slice-stack and use an array of provided ImageU12 objects as its data.
            The slices are filtered and sorted first (ie, some slices may be left out).
            The new stack adopts all the DICOM properties of the slices (including series UID).
            The stack is assumed to be for viewing, so the slice values may be remapped to ensure
            they fit in the 12b value range.
            </summary>
            <param name="slices">A list of the slices to be used for the slice stack. MAY BE MODIFIED BY
            THE CALL.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.#ctor(System.Collections.Generic.List{Claron.WIF.ImageU12},System.Boolean)">
            <summary>
            Create a new slice-stack and use an array of provided ImageU12 objects as its data.
            The slices are filtered and sorted first (ie, some slices may be left out).
            The new stack adopts all the DICOM properties of the slices (including series UID).
            The stack is assumed to be for viewing, so the slice values may be remapped to ensure
            they fit in the 12b value range.
            </summary>
            <param name="slices">A list of the slices to be used for the slice stack. MAY BE MODIFIED BY
            THE CALL.</param>
            <param name="diffRcsUidOverride">If true, uniqueness of RcsUid is not checked for.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.#ctor(System.Collections.Generic.List{Claron.WIF.ImageU12},System.Boolean,System.Boolean)">
            <summary>
            Create a new slice-stack and use an array of provided ImageU12 objects as its data.
            The slices are filtered and sorted first (ie, some slices may be left out).
            The new stack adopts all the DICOM properties of the slices (including series UID).
            The stack is assumed to be for viewing, so the slice values may be remapped to ensure
            they fit in the 12b value range.
            </summary>
            <param name="slices">A list of the slices to be used for the slice stack. MAY BE MODIFIED BY
            THE CALL.</param>
            <param name="ForViewing">If true, the slice data may be remapped to ensure it
            can be displayed by the Camera class (U12 pixels only)</param>
            <param name="diffRcsUidOverride">If true, uniqueness of RcsUid is not checked for.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.#ctor(System.Collections.Generic.List{Claron.WIF.ImageU12},System.Collections.Generic.List{Claron.WIF.ImageU12}@)">
            <summary>
            Create a new slice-stack and use an array of provided ImageU12 objects as its data.
            The slices are filtered and sorted first (ie, some slices may be left out).
            The new stack adopts all the DICOM properties of the slices (including series UID).
            The stack is assumed to be for viewing, so the slice values may be remapped to ensure
            they fit in the 12b value range.
            </summary>
            <param name="slices">A list of the slices to be used for the slice stack. MAY BE MODIFIED BY
            THE CALL.</param>
            <param name="outRemainingSlices">optional Output: fills the given list with the slices
            in the input list that were not used (from which
            perhaps other SliceStacks can be created). Ignored if Nothing.</param>
        </member>
        <member name="M:Claron.WIF.SliceStack.#ctor(System.Collections.Generic.List{System.String},System.Boolean,Claron.WIF.SliceStack.LoadProgressNotification,System.Collections.Generic.List{System.String}@)">
            <summary>
            Creates a new slice stack using slices loaded from DICOM files.
            Note: do not use this constructor to create a slicestack from non-dicom slices.
            Instead, use New (Slices() as Array..).
            </summary>
            <param name="SlicePaths"></param>
            <param name="UseRemoter">If true, the Images will be created and managed using a remoter
            (which is usually created on a server), Default value is false</param>
            <param name="ProgressCallBack">Progress notification. Can be null.</param>
            <param name="outErrorMessages">A list that collects all error messages during the creation.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.LoadImageRangeAsNeeded(System.Int32,System.Int32,System.Int32,System.Boolean@,System.Boolean)">
            <summary>
            Loads the specified slices from the disk for progressive loading
            </summary>
            <param name="StartIndex">startIndex of the slices to load</param>
            <param name="NumberToLoad">number of slices to load</param>
            <param name="highPriorityIndex">Index of the slice where current Focus is located. If user has
            scrolled to some location, that slice needs to be loaded first. Default pass -1.</param>
            <param name="highPriorityLoaded">Returns if the slice with High priorityIndex was loaded.</param>
            <param name="ForViewing"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.SliceStack.#ctor(System.Boolean,Claron.WIF.SliceStack)">
            <summary>
            For testing, will remove it once testing is done.
            </summary>
            <param name="UseRemoter"></param>
            <param name="ss"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.SetupFromDicomSlices(System.Collections.Generic.List{Claron.WIF.ImageU12})">
            <summary>Shared function for creating a new stack, called by multiple New() interfaces.
            The SliceStack is assumed to be for viewing (so the slice data may be remapped to ensure it
            can be displayed by the Camera class (U12 pixels only</summary>
            <param name="slices">In/out: A list of the slices to be used for the slice stack.
            After the call slices that were not used are left in the list.</param>
        </member>
        <member name="M:Claron.WIF.SliceStack.SetupFromDicomSlices(System.Collections.Generic.List{Claron.WIF.ImageU12},System.Collections.Generic.List{Claron.WIF.ImageU12},System.Collections.Generic.List{System.String}@,System.Boolean,System.Boolean)">
            <summary>Shared function for creating a new stack, called by multiple New() interfaces</summary>
            <param name="slices">In/out: A list of the slices to be used for the slice stack.
            After the call slices that were not used are left in the list.</param>
            <param name="outRemainingSlices">Output: the slices in the list that were not used (from which
            perhaps other SliceStacks can be created. If Nothing, then it is ignored</param>
            <param name="outErrorMessages"></param>
            <param name="ForViewing">If true, the slice data may be remapped to ensure it 
            can be displayed by the Camera class (U12 pixels only)</param>
            <param name="diffRcsUidOverride">If true, the uniqueness of RcsUid is not checked for</param>
        </member>
        <member name="M:Claron.WIF.SliceStack.SetupFromDicomSlices(System.Collections.Generic.List{Claron.WIF.ImageU12},System.Collections.Generic.List{Claron.WIF.ImageU12},System.Collections.Generic.List{System.String}@,System.Double,System.Boolean,System.Boolean)">
            <summary>Shared function for creating a new stack, called by multiple New() interfaces</summary>
            <param name="slices">In/out: A list of the slices to be used for the slice stack.
            After the call slices that were not used are left in the list.</param>
            <param name="outRemainingSlices">Output: the slices in the list that were not used (from which
            perhaps other SliceStacks can be created. If Nothing, then it is ignored</param>
            <param name="outErrorMessages">Error messages informing of problems during slicestack creation. 
            When no errors are encountered, it is null. </param>
            <param name="sliceSpacingTolerance">The maximum tolerance fraction (0 to 1) for deviations in
            slice spacing from the most common spacing. For example, a tolerance
            of 0.1 means spacings of 0.9 to 1.1 times (+/-10%) are allowed in
            the filtered list.</param>
            <param name="ForViewing">If true, the slice data may be remapped to ensure it 
            can be displayed by the Camera class (U12 pixels only)</param>
            <param name="diffRcsUidOverride">If true, the uniqueness of RcsUid is not checked for</param>
        </member>
        <member name="M:Claron.WIF.SliceStack.#ctor(Claron.WIF.ImageU12[],Claron.WIF.Vector3)">
            <summary>
            Create a new slice-stack and use an array of provided ImageU12 objects as its data.
            WARNING - the new stack does not have a proper DICOM header. Use only for temporary stacks.
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.#ctor(Claron.WIF.ImageU12,System.Boolean)">
            <summary>
            Create a new slice-stack from a single ImageU12 slice. The slice stack
            will reference the same slice twice (as if it had two slices), and the slices
            will be spaced by the slice thickness (or 1mm if thickness is unknown).
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.#ctor(Claron.WIF.GridBox)">
            <summary>
            Creates a new empty (all pixels 0) slice stack with the same dimensions and the same PatientRCS as the 
            provided GridBox.
            </summary>
            <param name="gb"></param>
        </member>
        <member name="M:Claron.WIF.SliceStack.#ctor(Claron.WIF.Vector3_I32,Claron.WIF.Vector3,System.Int16)">
            <summary>
            Creates a new empty slice stack.
            </summary>
            <param name="dims">The dimensions of the slice stack.</param>
            <param name="spacingMm">The spacing of the pixels in the slice stack.</param>
            <param name="initialVal">The initial value of each voxel in the slice stack.</param>
            <remarks>For use with synthetic data. Accessing DICOM information
            will result in an exception being thrown.
            The Stored2Modality parameters are set at (1,-1024), as if it was a CT stack.
            </remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.#ctor(System.Drawing.Bitmap,System.Int16,System.Int16)">
            <summary>
            Creates a new slice stack from the given bitmap.
            </summary>
            <param name="bmp">The input image.</param>
            <param name="min">The minimum value of the scaling range.</param>
            <param name="max">The maximum value of the scaling range.</param>
        </member>
        <member name="F:Claron.WIF.SliceStack._assembly">
            <summary>
            Assembly to load atlas from.
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.LoadFromEmbeddedResource(System.String)">
            <summary>
            Loads an atlas from either IAngioLib.dll or WIFOperators.dll
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.FreeVRCaches">
            <summary>
            Frees all the volume rendering cache memory associated with this slice stack.
            Automatically called when the SliceStack is garbage-collected, but the client
            may wish to call it earlier.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.Copy">
            <summary>
            Returns a deep copy of the slice stack (including slices). The slice pointers are unlocked.
            </summary>
            <returns></returns>
            <remarks>The copy has a new UID</remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.CopyAnonymised">
            <summary>
            Returns a deep copy of anonymised slice stack (including slices). The slice pointers are unlocked.
            </summary>
            <returns></returns>
            <remarks>The copy has a new UID</remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.MakeShallowCopy">
            <summary>
            Returns a shallow copy of the slice stack (referencing the same slices)
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.UpdateSeriesUID">
            <summary>
            Creates new series UID for the stack and updates the series UID of all the slices.
            The new UID will appear in the DICOM header only when the slice stack is saved.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.AddSlice(Claron.WIF.ImageU12)">
            <summary>
            Adds a new slice to a non-empty stack at the end. NO CONSISTENCY CHECKING BETWEEN SLICES IS DONE!
            </summary>
            <param name="slice">The slice to add</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.AddSlices(System.Int32)">
            <summary>
            Adds new blank slices to the end of the slice stack.
            </summary>
            <param name="nSlices">The number of slices to add.</param>
        </member>
        <member name="M:Claron.WIF.SliceStack.RemoveFirstSlice">
            <summary>
            Removes and returns the first slice from a stack. Does nothing if the stack is empty.
            </summary>
            <returns>The removed slice (or nothing if the stack is empty)</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.RemoveFirstNSlices(System.Int32)">
            <summary>
            Removes the first nSlicesToRemove from the slice stack. Does nothing if the number of slices
            to remove is greater than the number of slices present in the slice stack.
            </summary>
            <param name="nSlicesToRemove">The number of slices to remove.</param>
        </member>
        <member name="M:Claron.WIF.SliceStack.SubStack(System.Int32,System.Int32)">
            <summary>
            Returns a new slice stack containing a sub-range of the slices (by reference - no copy!).
            </summary>
            <param name="minZ">The index of the first slice in the SliceImages array, clamped to bounds</param>
            <param name="maxZ">The index of the last slice in the SliceImages array, clamped</param>
            <returns>The new sub-stack, or Nothing if EndI lower than StartI</returns>
            <remarks>Minimal additional memory is consumed by the sub-stack.
            Both stacks are unlocked afterwards</remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.SubSample(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a new slice stack containing a sub-sampled volume.
            </summary>
            <param name="minZ">The index of the first slice in the slice stack. Input value is clamped to
            z-bounds of slice stack.</param>
            <param name="maxZ">The index of the last slice in the slice stack. Input value is clamped to z-bounds
            of slice stack.</param>
            <param name="nSlices">The number of slices in the sub-sampled slice stack.</param>
            <returns>The new sub-stack or null if the last slice is lower than the first slice.</returns>
        </member>
        <member name="M:Claron.WIF.SliceStack.CopyVoxelsAndGrid(Claron.WIF.SliceStack)">
            <summary>
            Copies slice image and grid pointers. No data is copied.
            </summary>
            <param name="ss"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.SliceStack.SubStackRevert(System.Int32,System.Int32,Claron.WIF.SliceStack)">
            <summary>
             Restores values backed up in subSS. Verifies that subSS size and images size are matching
            </summary>
            <param name="StartI"></param>
            <param name="EndI"></param>
            <param name="subSS"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.StackRevert(Claron.WIF.SliceStack)">
            <summary>
            Restores values backed up in slice stack.
            </summary>
            <param name="ss">The slice stack to revert from.</param>
        </member>
        <member name="M:Claron.WIF.SliceStack.DilutedStack(System.Int32)">
            <summary>
            Returns a new slice stack containing only every Nth slice, starting from 0 (by reference - no copy!).
            </summary>
            <param name="Ratio">The dilution ratio, clamped to be positive</param>
            <returns>The new diluted stack</returns>
            <remarks>Minimal additional memory is consumed by the sub-stack.
            Both stacks are unlocked afterwards</remarks>
        </member>
        <member name="F:Claron.WIF.SliceStack.DicomFileValidNameExtensionPatterns">
            <summary>
            An array of valid DICOM file name extensions to help quickly filter out files
            which are certainly not DICOM files. The application can replace it with its own if
            the default doesn't satisfy its requirements. Must be uppercase and include the dot!.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.SliceStack.DicomFileInvalidName">
            <summary>
            An array of invalid DICOM file names (uppercase all).
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.DicomFileListFromFolder(System.String,System.Boolean)">
            <summary>
            Obtains the list of the full paths of files that may be DICOM files in the given folder
            (see DicomFileValidNameExtensionPatterns and DicomFileInvalidName).
            </summary>
            <param name="dcmFolderPath">The path to the folder to search</param>
            <param name="SearchSubfolders">If true, all sub-folders will be recursively searched as well</param>
            <returns>The list of full paths, which may be empty if cannot find any files or the folder doesn't exist.</returns>
        </member>
        <member name="M:Claron.WIF.SliceStack.DicomFolderInTreeWithMostDcmImages(System.String)">
            <summary>
            finds the list of filePathAndName to the subdirectory with the most files
            that appear to be DICOM images.
            </summary>
            <param name="dcmFolderPath">The directory to start the search at.</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.DicomFileListFromFileList(System.Collections.Specialized.StringCollection)">
            <summary>
            Removes non-DICOM-image paths from a list of paths (checking on only the path, not the file itself)
            (see DicomFileValidNameExtensionPatterns and DicomFileInvalidName).
            </summary>
            <param name="fullFilePaths">The paths to evaluate whether they may be valid DICOM images</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.FileIsMaybeDicomImage(System.String)">
            <summary>
            Returns true when the given file path is worth checking whether it is a valid DICOM image file
            by loading and searching for a header.
            See also DicomFileValidNameExtensionPatterns and DicomFileInvalidName.
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.CompareByVolume(Claron.WIF.SliceStack,Claron.WIF.SliceStack)">
            <summary>
            Comparer function that can be used for generic collection sorting of slice stacks by their volume
            </summary>
            <returns>1 if SS0 data size is larger, -1 if SS1 data size is larger, 0 if they have the same size</returns>
            <remarks>Usage: SsList.Sort(AddressOf SliceStack.CompareByVolume) </remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.CompareByAcquisitionTime(Claron.WIF.SliceStack,Claron.WIF.SliceStack)">
            <summary>
            Comparer function that can be used for generic collection sorting of slice stacks by their
            acquisition date/time
            </summary>
            <returns>1 if SS0 was acquired later, -1 if SS1 is later, 0 if they were acquired at the same time,
            their acquisition time is unknown.</returns>
            <remarks>Usage: SsList.Sort(AddressOf SliceStack.CompareByAcquisitionTime) </remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.CompareByContentTime(Claron.WIF.SliceStack,Claron.WIF.SliceStack)">
            <summary>
            Comparer function that can be used for generic collection sorting of virtual slice stacks
            for Tracker application by the acquisition date/time of individual images
            </summary>
            <returns> 1 if SS0 was acquired later, -1 if SS1 is later, 0 if they were acquired at the same time,
            their acquisition time is unknown.</returns>
            <remarks>Usage: SsList.Sort(AddressOf SliceStack.CompareByAcquisitionTime) </remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.LoadAllSliceStacks(System.String)">
            <summary>
            Searches the given directory for DICOM image files, filters and organizes them into slice-stacks,
            and returns a list of all the slice-stacks found sorted by number of voxels (largest first!).
            </summary>
            <param name="folderFullPath">The full path of the folder to search (with or without terminating slash)</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.LoadAllSliceStacks(System.String,Claron.WIF.SliceStack.LoadProgressNotification)">
            <summary>
            Searches the given directory for DICOM image files, filters and organizes them into slice-stacks,
            and returns a list of all the slice-stacks found sorted by number of voxels (largest first!).
            </summary>
            <param name="folderFullPath">The full path of the folder to search (with or without terminating slash)</param>
            <param name="ProgressCallBack">If provided, will be called to report on progress approximately
            every 5%. Will not be called if no image files are found.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.LoadAllSliceStacks(System.String,Claron.WIF.SliceStack.LoadProgressNotification,System.Boolean)">
            <summary>
            Searches the given directory, and, optionally, all its sub-directories, for DICOM image files,
            filters and organizes them into slice-stacks, and returns a list of all the slice-stacks
            found sorted by number of voxels (largest first!).
            </summary>
            <param name="folderFullPath">The full path of the folder to search (with or without terminating slash)</param>
            <param name="ProgressCallBack">If provided, will be called to report on progress approximately
            every 5%. Will not be called if no image files are found.</param>
            <param name="SearchSubfolders">If true, all sub-folders will be recursively searched for
            DICOM image files</param>
        </member>
        <member name="M:Claron.WIF.SliceStack.LoadAllSliceStacks(System.String,Claron.WIF.SliceStack.LoadProgressNotification,System.Boolean,System.Boolean)">
            <summary>
            Searches the given directory, and, optionally, all its sub-directories, for DICOM image files,
            filters and organizes them into slice-stacks, and returns a list of all the slice-stacks
            found sorted by number of voxels (largest first!).
            </summary>
            <param name="folderFullPath">The full path of the folder to search (with or without terminating slash)</param>
            <param name="ProgressCallBack">If provided, will be called to report on progress approximately
            every 5%. Will not be called if no image files are found.</param>
            <param name="SearchSubfolders">If true, all sub-folders will be recursively searched for
            DICOM image files</param>
            <param name="diffRcsUidOverride">If true, uniqueness of RcsUid is not checked for</param>
        </member>
        <member name="M:Claron.WIF.SliceStack.LoadAllSliceStacks(System.String,Claron.WIF.SliceStack.LoadProgressNotification,System.Boolean,System.Double,System.Boolean)">
            <summary>
            Searches the given directory, and, optionally, all its sub-directories, for DICOM image files,
            filters and organizes them into slice-stacks, and returns a list of all the slice-stacks
            found sorted by number of voxels (largest first!).
            </summary>
            <param name="folderFullPath">The full path of the folder to search (with or without terminating slash)</param>
            <param name="ProgressCallBack">If provided, will be called to report on progress approximately
            every 5%. Will not be called if no image files are found.</param>
            <param name="SearchSubfolders">If true, all sub-folders will be recursively searched for
            DICOM image files</param>
            <param name="sliceSpacingTolerance">The slice spacing tolerance (to identify inconsistent slices)</param>
            <param name="diffRcsUidOverride">If true, uniqueness of RcsUid is not checked for</param>
        </member>
        <member name="M:Claron.WIF.SliceStack.LoadSs(System.String,System.Collections.Generic.List{System.String}@)">
            <summary>
            Loads a slice stack from the given DICOM directory.
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.LoadSs(System.String,System.Boolean)">
            <summary>
            Loads a slice stack from the given DICOM directory.
            </summary>
            <param name="dcmDir">The path of the directory in which the image files reside</param>
            <param name="ForViewing">If true, the slice data may be remapped to ensure it
            can be displayed by the Camera class (U12 pixels only)</param>
        </member>
        <member name="M:Claron.WIF.SliceStack.LoadFromUsMultiFrameImage(System.String,System.Boolean)">
            <summary>
            Create slice stacks from an ultrasound multi-frame image
            </summary>
            <param name="filename"></param>
            <param name="toGrayscale">
            Whether to convert the image frames to gray-scale images, if true and the input image is an color image, the
            method will convert the frames into gray-scale images, otherwise, it will create 3 slice stacks with
            pixel data extracted independently from the frames' R G and B channels.
            The parameter takes no effects if the input image is an gray-scale image.
            </param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.SliceStack.LoadNextFiles(System.Collections.Specialized.StringCollection,System.Int32,System.Int32@,System.Collections.Generic.List{Claron.WIF.ImageU12}@)">
            <summary>
            Loads the next bunch of files from the prepared list of files to load.
            </summary>
            <param name="fullFilePaths">full paths to the dicom files to be loaded.</param>
            <param name="numFilesToLoadPerLoopBody">The number of files to load per loop body.</param>
            <param name="numFilesAlreadyProcessed">number of files already processed. Is updated inside the function.</param>
            <param name="sliceList">List of loaded image slices. Is updated inside the function.</param>
            <returns>True if more files are left to load, false when done.</returns>
            <remarks>
            The files must conform to DICOM part 10, or they will be skipped.
            </remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.FilterAndSortSlices(System.Collections.Generic.List{Claron.WIF.ImageU12},System.Double,System.Collections.Generic.List{System.String}@,System.Int32,System.Int32,System.Boolean,System.Double)">
            <summary>
            Returns an array of slices forming a coherent SliceStack in a right-handed grid
            </summary>
            <param name="SlicesList">The list of slices to be filtered and sorted (may be modified by the function).</param>
            <param name="SliceSpacingTolerance">The maximum tolerance fraction (0 to 1) for deviations in
            slice spacing from the most common spacing. For example, a tolerance
            of 0.1 means spacings of 0.9 to 1.1 times (+/-10%) are allowed in
            the filtered list.</param>
            <param name="outErrorMessages"></param>
            <param name="refSlcIndex"></param>
            <param name="maxInconsistentSlices"></param>
            <param name="diffRcsUidOverride"></param>
            <param name="sameOrientationThreshold"></param>
            <returns></returns>
            <remarks>
            When the filtering is done, the returned slice array is guaranteed to
            form a proper rectilinear grid with uniform spacing in each dimension.
            Slices that do not conform to the DICOM fields indicating they were acquired together
            at the same resolution (or are duplicates) are discarded.
            </remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.DoTiltCorrectionIfNecessary(Claron.WIF.ImageU12[])">
            <summary>
            Does tilt correction if necessary on the slice stack. Assumes that FilterAndSortSlices() has
            been called on the slice list.
            </summary>
            <param name="slicesArray">The array of ImageU12 objects to be tilt corrected.</param>
        </member>
        <member name="M:Claron.WIF.SliceStack.DoTiltCorrectionIfNecessary(Claron.WIF.ImageU12[],System.Int32,System.Double@)">
            <summary>
            Does tilt correction if necessary on the slice stack. Assumes that FilterAndSortSlices() has
            been called on the slice list.
            </summary>
            <param name="slicesArray">The array of ImageU12 objects to be tilt corrected.</param>
            <param name="maxInconsistentSlices">The maximum number of inconsistent contiguous slices allowed in each
            block.</param>
            <param name="tiltAngleRad">The tilt angle in radians. Should be used to </param>
        </member>
        <member name="M:Claron.WIF.SliceStack.CalculateAverageTiltAngle(System.Collections.Generic.SortedList{System.Double,Claron.WIF.ImageU12},System.Collections.Generic.IList{System.Double},System.Boolean[],System.Int32[])">
            <summary>
            Calculates the average tilt angle for the range of slices.
            </summary>
            <param name="orderedSlices"></param>
            <param name="SZs"></param>
            <param name="skewed">An array of values storing the skew condition of each slice.</param>
            <param name="blockI">The range of slice indices over which to calculate the tilt angle.</param>
        </member>
        <member name="M:Claron.WIF.SliceStack.TiltCorrectionUndo">
            <summary>
            Undoes tilt correction if necessary. Returns this slice stack unmodified if no tilt
            correction was done and no undo is necessary.
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.Save(System.String,System.String,System.String,System.String,System.Int32)">
             <summary>
            
             </summary>
             <param name="FolderPath"></param>
             <param name="SeriesUID"></param>
             <param name="NewPatientName">Default value = null</param>
             <param name="SeriesDescription">Default value = null</param>
             <param name="initialDcmI">The initial image number (default = 0).</param>
        </member>
        <member name="M:Claron.WIF.SliceStack.SaveAsFlatFile(System.String)">
            <summary>
            Saves the data as one big file (not as a series of DICOM images).
            </summary>
            <param name="FilePath">The file name to save to.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.SaveAsFlatFileCompressed(System.String)">
            <summary>
            Serialize to a single file (not as a series of DICOM images), compressed
            using GZIP.
            </summary>
            <param name="FilePath">The file name to save to (.gz extension
            will be added if not already provided).</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.LoadFromFlatFile(System.String)">
            <summary>
            Returns a new SliceStack loaded from a file containing a serialized SliceStack.
            </summary>
            <param name="filePath">The path to the file containing the slice stack.
            If the file name has a ".zip" extension, it is assumed to be compressed.</param>
        </member>
        <member name="M:Claron.WIF.SliceStack.LoadFromAnalyzeFormatFiles(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Returns a new SliceStack loaded from a header and pixel data file stored in the
            Analyze program's format. Currently, only binary(1), byte(2) and short(4) datatypes
            are supported.
            </summary>
            <param name="HeaderFilePath">The file containing the stack header.</param>
            <param name="PixelsFilePath">The file containing the pixels.</param>
            <param name="InvertYorder">If set, the y order of the rows will be inverted after the load</param>
            <param name="InvertZorder">If set, the z order will be inverted during the load (useful
            when the original data was stored by a program using a right-handed coordinate
            system.</param>
            <returns>The newly created SliceStack. If the path or contents of either of the files is
            invalid, an exception is thrown.
            </returns>
        </member>
        <member name="M:Claron.WIF.SliceStack.SaveAsJpg(System.String)">
            <summary>
            Saves the slice images as a individual JPEG formate files (75% quality).
            </summary>
            <param name="dirPathAndName">The base file name - each image will be saved with an index number appended</param>
        </member>
        <member name="M:Claron.WIF.SliceStack.GetBitvolOfNonTransparentVoxels(Claron.WIF.RenderingPreset,System.Double,System.Int32)">
            <summary>
            Returns a new BitVol where the non-transparent voxels in a shading transfer function
            are marked 1.
            </summary>
            <param name="preset">The preset to use in evaluating voxel transparency</param>
            <param name="OpacityThreshold0to1">The opacity (alpha) fraction above which voxels would
            be considered non-transparent (eg, 0.1).</param>
            <param name="DilateDiscreteCount">The bitvol can be dilated discretely by this count
            in order to include partial volume layers, improving shaded rendering</param>
            <returns></returns>
            <remarks>Currently implemented using only a single value threshold. Would work correctly
            on when the opacity is higher for voxel values above the threshold. </remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.GetBitvol">
            <summary>
            Returns a bitvol with all bits in the slice stack grid turned to 1.
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.AreSliceImagesIdentical(Claron.WIF.SliceStack,Claron.WIF.SliceStack)">
            <summary>
            Returns True if the slice images in the two slice stacks are identical, False otherwise.
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.ResampleSlices(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Re-samples all the slice images to a different resolution.
            Each slice image XY dimensions are modified to match the ones in a given grid while
            keeping the physical mappings the same.
            </summary>
            <param name="NewDimX">New X dimension samples count</param>
            <param name="NewDimY">New Y dimension samples count</param>
            <param name="UseBilinear">Use bilinear interpolation, otherwise nearest-neighbor</param>
            <remarks>
            2.487s for 512x512x1000 @ 1 threads, 4 cores, Intel i7 @ 2.67Ghz
            </remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.ReduceSlicesResolution(System.Int32)">
            <summary>
            Reduces the resolution of all slices by a factor N by averaging each NxN pixels
            neighborhood into a new pixel. Faster and more accurate than ResampleSlices()
            for resolution reduction by an integer factor.
            </summary>
            <param name="ReductionFactor">The decimation factor. Ignored if less than 2.</param>
        </member>
        <member name="M:Claron.WIF.SliceStack.EnsureGridAlignedWithLPH">
            <summary>
            Ensures that the data grid axes are (approximately) aligned with the
            PatientScan RCS axes - X->Left Y->Posterior and Z->Head. If needed, reorders the
            pixels in each slice and reorders the slices, in which case the ToPatientScan mapper is
            also modified to reflect the changes.
            Cannot properly handle non-axial slices. When the slices are coronal or sagittal,
            an exception will be raised.
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.DataAvailableMask">
            <summary>
            Computes a BitImage containing the "cookie cutter" shape in the XY plane that contains
            positive values in all slices (usually the reconstruction circle in CT).
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.EnsurePixelRangeCompatibility(System.Collections.Generic.List{Claron.WIF.ImageU12}@)">
            <summary>
            Ensures that the pixel values in the slices in a list are all with the U12 value range
            while using a uniform Pixel2ModalitySlope and Pixel2ModalityIntercept
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.EnsurePixelRangeCompatibility">
            <summary>
            Ensures that the pixel values in the slices in a list are all within the U12 value range
            while using a uniform Pixel2ModalitySlope and Pixel2ModalityIntercept
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.Subtract(Claron.WIF.SliceStack)">
            <summary>
            Subtracts from me the pixels values of another stack and returns the result as a new stack,
            with pixel values shifted and scaled to the proper range to be rendered. The slice stack to
            be subtracted can be arbitrarily oriented and have different dimensions with respect to the
            other slice stack.
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.ShrinkToSubVolume(Claron.WIF.BoxI32)">
            <summary>
            Shrinks the volume to a SubVolume with identical spacingMm between voxels,
            but the field of view reduced according to the given box.
            </summary>
            <param name="BoxSi">Bounding box of index ranged to be shrunk to</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.SubVolume(Claron.WIF.BoxI32)">
            <summary>
            Creates and returns a SubVolume with identical spacingMm between voxels,
            but the field of view reduced according to the given box.
            </summary>
            <param name="BoxSi">Bounding box of index ranged to be shrunk to</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.SubVolume(Claron.WIF.Vector3_I32,Claron.WIF.Vector3_I32,System.Boolean,System.Int16[0:,0:,0:])">
            <summary>
            Sets a given 3D array to values in a SubVolume of the stack. Less efficient than the 1D array version.
            </summary>
            <param name="MinIndexXYZ">The minimum stack index coordinate, corresponding to index (0,0,0) of the returned array</param>
            <param name="MaxIndexXYZ">The maximum index coordinates</param>
            <param name="ConvertToModalityValues">If true, the return values are in modality values (eg, HU for CT)</param>
            <param name="outVals">An array with sufficient size to accept the output.</param>
            <remarks>Values outside the stack bounds are set to 0.
            </remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.SubVolume(Claron.WIF.Vector3_I32,Claron.WIF.Vector3_I32,System.Boolean,System.Int16[])">
            <summary>
            Sets a given 1D array to values in a sub-volume of the stack, ordered sequentially. Efficient!
            Even more efficient is to access the ImageU12.values() array directly
            (i.e. make an array of the values array in all needed slices)
            </summary>
            <param name="MinIndexXYZ">The minimum stack index coordinate, corresponding to index (0) of the returned array</param>
            <param name="MaxIndexXYZ">The maximum index coordinates</param>
            <param name="ConvertToModalityValues">If true, the return values are in modality range (eg, HU)</param>
            <param name="outVals">An array with sufficient length to accept the output.</param>
            <remarks>Values outside the bounds are set to 0.
            </remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.SubVolumeHist(Claron.WIF.Box,System.Int32[]@)">
            <summary>
            Sets a given 1D array assumed to have at least 4096 entries to the counts of values in a sub-volume of the stack,
            Efficient!
            </summary>
            <param name="subVolBox">The box covering the area under which to compute the histogram.</param>
            <param name="counts">The array of counts. Does not get reset, just incremented with each voxel in the box.</param>
            <remarks>Values outside the bounds are ignored.
            </remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.SubVolumeHistSubSampled(Claron.WIF.Box,System.Int32,System.Int32[]@)">
            <summary>
            Sets a given 1D array assumed to have at least 4096 entries to the counts of values in a sub-volume of the stack,
            Efficient!
            </summary>
            <param name="subVolBox">The box covering the area under which to compute the histogram.</param>
            <param name="subSampleStepSizeYZ">Defines the step size to use in the y and z loop traversals.</param>
            <param name="counts">The array of counts. Does not get reset, just incremented with each voxel in the box.</param>
            <remarks>Values outside the bounds are ignored.
            </remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.GradientAt(System.Int32,System.Int32,System.Int32)">
            <summary>
            Computes the gradient vector at the given grid location (ie, voxel position), in Sr 
            (slice stack Rcs). Each component of the returned vector is an estimate of the 
            rate of increase of the modality value per mm along the corresponding axis direction.
            The location must be within the stack's bounds or an exception would be thrown.
            The gradient is computed efficiently using a Zucker-Hummel operator, which provides an
            accurate gradient estimate at a low noise sensitivity.
            If the point lies on a boundary, locations outside the boundary are ignored and only
            half the kernel is used.
            </summary>
            <param name="Xi">X index position in the grid, within bounds</param>
            <param name="Yi">Y index position in the grid, within bounds</param>
            <param name="Zi">Z index position in the grid, within bounds</param>
            <returns>The gradient vector, where each component is in modality value per mm.</returns>
        </member>
        <member name="M:Claron.WIF.SliceStack.GradientAt(Claron.WIF.Vector3_I32)">
            <summary>
            Computes the gradient vector at the given grid location (ie, voxel position), in Sr 
            (slice stack Rcs). Each component of the returned vector is an estimate of the 
            rate of increase of the modality value per mm along the corresponding axis direction.
            The location must be within the stack's bounds or an exception would be thrown.
            If the point lies on the grid boundary, locations outside the boundary are ignored and only
            half the kernel is used.
            </summary>
            <param name="XYZ">The index position in the grid, within bounds</param>
            <returns>The gradient vector, where each component is in modality value per mm.</returns>
        </member>
        <member name="M:Claron.WIF.SliceStack.GradientByCentralDifferenceAt(Claron.WIF.Vector3,System.Double)">
            <summary>
            Computes the gradient vector at the given (non integer) grid location (ie, voxel position), in Sr 
            (slice stack Rcs). Each component of the returned vector is an estimate of the 
            rate of increase of the modality value per mm along the corresponding axis direction.
            The gradient is computed using a central difference operator, taking the difference between 
            the values of trilinearly interpolated 6-neighbors, one index unit away in each direction.
            Compared to the Zucker-Hummel operator used in GradientAt, central difference is more locally
            accurate, but more sensitive to noise. It is also calculated efficiently on non-integer grid
            locations.
            If the point lies on, or near, the grid boundary, neighbor locations are clamped to grid boundary.
            </summary>
            <param name="PosSi">The index position in the grid</param>
            <param name="DistanceToNeighborsSi">The length of the forward/backwards step to take when sampling neighbors, 
            in index (voxel) units. Recommended value range is 0.2 to 1.</param>
            <returns>The gradient vector, where each component is in modality value per mm.
            When the given position is out of bounds, an invalid vector is returned.</returns>
        </member>
        <member name="M:Claron.WIF.SliceStack.CalculateGradientImageX(Claron.WIF.SliceStack)">
            <summary>
            Calculates the x-gradient image using central differences.
            </summary>
            <param name="ss">The input slice stack.</param>
        </member>
        <member name="M:Claron.WIF.SliceStack.SynthesizeContents(Claron.WIF.SliceStack.SyntheticShape)">
            <summary>
            Overwrites the contents of the stack with a synthesized contents of the specified pattern.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.HU(System.UInt16)">
            <summary>
            Convert a stored value to HU (assume CT data). Not fast enough for a critical loop
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.CTVal(System.Int32)">
            <summary>
            Convert a HU value to CT value (assume CT modality). Not fast enough for critical loops
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.ModalityValue(System.UInt16)">
            <summary>
            Convert a stored voxel value to modality value.
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.ModalityValue(System.Double)">
            <summary>
            Convert a stored voxel value to modality value.
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.ModalityValue(System.UInt16[])">
            <summary>
            Convert an array of stored voxel values to modality values (very efficient).
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.StoredValue(System.Double)">
            <summary>
            Return the stored pixel value for a given modality value.
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.StoredValue(System.Int32[])">
            <summary>
            Convert an array of modality values to stored pixel values (very efficient).
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.StoredValueFloatingPoint(System.Double)">
            <summary>
            Return the stored pixel value for a given modality value.
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.GetXZImage(System.Int32@)">
            <summary>
            Obtain a ("coronal") reformat through the stack. No interpolation is done, and the image has no DICOM header.!!
            </summary>
            <param name="y">Clipped to the valid range!!</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.GetYZImage(System.Int32@)">
            <summary>
            Obtain a ("saggital") reformat through the stack. No interpolation is done, and the image has no DICOM header.!!
            </summary>
            <param name="x">Clipped to the valid range!!</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.GetVoxelValue(System.Int32,System.Int32,System.Int32)">
            <summary>
            Function to get the voxel value at a specified position in the slice
            stack. Not an efficient way to access the stack in a loop!
            </summary>
            <param name="x">The x-coordinate (in image index coordinates).</param>
            <param name="y">The y-coordinate (in image index coordinates).</param>
            <param name="z">The z-coordinate (the slice 0-based index in the stack).</param>
            <returns>The voxel value as a single float.</returns>
            <remarks>To ensure that the function is as fast as possible, no
            bounds checking is done.</remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.SetAllVoxelValues(System.Int16)">
            <summary>
            Sets all voxels in the slice stack to the given value.
            </summary>
            <param name="val">The value to set all voxel values to.</param>
        </member>
        <member name="M:Claron.WIF.SliceStack.GetNearestNeighborVoxelValue(System.Double,System.Double,System.Double)">
            <summary>
            Function to get the voxel value at a specified position in the slice
            stack using nearest neighbor interpolation.
            </summary>
            <param name="x">The x-coordinate (in slice stack grid
            coordinates).</param>
            <param name="y">The y-coordinate (in slice stack grid
            coordinates).</param>
            <param name="z">The z-coordinate (in slice stack grid
            coordinates).</param>
            <returns>The voxel value as a single float.</returns>
            <remarks>To ensure that the function is as fast as possible, no
            bounds checking is done.</remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.GetInterpolatedVoxelValue(System.Double,System.Double,System.Double)">
            <summary>
            Computes the (stored) voxel value at a specified index position in the slice
            stack using trilinear interpolation. Highly efficient, but usually blocked waiting
            for input date to arrive.
            </summary>
            <param name="xSi">The x coordinate in stack index RCS</param>
            <param name="ySi">The y coordinate in stack index RCS</param>
            <param name="zSi">The z coordinate in stack index RCS</param>
            <returns>The interpolated voxel value.</returns>
            <remarks>No bounds checking is done. Will throw an exception if out of bounds.</remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.GetInterpolatedVoxelValue(Claron.WIF.Vector3)">
            <summary>
            Computes the (stored) voxel value at a specified index position in the slice
            stack using trilinear interpolation. Highly efficient, but usually blocked waiting
            for input date to arrive.
            </summary>
            <param name="PosSi">The position in stack index coordinates</param>
            <returns>The interpolated voxel value.</returns>
            <remarks>No bounds checking is done. Will throw an exception if out of bounds.</remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.GetInterpolatedModalityValue(Claron.WIF.Vector3)">
            <summary>
            Computes the modality voxel value at a specified index position in the slice
            stack using trilinear interpolation. Highly efficient, but usually blocked waiting
            for input date to arrive.
            </summary>
            <param name="PosSi">The position in stack index coordinates</param>
            <returns>The interpolated voxel value mapped to the modality value range.</returns>
            <remarks>No bounds checking is done. Will throw an exception if out of bounds.</remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.AverageDown(Claron.WIF.Vector3_I32)">
            <summary>
            Resamples the slice stack to a new size based on the pixel
            spacingMm size factor.
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.AverageDownThreadSub(System.Object)">
            <summary>
            Thread sub for averaging down a slice stack.
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.SerializeToFile(System.String)">
            <summary>
            Serializes the given stack to a file.
            </summary>
            <param name="pathAndfileName">If not provided, will store in the temp file "ss.dat". Default value = ""</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.SerializeToStream(System.IO.FileStream)">
            <summary>
            Serializes the stack to the given stream. Note that the stream is not closed after the
            slice stack has been serialized.
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.DeserializeFromFile(System.String)">
            <summary>
            De-serializes from a file to the given stack
            </summary>
            <param name="pathAndfileName">If not provided, will restore from the temp file "ss.dat". Default value = ""</param>
        </member>
        <member name="M:Claron.WIF.SliceStack.DeserializeFromStream(System.IO.Stream)">
            <summary>
            De-serializes from a stream.
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.CreateSphere(Claron.WIF.SpaceMapperSimilarity,Claron.WIF.GridBox)">
            <summary>
            Creates a single sphere.
            </summary>
            <param name="mapper">Optional mapper to re position or resize the sphere in the volume.
            When null, the sphere is centered with a diameter of 50mm.</param>
            <param name="grid">Optional grid to specify the dimensions and spacingMm of the slice stack
            to create and place the sphere in. When null, a default 512x512x256 slices stack
            with 0.4x0.4x0.8 mm spacingMm would be created.</param>
        </member>
        <member name="M:Claron.WIF.SliceStack.CreateSphereThreadSub(System.Int32,System.Int32,System.Object,System.Exception@)">
            <summary>
            Thread sub for creating a sphere.
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.CreateCube(Claron.WIF.SpaceMapperSimilarity,Claron.WIF.GridBox)">
            <summary>
            Creates a single cube.
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.CreateCubeThreadSub(System.Object)">
            <summary>
            Thread sub for creating a cube.
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.CreateCheckeredCube">
            <summary>
            Creates a checkered cube.
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.CreateCheckeredCubeThreadSub(System.Object)">
            <summary>
            Thread sub for creating checkered cube.
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStack.CreateSpheresAndBarsNotRotationalSymmetric(Claron.WIF.GridBox)">
            <summary>
            Creates simulated data and represents it as a stack of images.
            </summary>
            <param name="gridBox">The desired destination grid. Can be null, which will default to a 64x64x64 grid.</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.StringScanconvertIntoSliceStack(System.String,Claron.WIF.Vector3_I32,System.Single)">
            <summary>
            IB Works in progress, needs validation
            </summary>
            <param name="s"></param>
            <param name="pos"></param>
            <param name="scale"></param>
        </member>
        <member name="P:Claron.WIF.SliceStack.BrickMaxValSs">
            <summary>
            Slice stack to hold the maximum stored value in each brick of the current slice stack.
            </summary>
        </member>
        <member name="P:Claron.WIF.SliceStack.SliceImages">
            <summary>
            Direct access to the array of slice images managed by the SS.
            Fast and cheap when the images are local, but very slow when remoting to a server.
            </summary>
        </member>
        <member name="P:Claron.WIF.SliceStack.SeriesInstanceUid">
            <summary>
            Returns the series instance Uid.
            </summary>
        </member>
        <member name="P:Claron.WIF.SliceStack.AcquisitionDateTime">
            <summary>
            A safe way to access Info(InfoTag.AcquisitionDateTime). Looks after the case
            where the info string is not a valid DateTime representation.
            </summary>
        </member>
        <member name="P:Claron.WIF.SliceStack.ContentDateTime">
            <summary>
            A safe way to access Info(InfoTag.ContentDateTime). Looks after the case
            where the info string is not a valid DateTime representation.
            </summary>
        </member>
        <member name="P:Claron.WIF.SliceStack.PatientScanRCS">
            <summary>
            The patient scan's RCS in which the stack is positioned
            </summary>
        </member>
        <member name="P:Claron.WIF.SliceStack.GravityInGridRCS">
            <summary>
            A unit vector in the direction of gravity in the GridBox RCS. May be Nothing if unknown.
            </summary>
        </member>
        <member name="P:Claron.WIF.SliceStack.HeadDirectionInPatientScanRCS">
            <summary>
            A unit vector in the head (superior) direction in patient scan RCS.
            </summary>
        </member>
        <member name="P:Claron.WIF.SliceStack.ToPatientScan">
            <summary>
            The Stack's coordinate mapping to the patient scan RCS - same as the Grid's (convenience)
            </summary>
        </member>
        <member name="P:Claron.WIF.SliceStack.DimX">
            <summary>
            Convenience function for getting the number of voxels in the
            x-direction.
            </summary>
            <returns>The number of voxels in the x-direction.</returns>
        </member>
        <member name="P:Claron.WIF.SliceStack.DimY">
            <summary>
            Convenience function for getting the number of voxels in the
            y-direction.
            </summary>
            <returns>The number of voxels in the y-direction.</returns>
        </member>
        <member name="P:Claron.WIF.SliceStack.DimZ">
            <summary>
            Convenience function for getting the number of voxels in the
            z-direction.
            </summary>
            <returns>The number of voxels in the z-direction.</returns>
        </member>
        <member name="P:Claron.WIF.SliceStack.SpacingMM">
            <summary>
            The spacing in MM between adjacent voxels.
            </summary>
        </member>
        <member name="P:Claron.WIF.SliceStack.MaxInconsistentSlices">
             <summary>
             The maximum number of slices which can be missing, have an inconsistent spacing, or have an
             inconsistent tilt which will be corrected. If non-zero then any missing slices will be
             interpolated, any inconsistencies in spacing will be corrected, and any inconsistencies in
             tilt will also be corrected up to the maximum number of slices set.
            
             The recommended value for this property is 0, so that no correction will be made. In this case
             the largest contiguous block of consistently spaced and tilted slices will be loaded. If
             however it is very important that all slices be loaded then it is recommended to set this
             property value to either 1, 2, or 3 at a maximum.
             </summary>
        </member>
        <member name="P:Claron.WIF.SliceStack.SkewedThreshold">
            <summary>
            Threshold for gantry tilt correction. There is no correction for slices.
            </summary>
        </member>
        <member name="P:Claron.WIF.SliceStack.SlicesSameOrientationThreshold">
            <summary>
            Threshold for detecting if all the slices have the same orientation.
            </summary>
        </member>
        <member name="P:Claron.WIF.SliceStack.MinStoredValue">
            <summary>
            Property for getting the minimum stored voxel value in the slice stack.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.SliceStack.MaxStoredValue">
            <summary>
            Property for getting the maximum voxel value in the slice stack.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.SliceStack.AllHeaderTags">
            <summary>
            Returns a dictionary of name-value pairs of all recognized DICOM header fields of the first slice in the stack.
            </summary>
        </member>
        <member name="P:Claron.WIF.SliceStack.AllHeaderTagsLast">
            <summary>
            Returns a dictionary of name-value pairs of all recognized DICOM header fields of the last slice in the stack.
            </summary>
        </member>
        <member name="P:Claron.WIF.SliceStack.CardiacProtocol">
            <summary>
            Returns true iff the stack was (probably) acquired using a cardiac protocol
            </summary>
        </member>
        <member name="P:Claron.WIF.SliceStack.HistogramInt">
            <summary>
            Like Histogram(), but returns a histogram of integers, with
            entry 0 corresponding to StoredValueRangeMin.
            Sized to contain only up to the largest non-zero entry (useful for plotting).
            </summary>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.SliceStack.IsPseudoSpacing">
            <summary>
            Get/Set property indicating if the pixel spacing is synthetic
            </summary>
        </member>
        <member name="T:Claron.WIF.SliceStack.LoadProgressNotification">
            <summary>
            A callback function for reporting progress during slice stack file loading
            </summary>
            <param name="FractionAccomplished0To1">Fraction accomplished for progress bar or similar</param>
            <param name="ProgressMessage">Message to report to users on what has been achieved</param>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.SliceStack.AverageDownThreadParams">
            <summary>
            Thread parameters for averaging down a slice stack.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.SliceStack.AverageDownThreadParams._ssT">
            <summary>
            The target slice stack (stack storing the averaged down values).
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.SliceStack.AverageDownThreadParams._kRange">
            <summary>
            The slice range in the target slice stack which is allocated to a thread.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.SliceStack.AverageDownThreadParams._pixelSizeFactor">
            <summary>
            The pixel size factor.
            </summary>
        </member>
        <member name="T:Claron.WIF.SliceStack.CreateSphereThreadParameters">
            <summary>
            Thread parameters for generating iso-surface.
            </summary>
        </member>
        <member name="T:Claron.WIF.SliceStack.Iter">
            <summary>
            Iterator for slice stacks.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.SliceStack.Iter._ss">
            <summary>
            The slice stack.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.SliceStack.Iter._dims">
            <summary>
            The slice stack dimensions.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.SliceStack.Iter._x">
            <summary>
            The current x position in the slice stack.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.SliceStack.Iter._y">
            <summary>
            The current y position in the slice stack.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.SliceStack.Iter._z">
            <summary>
            The current z position in the slice stack.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.SliceStack.Iter._imageValues">
            <summary>
            Pointers to the image values in each slice.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.SliceStack.Iter._sliceIndex">
            <summary>
            The current image value index in a slice.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.SliceStack.Iter._maxSliceIndex">
            <summary>
            The maximum image value index in an individual slice.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.Iter.#ctor(Claron.WIF.SliceStack,Claron.WIF.Vector3_I32)">
            <summary>
            Creates a new slice stack iterator with the iterator initialized
            to the given position.
            </summary>
            <param name="ss">The slice stack.</param>
            <param name="xyz">The iterator's position.</param>
            <remarks>The position must fall within the bounds of the
            slice stack.</remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.Iter.#ctor(Claron.WIF.SliceStack)">
            <summary>
            Initializes the slice stack iterator to the start of the image.
            </summary>
            <param name="ss"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.Iter.Initialize(Claron.WIF.SliceStack,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes the pointers to the slices in the stack.
            </summary>
            <param name="ss">The slice stack.</param>
            <param name="x">The start x position.</param>
            <param name="y">The start y position.</param>
            <param name="z">The start z position.</param>
            <remarks>The position must fall within the bounds of the slice
            stack.</remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.Iter.NextVoxel">
            <summary>
            Moves to the next voxel.
            </summary>
            <returns>Returns true if the iterator is still in the bounds of
            the slice stack, false otherwise.</returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.SliceStack.Iter.Value">
            <summary>
            Returns the slice stack value.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.SliceStack.MappedGridIndexIterator">
            <summary>
            Class for iterating through a slice stack and mapping the slice stack
            grid index position into a grid index position in another slice stack.
            </summary>
        </member>
        <member name="F:Claron.WIF.SliceStack.MappedGridIndexIterator._ss">
            <summary>
            The slice stack to iterate over.
            </summary>
        </member>
        <member name="F:Claron.WIF.SliceStack.MappedGridIndexIterator._currentSlice">
            <summary>
            The current slice in the slice stack.
            </summary>
        </member>
        <member name="F:Claron.WIF.SliceStack.MappedGridIndexIterator._voxelValues">
            <summary>
            The voxel values in the current slice.
            </summary>
        </member>
        <member name="F:Claron.WIF.SliceStack.MappedGridIndexIterator._index">
            <summary>
            The index into the voxel values array.
            </summary>
        </member>
        <member name="F:Claron.WIF.SliceStack.MappedGridIndexIterator._indexNextRowOffset">
            <summary>
            Index offset in the pixel values array to move to the next row.
            </summary>
        </member>
        <member name="F:Claron.WIF.SliceStack.MappedGridIndexIterator._dims">
            <summary>
            The dimensions of the slice stack.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.SliceStack.MappedGridIndexIterator._matrix">
            <summary>
            A matrix to map from the grid in which the iterator does the
            traversal of the slice stack into another grid. The mapping is done
            in index coordinates.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.SliceStack.MappedGridIndexIterator._indexPos">
            <summary>
            The current position of the iterator in the slice stack in grid index
            coordinates.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.SliceStack.MappedGridIndexIterator._indexStep">
            <summary>
            The increment of the position of the iterator in grid index
            coordinates in the x, y, and z directions.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.SliceStack.MappedGridIndexIterator._indexMaxPos">
            <summary>
            The maximum grid index position of the iterator in the x, y, and z
            directions.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.SliceStack.MappedGridIndexIterator._mappedIndexPos">
            <summary>
            The current position of the iterator in index coordinates in the
            mapped grid box.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.SliceStack.MappedGridIndexIterator._incVecX">
            <summary>
            The incremental vector in the mapped grid box when the current index
            position is incremented by the index step in the x direction.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.SliceStack.MappedGridIndexIterator._incVecY">
            <summary>
            The incremental vector in the mapped grid box when the current index
            position is incremented by the index step in the y direction.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.SliceStack.MappedGridIndexIterator._incVecZ">
            <summary>
            The incremental vector in the mapped grid box when the current index
            position is incremented by the index step in the z direction.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.SliceStack.MappedGridIndexIterator._mappedRowVector">
            <summary>
            The vector in the mapped grid box corresponding to one whole row of
            voxels in the slice stack grid.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.SliceStack.MappedGridIndexIterator._mappedColumnVector">
            <summary>
            The vector in the mapped grid box corresponding to one whole column of
            voxels in the slice stack grid.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.MappedGridIndexIterator.#ctor(Claron.WIF.SliceStack,System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes the iterator.
            </summary>
            <param name="ss">The slice stack to iterate through.</param>
            <param name="matrix">A 4x4 matrix which maps from the grid in which
            the iterator does the traversal of the slice stack into another grid.
            The mapping should done in index coordinates.</param>
            <param name="sx">The grid index step in the x direction. Default value = 1</param>
            <param name="sy">The grid index step in the y direction. Default value = 1</param>
            <param name="sz">The grid index step in the z direction. Default value = 1</param>
            <remarks>The 4x4 matrix can be obtained by using the
            GridBox.HomoMat4x4GridTo() function.</remarks>
        </member>
        <member name="M:Claron.WIF.SliceStack.MappedGridIndexIterator.NextPosition">
            <summary>
            Moves to the next position in the slice stack.
            </summary>
            <returns>Returns true if the iterator moved successfully to the
            next position or false otherwise.</returns>
        </member>
        <member name="P:Claron.WIF.SliceStack.MappedGridIndexIterator.Value">
            <summary>
            Gets/sets the voxel value at current position of the iterator.
            </summary>
        </member>
        <member name="P:Claron.WIF.SliceStack.MappedGridIndexIterator.GridIndexPos">
            <summary>
            Property to get/set the current position of the iterator in the
            slice stack grid in index coordinates.
            </summary>
            <value>The new position of the iterator in the slice stack grid in
            index coordinates.
            </value>
            <returns>The current position of the iterator in the slice stack
            grid in index coordinates.
            </returns>
            <remarks>The mapped position is updated accordingly.</remarks>
        </member>
        <member name="P:Claron.WIF.SliceStack.MappedGridIndexIterator.MappedIndexPos">
            <summary>
            Property to get the current position of the iterator in index
            coordinates in the mapped grid box.
            </summary>
            <returns>The current position of the iterator in index coordinates
            in the mapped grid box.
            </returns>
        </member>
        <member name="T:Claron.WIF.SliceStack.CreateSphereCubeParams">
            <summary>
            Thread parameters for creating a sphere/cube.
            </summary>
        </member>
        <member name="F:Claron.WIF.SliceStack.CreateSphereCubeParams._ss">
            <summary>
            The slice stack in which to create the sphere/cube.
            </summary>
        </member>
        <member name="F:Claron.WIF.SliceStack.CreateSphereCubeParams._r">
            <summary>
            The radius/length of the cube.
            </summary>
        </member>
        <member name="F:Claron.WIF.SliceStack.CreateSphereCubeParams._minK">
            <summary>
            The minimum z-slice associated with the thread.
            </summary>
        </member>
        <member name="F:Claron.WIF.SliceStack.CreateSphereCubeParams._maxK">
            <summary>
            The maximum z-slice associated with the thread.
            </summary>
        </member>
        <member name="F:Claron.WIF.SliceStack.CreateSphereCubeParams._mapper">
            <summary>
            Mapper used to transform cube/sphere.
            </summary>
        </member>
        <member name="T:Claron.WIF.SliceStackRemoter">
            <summary>
            Represent a remote (server-side) object, owned by a client-side SliceStack object, which
            manages fields kept on the server.
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStackRemoter.LoadFromDicomFiles(System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.String}@)">
            <summary>
            Loads the images from files (on the server)
            </summary>
        </member>
        <member name="M:Claron.WIF.SliceStackRemoter.GetThresholdedBitvol(System.Double,System.Int32)">
            <summary>
            Returns a bitvol at the given grid size, which has bits set by thresholding the
            slice stack at the given stored value.
            </summary>
            <param name="ThresholdModality"></param>
            <param name="DilateDiscreteCount">The BitVol can be dilated discretely by this count
            in order to include partial volume layers, improving shaded rendering</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStackRemoter.GetFullGridBitvol(Claron.WIF.GridBox)">
            <summary>
            Returns a full bitvol at the given gridbox dimensions.
            </summary>
            <param name="ssGrid"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStackRemoter.ResampleSlices(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Resamples all the slices and relocks them in memory.
            </summary>
            <param name="NewDimX"></param>
            <param name="NewDimY"></param>
            <param name="UseBilinear">Otherwise, nearest-neighbor</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.SliceStackRemoter.LocalProgressNotification(System.Double,System.String)">
            <summary>
            Callback for progress notification during image loading
            </summary>
        </member>
        <member name="P:Claron.WIF.SliceStackRemoter.IsPseudoSpacing">
            <summary>
            Get/Set property indicating if the pixel spacing is synthetic
            </summary>
        </member>
        <member name="T:Claron.WIF.Surface">
            <summary>
            Class to represent a triangulated surface in 3D space.
            The surface is stored as a list of vertices in its own coordinate system
            It provides methods for creating a triangulated iso-surface from a SliceStack and for
            scan-converting a closed surface to a BitVol.
            </summary>
        </member>
        <member name="F:Claron.WIF.Surface._vertices">
            <summary>
            The vertices of the surface, each as a full 3D coordinate.
            </summary>
        </member>
        <member name="M:Claron.WIF.Surface.VerticesCount">
            <summary>
            Returns the number of vertices in the mesh.
            </summary>
        </member>
        <member name="M:Claron.WIF.Surface.SaveToFile(System.String)">
            <summary>
            Saves the surface to a file.
            </summary>
            <param name="filePath">The path to save the surface.</param>
        </member>
        <member name="M:Claron.WIF.Surface.SaveToStream(System.IO.Stream)">
            <summary>
            Saves the surface to a stream.
            </summary>
            <param name="oStream">The stream to save to.</param>
        </member>
        <member name="M:Claron.WIF.Surface.LoadFromFile(System.String)">
            <summary>
            Loads the surface from a file.
            </summary>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Surface.NewBox(Claron.WIF.GridBox,Claron.WIF.Box)">
            <summary>
            Returns a new surface bounding the given box.
            </summary>
            <param name="grid">The </param>
            <param name="box"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Surface.#ctor(Claron.WIF.GridBox)">
            <summary>
            Creates a new surface.
            </summary>
            <param name="grid">The grid representing the RCS of this surface. Usually
            mapped to a Patient scan RCS</param>
        </member>
        <member name="M:Claron.WIF.Surface.Copy">
            <summary>
            Returns a copy of this surface.
            </summary>
        </member>
        <member name="M:Claron.WIF.Surface.AddVertex(Claron.WIF.Vector3)">
            <summary>
            Adds a vertex to the surface at the end of the list of vertices.
            </summary>
        </member>
        <member name="M:Claron.WIF.Surface.AddVertices(Claron.WIF.Vector3[])">
            <summary>
            Adds one or more vertices to the surface at the end of the list of vertices.
            </summary>
        </member>
        <member name="M:Claron.WIF.Surface.Map(Claron.WIF.SpaceMapperSimilarity)">
            <summary>
            Maps all the vertices to a new RCS
            </summary>
            <param name="MapperToNewRcs"></param>
        </member>
        <member name="M:Claron.WIF.Surface.AddTriangle(Claron.WIF.Vector3_I32)">
            <summary>
            Adds a triangle to the surface at the end of the list of triangles.
            The triangle is defined as a triplet of vertex indices, ordered clockwise
            when viewed from outside the surface.
            </summary>
        </member>
        <member name="M:Claron.WIF.Surface.AddConvexPolygon(System.Int32[])">
            <summary>
            Adds a convex polygon to the surface. The polygon is decomposed into triangles sharing the
            first vertex.
            Note that if the polygon is not flat, the decomposition will create a multi-faceted surface.
            </summary>
            <param name="VertexIndices">A list of the vertex indices in clockwise order when viewed
            from the outside.</param>
        </member>
        <member name="M:Claron.WIF.Surface.AddTriangles(Claron.WIF.Vector3_I32[])">
            <summary>
            Adds one or more triangles to the surface.
            Each triangle is defined as a triplet of vertex indices, ordered clockwise
            when viewed from outside the surface.
            </summary>
        </member>
        <member name="M:Claron.WIF.Surface.MinCoord">
            <summary>
            Computes and returns the minimum value of each coordinates in all the vertices.
            Returns an invalid vector if there are no vertices.
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Surface.MaxCoord">
            <summary>
            Computes and returns the maximum value of each coordinates in all the vertices.
            Returns an invalid vector if there are no vertices.
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Surface.SamplePointsOnSurface(System.Int32)">
            <summary>
            Samples points on this surface.
            </summary>
            <param name="nSamples">The number of surface point samples to take along one of the sides of
            the triangle. If nSamples is equal to 1 then the vertices of the surface are returned.
            </param>
        </member>
        <member name="F:Claron.WIF.Surface._centerOfGravity">
            <summary>
            Returns the center of gravity of the surface.
            </summary>
        </member>
        <member name="F:Claron.WIF.Surface._radiusAverage">
            <summary>
            Returns the root mean squared value of the distances of the vertices from the center of
            gravity of the surface.
            </summary>
        </member>
        <member name="F:Claron.WIF.Surface._bboxLastUpdateTicks">
            <summary>
            Calculates the bounding box of the surface.
            </summary>
            <returns>Returns the bounding box of the Surface (in the RCS its vertices are specified.)</returns>
            <remarks>lazily evaluates the </remarks>
        </member>
        <member name="F:Claron.WIF.Surface._imageContoursOfLargestSlice">
            <summary>
            Returns the largest axial slice in the surface (in the RCS its vertices are specified)
            assuming it is closed and non self-intersecting.
            </summary>
            <returns>the largest slice in the surface</returns>
            <remarks>Value is calculated on demand whenever stale and cached</remarks>
        </member>
        <member name="M:Claron.WIF.Surface.Slices">
            <summary>
            Obtain all slices corresponding to this surface
            </summary>
            <returns>an enumeration of slices</returns>
        </member>
        <member name="M:Claron.WIF.Surface.ScanConvertToBitvol(Claron.WIF.BitVol)">
            <summary>
            Assuming the surface is closed and the vertex coordinates are in patientScan space,
            Sets to 1 each location in a given bitvol that fall on the inside of the surface (ie,
            where an imaginary person standing at that location would be able to see the inside side of at least
            a portion of one triangle.
            </summary>
            <param name="BV">The bitvol to modify. Its Grid must be mapped to PatientScan space.</param>
            <remarks>For most surfaces, the execution time is dominated by the number of bits
            turned on in the volume, rather than the triangle _ in the surface.</remarks>
        </member>
        <member name="M:Claron.WIF.Surface.ScanConvertToBitvol(System.Collections.Generic.List{Claron.WIF.Vector3},System.Collections.Generic.List{Claron.WIF.Vector3_I32},Claron.WIF.BitVol)">
            <summary>
            Assuming the surface is closed and the vertex coordinates are in patientScan space,
            Sets to 1 each location in a given bitvol that fall on the inside of the surface (ie,
            where an imaginary person standing at that location would be able to see the inside side of at least
            a portion of one triangle.
            </summary>
            <param name="vertices">The vertices of the surface</param>
            <param name="triangles">The triangles of the surface</param>
            <param name="BV">The bitvol to modify. Its Grid must be mapped to PatientScan space.</param>
            <remarks>For most surfaces, the execution time is dominated by the number of bits
            turned on in the volume, rather than the triangle _ in the surface.</remarks>
        </member>
        <member name="M:Claron.WIF.Surface.ScanconvertTriangleToIbuf(System.Collections.Generic.List{Claron.WIF.Surface.Intersection}[],System.Int32,Claron.WIF.Vector3[])">
            <summary>
            Scans a triangle to X intersections buffer. Inserts the intersections in order.
            </summary>
            <param name="Ibuf"></param>
            <param name="IColumns"></param>
            <param name="V">The vertices of the triangles in 0-based Ibuf coordinates</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Surface.ScanConvertLadder(System.Collections.Generic.List{Claron.WIF.Surface.Intersection}[],System.Int32,Claron.WIF.Vector3,Claron.WIF.Vector3,Claron.WIF.Vector3,Claron.WIF.Vector3,System.Boolean)">
            <summary>
            Scanconverts the region between two lines, "left" and "right", into iBuf (YZ buffer of X intersections).
            The tops and bottom Z coordinates of the lines are the same (ie, they form a "ladder" of Z lines).
            The lines do not intersect, and either the top or bottom position are the same.
            The output intersections are written to iBuf in a sorted X order.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Surface.ComputeDistVerticesToPlane">
            <summary>
            Compute distance for each vertex from plane derived by rotation matrix
            _pat2VpRcs and point defined by _focus and saves it in field DistToPlane of vertex
            For vertices in vicinity of plane( |dist| smaller than 0.01mm )
            fakes distance so that it would be bigger than 0.01mm 
            without actually moving vertex
            </summary>
        </member>
        <member name="M:Claron.WIF.Surface.PlaneContours(Claron.WIF.SpaceMapperSimilarity,Claron.WIF.Vector3,System.Collections.Generic.List{System.Int32[]}@,System.Collections.Generic.List{System.Int32[]}@)">
            <summary>
            Wrapper for the following function without returned lists of 
            verticesIdxAbovePlane and verticesIdxBelowPlane
            </summary> TEMP Wrapper
            <param name="Pat2Vr"></param>
            <param name="FocusPosPr"></param>
            <param name="verticesIdxAbovePlane"></param>
            <param name="verticesIdxBelowPlane"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Surface.PlaneContours(Claron.WIF.SpaceMapperSimilarity,Claron.WIF.Vector3)">
            <summary>
            Contour of the surface in the plane defined by Pat2Vr rotation matrix
            and the point in plane FocusPosPr. Uses _mesh structure
            </summary>
            <param name="Pat2Vr"></param>
            <param name="FocusPosPr"></param>
            <returns></returns>
            <remarks> Function cannot be called multi-threaded </remarks> 
        </member>
        <member name="M:Claron.WIF.Surface.PlaneContoursNoMesh(Claron.WIF.SpaceMapperSimilarity,Claron.WIF.Vector3)">
            <summary>
            Wrapper for the following function without returned lists of 
            verticesIdxAbovePlane and verticesIdxBelowPlane
            </summary> TEMP Wrapper
            <param name="Pat2Vr"></param>
            <param name="FocusPosPr"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Surface.PlaneContoursNoMesh(Claron.WIF.SpaceMapperSimilarity,Claron.WIF.Vector3,System.Collections.Generic.List{System.Int32[]}@,System.Collections.Generic.List{System.Int32[]}@)">
            <summary>
            Contour of the surface in the xy-plane at z=0 (at the focus point)
            </summary>
            <param name="Pat2Vr"></param>
            <param name="FocusPosPr"></param>
            <param name="verticesIdxAbovePlane"></param>
            <param name="verticesIdxBelowPlane"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Surface.ClosestPointOnEdge(Claron.WIF.Vector3,System.Int32,System.Int32)">
            <summary>
            the vertex on the given edge closest to the given point PntPr. 
            </summary>
            <param name="PntPr">The query point in patient reference coordinates (Pr).</param>
            <param name="VertexIdxA">Index to first  edge vertex.</param>
            <param name="VertexIdxB">Index to second edge vertex.</param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Surface.EdgeClosestToPoint(Claron.WIF.Vector3,Claron.WIF.Vector3_I32,System.Int32@,System.Int32@)">
            <summary>
            The edge of a triangle closest to the given point.
            </summary>
            <param name="PntPr">The query point in patient reference coordinates (Pr).</param>
            <param name="Trig">The triangle for which to test the edges.</param>
            <param name="EdgeVertexIdxA">Is set to the closest edge's first  vertex index.</param>
            <param name="EdgeVertexIdxB">Is set to the closest edge's second vertex index.</param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Surface.ComputeFacesNormalsAndAreas(System.Double[]@)">
            <summary>
            Normals to all faces
            </summary>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Surface.FaceNormalAndArea(System.Int32,System.Double@)">
            <summary>
            Normal vector to face as vector product of 2 edges
            </summary>
            <param name="faceIdx"></param>
            <param name="faceArea"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Surface.GetHashCode">
            <summary>
            Returns the hash code for the surface.
            </summary>
        </member>
        <member name="M:Claron.WIF.Surface.Cut(Claron.WIF.Surface,Claron.WIF.BitVol)">
            <summary>
            Cut the tissue defined by surface with excluding BitVol.
            Assumes that tissue is star-shaped, so that vertices falling inside the BitVol
            are moved away along the vertex-to-CenterOfGravity vector.
            Assumes also that overlap is not too big: CenterOfGravity doesn't belong
            to BitVol
            </summary>
            <param name="surfaceToExclude"></param>
            <param name="bvToExclude"></param>
        </member>
        <member name="M:Claron.WIF.Surface.FaceCrossLine(Claron.WIF.Vector3_I32,Claron.WIF.Vector3,Claron.WIF.Vector3,System.Double@)">
            <summary>
            Find the intersection between face and line defined by 2 points vBgn and vEnd
            Also computes the sum distance of this intersection point to 3 vertices of the face
            </summary>
            <param name="face"></param>
            <param name="vBgn"></param>
            <param name="vEnd"></param>
            <param name="distToVertices"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Surface.InternalPoint(Claron.WIF.Vector3,Claron.WIF.Vector3[])">
            <summary>
            Defines if the point is inside surface or not
            </summary>
            <param name="p"></param>
            <param name="facesNormals"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Surface.SubdivideFace(System.Int32)">
            <summary>
            Subdivide triangular face into 4 triangles of half edge size
            </summary>
            <param name="tIdx"></param>
        </member>
        <member name="M:Claron.WIF.Surface.SplitFaceEdge(System.Int32,System.Int32,System.Int32)">
            <summary>
            In face iT split edge adjacent to face adjacentSubdividedFaceIdx
            </summary>
            <param name="iT"></param>
            <param name="vertexXIdx"></param>
            <param name="vertexYIdx"></param>
        </member>
        <member name="M:Claron.WIF.Surface.IsNewContourAcceptable(Claron.WIF.Vector3[])">
            <summary>
            Check if input of editing operation is acceptable:
            contour not too big or too far from existing one 
            </summary>
            <param name="newContourSegmentArray"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Surface.SnapToCurve(Claron.WIF.SpaceMapperSimilarity,System.Collections.Generic.List{Claron.WIF.Vector3},Claron.WIF.SliceStack)">
            <summary>
            Wrapper for main SnapToCurve() function
            </summary>
            <param name="pat2VpRcs"></param>
            <param name="newContourSegment"></param>
            <param name="ss"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Surface.SnapToCurve(Claron.WIF.SpaceMapperSimilarity,System.Collections.Generic.List{Claron.WIF.Vector3},System.Collections.Generic.List{Claron.WIF.Surface.vertexShift}@,System.Int32@,Claron.WIF.SliceStack)">
            <summary>
            Smooth editing of the surface by 
            (a) replacing segment of contour on plane in general position by new segment
            (b) smooth adjustment of vertices in vicinity of this segment
            Possible use cases:
            edit current contour on Viewport plane, including full new contour;
            cut surface by the plane of current contour, leaving the bigger remaining part;
            add new contour on the plane which previously haven't crossed the surface 
            and extend the surface to include this contour
            </summary>
            <param name="pat2VpRcs"></param>
            <param name="newContourSegment"></param>
            <param name="shifts"></param>
            <param name="nPositiveShifted"></param>
            <param name="ss"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Surface.NearestVertexIdx(Claron.WIF.Vector3)">
            <summary>
            The index of the vertex nearest to the given point.
            </summary>
            <param name="pntPr">The query point in patient reference coordinates (Pr).</param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Surface.InitLastEditingDataForDisplay(System.Collections.Generic.List{System.Int32},System.Collections.Generic.List{Claron.WIF.Vector3})">
            <summary>
            Allocate or clear arrays of last edited vertices and last edited edges.
            
            </summary>
            <param name="contour3DVerticesIdx"></param>
            <param name="targetPoints"></param>
        </member>
        <member name="M:Claron.WIF.Surface.FindBestRouteOnSurface(System.Int32,System.Int32,System.Collections.Generic.List{System.Int32}[],Claron.WIF.Curve,System.Collections.Generic.List{System.Int32})">
            <summary>
            Implements Dijkstra algorithm of search of the least cost route 
            on the graph
            </summary>
            <param name="bgnVertexIdx"></param>
            <param name="endVertexIdx"></param>
            <param name="adVerticesVertex"></param>
            <param name="curveToSnap"></param>
            <param name="VerticesToIgnoreList">Indices of the vertices on the surface that should be ignored, 
            i.e. those that were part of an optimal path of an earlirer sectian of the user curve.</param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Surface.FindPathOnSurfaceByPlaneSection(System.Collections.Generic.List{Claron.WIF.Vector3_I32}@,System.Collections.Generic.List{Claron.WIF.Vector3}@,Claron.WIF.Vector3[],System.Int32,System.Int32)">
            <summary>
            Build plane through vertex nearest to the center of editing curve
            and two vertices nearest to the end of the editing curve. The intersection
            of this plane with the surface is used as the edited contour
            </summary>
            <param name="edgesOnSurface"></param>
            <param name="pointsOnEdges"></param>
            <param name="targetCurve"></param>
            <param name="bgnCurveIdx"></param>
            <param name="endCurveIdx"></param>
        </member>
        <member name="M:Claron.WIF.Surface.EdgesOfPathOnSurface(System.Collections.Generic.List{System.Int32}@)">
            <summary>
            Improve path on the surface to be as straight as possible
            </summary>
            <param name="verticesOnSurfaceContourIdx"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Surface.FindVerticesAdjacentToVertex(System.Int32)">
            <summary>
            Returns the list of vertex IDs which are connected to the given vertex.
            </summary>
            <param name="id">The ID of the vertex to test.</param>
        </member>
        <member name="M:Claron.WIF.Surface.AdjustVertexToNearestPointOnTheEdge(Claron.WIF.Vector3,System.Int32@)">
            <summary>
            
            </summary>
            <param name="tPointPr"></param>
            <param name="vIdx"></param>
        </member>
        <member name="M:Claron.WIF.Surface.NearestToNewContourPlaneContour(Claron.WIF.Vector3[],Claron.WIF.Vector3_I32[]@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Find all contours in the plane of newContourSegment, 
            return the one which has min dist to segment Bgn point
            Assumes that newContourSegment is in the same plane with _focus
            </summary>
            <param name="newContourSegment"></param>
            <param name="contourEdgesIdx"></param>
            <param name="bgnEditedIdx"></param>
            <param name="endEditedIdx"></param>
            <param name="nContoursFound"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Surface.NearestToNewContourOtherPlaneContour(Claron.WIF.Vector3[],Claron.WIF.Vector3_I32[]@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Function is called in case plane of newContourSegment has no intersections
            with Surface. It looks for nearest contour in the plane parallel to plane of VP,
            shifted by whole number of pixMM in direction orthigonal to plane.
            </summary>
            <param name="newContourSegment"></param>
            <param name="contourEdgesIdx"></param>
            <param name="bgnEditedIdx"></param>
            <param name="endEditedIdx"></param>
            <param name="nContoursFound"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Surface.FindBgnEndEditForWholeContour(System.Int32@,System.Int32@,Claron.WIF.Vector3[],Claron.WIF.Vector3[])">
            <summary>
            
            </summary>
            <param name="bgnEditedIdx"></param>
            <param name="endEditedIdx"></param>
            <param name="contour"></param>
            <param name="newContour"></param>
        </member>
        <member name="M:Claron.WIF.Surface.SplitEdge(Claron.WIF.Vector3_I32)">
            <summary>
            Add new vertex in the middle of the edge, replace 2 adjacent to this edge faces by 
            4 new faces
            </summary>
            <param name="edge"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Surface.LockContourOutOfSegment(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Before performing editing operation on the part of plane contour lock the rest 
            of the contour by setting confidence = 1 for all vertices. The backUp array of values
            of confidence is returned and used later in UnLock function.
            </summary>
            <param name="contourVerticesIdx"></param>
            <param name="bgnEditedIdx"></param>
            <param name="endEditedIdx"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Surface.UnLockContourOutOfSegment(System.Double[],System.Int32[],System.Int32,System.Int32)">
            <summary>
            Restore values of confidence on contour vertices after editing
            </summary>
            <param name="confBackup"></param>
            <param name="contourVerticesIdx"></param>
            <param name="bgnEditedIdx"></param>
            <param name="endEditedIdx"></param>
        </member>
        <member name="M:Claron.WIF.Surface.CenterDistIdx(System.Int32,System.Int32,System.Double[],System.Double@)">
            <summary>
            Define which vertex on the contour has the most central position between _vertex[bgnEditedIdx]
            and _vertex[endEditedIdx]. The length along contour is considered.
            </summary>
            <param name="bgnEditedIdx"></param>
            <param name="endEditedIdx"></param>
            <param name="distAlongContour"></param>
            <param name="distCenterToEdge"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Surface.DefineIdxMaxShift(System.Int32,System.Int32,System.Int32[],System.Double[],System.Int32,System.Int32,Claron.WIF.Vector3[],System.Int32@,System.Double@)">
            <summary>
            
            </summary>
            <param name="bgnEditedIdx"></param>
            <param name="endEditedIdx"></param>
            <param name="contourVerticesIdx"></param>
            <param name="distAlongContour"></param>
            <param name="bgnNewContourIdx"></param>
            <param name="endNewContourIdx"></param>
            <param name="newContourSegmentArray"></param>
            <param name="newContourMaxShiftIdx"></param>
            <param name="distCenterToEdgeEdited"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.Surface.ReorderContour(System.Int32@,System.Int32@,Claron.WIF.Vector3[]@,Claron.WIF.Vector3[]@,Claron.WIF.Vector3_I32[]@,System.Boolean)">
            <summary>
            For editing of contour, reorder contour of surface on plane so that the first point of
            the newContourSegment applies to bgnEditedIdx, its last point - to endEditedIdx, and index
            of contour edges and points increases from bgnEditedIdx to endEditedIdx
            </summary>
            <param name="bgnEditedIdx"></param>
            <param name="endEditedIdx"></param>
            <param name="newContourSegment"></param>
            <param name="contour"></param>
            <param name="contourEdgesIdx"></param>
            <param name="wholeContour"></param>
        </member>
        <member name="M:Claron.WIF.Surface.ShuffleContourOnPlane(System.Int32@,System.Int32@,Claron.WIF.Vector3[]@,Claron.WIF.Vector3_I32[]@)">
            <summary>
            If the start-end points of adjusting segment are on 2 sides of contour start-end point -
            shuffle contour so that it starts from bgnIdx
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Surface.ReduceVerticesConfidence">
            <summary>
            Prototype.
            The behavior should consider the edge proximity: if the vertex is on the strong edge,
            its confidence stays high.
            </summary>
        </member>
        <member name="M:Claron.WIF.Surface.RemoveMultiEntryInvolvedVertices">
            <summary>
            Remove multiple indices from _involvedVerticesPerOneEdit list
            and populate _involvedFacesPerOneEdit list
            </summary>
        </member>
        <member name="M:Claron.WIF.Surface.GradientInVertex(System.Int32)">
            
             Private Function GradientInPix(ByVal pix As Vector3_I32, ByRef valueHu As Integer) As Vector3
             <summary>
             Note that this function considers values outside the volume as containing the stored value
             0.
             </summary>
             <returns></returns>
             <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Surface.CreateSphere(Claron.WIF.GridBox,System.Double,System.Int32,System.Int32)">
            <summary>
            Creates a sphere surface centered at the origin with the given radius by uniformly
            sampling the coordinates of the vertices of the sphere in spherical polar coordinates.
            </summary>
            <param name="r">The radius of the sphere.</param>
            <param name="nPhis">The number of samples in the theta direction (longitudinal direction).
            The range of phi is [0, 2 * Pi).</param>
            <param name="nThetas">The number of samples in the theta direction (latitudinal
            direction).
            The range of theta is [0, Pi).</param>
            <param name="gb"></param>
        </member>
        <member name="M:Claron.WIF.Surface.CreateOctahedronSubdividedSphere(Claron.WIF.GridBox,System.Double,System.Int32,System.Double[][]@,System.Double[][]@)">
            <summary>
            Creates a sphere by subdividing a octahedron.
            </summary>
            <param name="gb">The grid box for the sphere.</param>
            <param name="r">The radius of the sphere.</param>
            <param name="nSubdivs">The number of subdivisions to make.</param>
            <param name="phis">The angular portion of the spherical polar coordinates of the vertices.</param>
            <param name="thetas">The angular portion of the spherical polar coordinates of the vertices.</param>
            <returns>Returns a series of subdivided spheres.</returns>
        </member>
        <member name="M:Claron.WIF.Surface.GetSphericalPolarCoordinates(Claron.WIF.Vector3,System.Double@,System.Double@,System.Double@)">
            <summary>
            Returns the spherical polar coordinates of the given point.
            </summary>
            <param name="pt">The input point.</param>
            <param name="r">The distance of the point from the origin.</param>
            <param name="theta">The angle made by the radius vector with the z-axis.</param>
            <param name="phi">The angle made by the projection of radius vector onto the xy-plane with
            the x-axis.</param>
        </member>
        <member name="M:Claron.WIF.Surface.ResetOctahedronSubdividedSphere(Claron.WIF.Surface,System.Double)">
            <summary>
            Resets the vertex positions of the surface so that they lie on the surface of a sphere of
            radius r, centered at the origin.
            </summary>
            <param name="surface"></param>
            <param name="r"></param>
        </member>
        <member name="M:Claron.WIF.Surface.SubdivideOctahedronSphere(Claron.WIF.Surface,System.Double,System.Double[]@,System.Double[]@)">
            <summary>
            Subdivides the given octahedral surface.
            </summary>
            <param name="surface">The octahedron.</param>
            <param name="r">The radius of the sphere.</param>
            <param name="thetas">The angular portion of the spherical polar coordinates of the
            vertices.</param>
            <param name="phis">The angular portion of the spherical polar coordinates of the
            vertices.</param>
            <returns>The subdivided octahedron.</returns>
        </member>
        <member name="P:Claron.WIF.Surface.FriendlyName">
            <summary>
            An optional friendly (generally unique) name for this surface
            </summary>
        </member>
        <member name="P:Claron.WIF.Surface.AvailableMemory">
            <summary>
            Returns the available memory.
            </summary>
        </member>
        <member name="P:Claron.WIF.Surface.Vertices">
            <summary>
            Returns THE list of the vertices of the surface (not a copy!).
            </summary>
            <returns>The vertices by reference</returns>
        </member>
        <member name="P:Claron.WIF.Surface.Triangles">
            <summary>
            Returns THE list of the triangles defining the surface (not a copy!).
            </summary>
            <returns>The triangles list by reference.</returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Surface.Volume">
            <summary>
            Returns the volume of the surface (in the RCS its vertices are specified),
            assuming it is closed and non self-intersecting.
            Very fast and efficient.
            </summary>
            <remarks>The volume is calculated by summing, for each triangle in the mesh, the product
            (1/6)(z0+z1+z2) [ x0(y2-y1) + x1(y0-y2) + x2(y1-y0) ], which is the signed volume
            of the pyramid formed between the three vertices and the origin.
            The sign is positive or negative according to a sort of right-hand rule.</remarks>
        </member>
        <member name="P:Claron.WIF.Surface.VolumeAndLongAxisChangeMsg">
            <summary>
            Returns the volume of the surface (in the RCS its vertices are specified),
            assuming it is closed and non self-intersecting.
            Very fast and efficient.
            </summary>
            <remarks>The volume is calculated by summing, for each triangle in the mesh, the product
            (1/6)(z0+z1+z2) [ x0(y2-y1) + x1(y0-y2) + x2(y1-y0) ], which is the signed volume
            of the pyramid formed between the three vertices and the origin.
            The sign is positive or negative according to a sort of right-hand rule.</remarks>
        </member>
        <member name="T:Claron.WIF.Surface.ImageContours">
            <summary>
            All contours of the intersection of an original SliceStack image and the surface.
            </summary>
        </member>
        <member name="F:Claron.WIF.Surface.ImageContours.Contours">
            <summary>
            The list of contours (typically one) on the intersection for this slice
            </summary>
        </member>
        <member name="F:Claron.WIF.Surface.ImageContours._contourLargest">
            <summary>The contour in the original slice with the largest long axis.</summary>
        </member>
        <member name="P:Claron.WIF.Surface.ImageContours.LargestContour">
            <summary>The contour in the original slice with the largest long axis.</summary>
        </member>
        <member name="T:Claron.WIF.Surface.ImageContours.Axis">
            <summary>
            A line segment representing an axis of the intersection in the Patient RCS
            </summary>
        </member>
        <member name="T:Claron.WIF.Surface.ImageContours.Contour">
            <summary>
            A single contour of a surface-plane intersection and the corresponding major and minor axis (length and width) in Pr (Patient RCS)
            </summary>
        </member>
        <member name="T:Claron.WIF.Surface.Intersection">
            <summary>
            A single entry in Ibuf, representing a surface intersection
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.MarchingSquares">
            <summary>
            Class to generate a set of iso-contours from a 2D image.
            </summary>
        </member>
        <member name="F:Claron.WIF.MarchingSquares._isoLevelStored">
            <summary>
            The iso-level at which to generate the surface. All values less than the iso-level are
            outside of the surface, and all values greater than or equal to the iso-level are inside
            the surface.
            </summary>
        </member>
        <member name="F:Claron.WIF.MarchingSquares._img">
            <summary>
            The image from which to generate the iso-curves.
            </summary>
        </member>
        <member name="F:Claron.WIF.MarchingSquares._edgeTable">
            <summary>
            Table storing edges in a cell which intersect with the iso-curve.
            </summary>
        </member>
        <member name="F:Claron.WIF.MarchingSquares._linesTable">
            <summary>
            Table storing edges which must be connected to give the iso-curve in a cell.
            </summary>
        </member>
        <member name="F:Claron.WIF.MarchingSquares._vertices">
            <summary>
            The iso-surface vertices.
            </summary>
        </member>
        <member name="F:Claron.WIF.MarchingSquares._lines">
            <summary>
            The iso-surface lines.
            </summary>
        </member>
        <member name="F:Claron.WIF.MarchingSquares._curves">
            <summary>
            The iso-surface curves.
            </summary>
        </member>
        <member name="M:Claron.WIF.MarchingSquares.#ctor(Claron.WIF.ImageU12,System.Double)">
            <summary>
            Initializes the class and generates the curves from the image at the given iso-level.
            </summary>
            <param name="img">The image to generate the iso-curves from.</param>
            <param name="isoLevelStored">The iso-level to use when generating the iso-curves. All values
            less than the iso-level are outside of the surface, and all values greater than or equal
            to the iso-level are inside the surface.</param>
        </member>
        <member name="M:Claron.WIF.MarchingSquares.GenerateCurves">
            <summary>
            Generates the iso-curves.
            </summary>
        </member>
        <member name="M:Claron.WIF.MarchingSquares.RenameVerticesAndLines(System.Collections.Generic.Dictionary{System.Int32,Claron.WIF.Vector3},System.Collections.Generic.List{System.Int32[]})">
            <summary>
            Renames vertices and lines so that they can be efficiently accessed using arrays and
            also connects lines which have common end-points.
            </summary>
            <param name="id2Vector3">Dictionary which maps vertex IDs to Vector3 objects.</param>
            <param name="linesList">The list of lines to rename and connect.</param>
        </member>
        <member name="P:Claron.WIF.MarchingSquares.Vertices">
            <summary>
            The iso-surface vertices.
            </summary>
        </member>
        <member name="P:Claron.WIF.MarchingSquares.Lines">
            <summary>
            The iso-surface lines.
            </summary>
        </member>
        <member name="P:Claron.WIF.MarchingSquares.Curves">
            <summary>
            The iso-surface curves.
            </summary>
        </member>
        <member name="T:Claron.WIF.MarchingCubes">
             <summary>
             Class to polygonize a scalar field using the "Marching Cubes" algorithm. Based on explanation and
             source code at Paul Bourke's website:
            
             http://local.wasp.uwa.edu.au/~pbourke/geometry/polygonise/
             </summary>
        </member>
        <member name="F:Claron.WIF.MarchingCubes._edgeTable">
            <summary>
            The edge table.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.MarchingCubes._triTable">
            <summary>
            The triangle table.
            </summary>
        </member>
        <member name="F:Claron.WIF.MarchingCubes._ss">
            <summary>
            The slice stack.
            </summary>
        </member>
        <member name="F:Claron.WIF.MarchingCubes._grid">
            <summary>
            The slice stack.
            </summary>
        </member>
        <member name="F:Claron.WIF.MarchingCubes._isoLevel">
            <summary>
            The iso-level.
            </summary>
        </member>
        <member name="F:Claron.WIF.MarchingCubes._vertices">
            <summary>
            The vertices of the surface.
            </summary>
        </member>
        <member name="F:Claron.WIF.MarchingCubes._triangles">
            <summary>
            The ids of the vertices forming the triangles in the surface.
            </summary>
        </member>
        <member name="M:Claron.WIF.MarchingCubes.CalculateNormals">
            <summary>
            Returns the normals.
            </summary>
        </member>
        <member name="M:Claron.WIF.MarchingCubes.SurfacePrFromSs(Claron.WIF.SliceStack,System.Double,Claron.WIF.BitVol)">
            <summary>
            Returns a closed threshold iso-surface in a given slice-stack. The surface is in Patient RCS (Pr)
            of the SliceStack.
            </summary>
            <param name="ss">The slice stack to generate the iso-surface from.</param>
            <param name="mask">An optional mask bitvol in which to generate the surface (null if all the ss should be used).</param>
            <param name="isoLevelStored">The iso-level (stored value) at which to generate the surface. 
            All values less than the isoLevel or outside the Ss bounding box are outside the surface and all 
            values >= isoLevel are inside of the surface.</param>
        </member>
        <member name="M:Claron.WIF.MarchingCubes.#ctor(Claron.WIF.SliceStack,System.Double,Claron.WIF.BitVol,System.Boolean)">
            <summary>
            Creates a new "Marching Cubes" instance and creates a new surface in Pr of the given Ss.
            </summary>
            <param name="ss">The slice stack to generate the iso-surface from.</param>
            <param name="mask">A mask bitvol in which to generate the surface, or null if all the ss should be used.</param>
            <param name="assumeValuesOutsideBoundsAreBelowThreshold">If set to true then values outside
            of the bounds of the slice stack are assumed to below the iso-surface threshold.</param>
            <param name="isoLevelStored">The iso-level (stored value) at which to generate the surface. 
            All values less than the isoLevel are outside the surface and all 
            values >= isoLevel are inside of the surface.</param>
        </member>
        <member name="M:Claron.WIF.MarchingCubes.#ctor(Claron.WIF.BitVol)">
            <summary>
            Creates a new "Marching Cubes" instance.
            </summary>
            <param name="bvForSurface">A BitVol from which to generate the surface.</param>
        </member>
        <member name="M:Claron.WIF.MarchingCubes.GenerateSurfaceFromBv(Claron.WIF.BitVol)">
            <summary>
            Generates a new surface from the given BitVol.
            </summary>
        </member>
        <member name="M:Claron.WIF.MarchingCubes.GenerateSurfaceFromBvThreadSub(System.Int32,System.Int32,System.Object,System.Exception@)">
            <summary>
            Generates surface thread subroutine.
            </summary>
        </member>
        <member name="M:Claron.WIF.MarchingCubes.GenerateSurface(System.Double)">
            <summary>
            Generates a new surface from the stored slice stack at the specified threshold.
            </summary>
        </member>
        <member name="M:Claron.WIF.MarchingCubes.GenerateSurfaceThreadSub(System.Int32,System.Int32,System.Object,System.Exception@)">
            <summary>
            Generates surface thread subroutine.
            </summary>
        </member>
        <member name="M:Claron.WIF.MarchingCubes.CalculateIntersectionSi(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the position, in SS index coordinates, of the iso intersection
            at the given edge (0 to 11) at the cube with its min corner at x, y, z
            </summary>
        </member>
        <member name="M:Claron.WIF.MarchingCubes.SaveAsBinaryStlFile(System.String)">
            <summary>
            Saves the surface as a binary STL file. For more information about the file format see:
            
            http://en.wikipedia.org/wiki/STL_%28file_format%29
            </summary>
        </member>
        <member name="M:Claron.WIF.MarchingCubes.TestGenerateSphereBv(Claron.WIF.SliceStack@,Claron.WIF.BitVol@,Claron.WIF.BitVol@,Claron.WIF.BitVol@,Claron.WIF.BitVol@)">
            <summary>
            Test function for marching cubes class.
            </summary>
            <param name="ss"></param>
            <param name="bv0">BitVol from large ball surface.</param>
            <param name="bv1">BitVol from both inner balls union surface.</param>
            <param name="bv2">BitVol from brightest ball surface.</param>
            <param name="bv1b">BitVol from both inner balls union surface via GenerateSurfaceFromBv().</param>
        </member>
        <member name="M:Claron.WIF.MarchingCubes.BvToSurface(Claron.WIF.BitVol)">
            <summary>
            Using the Marching cubes algorithm for iso-value, create the surface of the BV by generating 
            auxiliary slice stack.
            </summary>
        </member>
        <member name="P:Claron.WIF.MarchingCubes.Vertices">
            <summary>
            Returns the vertices forming the iso-surface.
            </summary>
        </member>
        <member name="P:Claron.WIF.MarchingCubes.Triangles">
            <summary>
            Returns the triangles forming the iso-surface.
            </summary>
        </member>
        <member name="P:Claron.WIF.MarchingCubes.Mask">
            <summary>
            The bitvol mask.
            </summary>
        </member>
        <member name="P:Claron.WIF.MarchingCubes.AssumeValuesOutsideBoundsAreBelowThreshold">
            <summary>
            Property to get set whether values outside of the bounds of the stack
            are assumed to be below the threshold.
            </summary>
        </member>
        <member name="T:Claron.WIF.MarchingCubes.GenerateSurfaceFromBvThreadParameters">
            <summary>
            Thread parameters for generating iso-surface.
            </summary>
        </member>
        <member name="T:Claron.WIF.MarchingCubes.GenerateSurfaceThreadParameters">
            <summary>
            Thread parameters for generating iso-surface.
            </summary>
        </member>
        <member name="T:Claron.WIF.Tissue">
            <summary>
            The Tissue class represents a combination of a bitvol mask and a transfer function
            (ARGB look-up table). It handles the conversions between the native Bitvol format and the
            data structures required by VR2.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Tissue.#ctor(Claron.WIF.BitVol)">
            <summary>
            Creates a new tissue from the given BitVol, optionally truncating and shifting it to match a reference SliceStack
            </summary>
            <param name="BV">The source BitVol</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Tissue.#ctor(Claron.WIF.BitVol,Claron.WIF.SliceStack)">
            <summary>
            Creates a new tissue from the given BitVol, optionally truncating and shifting it to match a reference SliceStack
            </summary>
            <param name="BV">The source BitVol</param>
            <param name="RefSS">The slice stack in which the tissue should be positioned. If Nothing, then the BV's origin in the PatientScanRCS is assumed to be identical to the stack's. Default value = null</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Tissue.UnRegisterTissueRemoter">
            <summary>
            Unregister TissueRemoter
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Tissue.#ctor(System.String,System.Boolean)">
            <summary>
            Creates a new tissue using a BitVol loaded from a file (possibly on a remote machine)
            </summary>
            <param name="BitvolFilePath">The full path of the bitvol file (on the machine where it would be loaded)</param>
            <param name="UseRemoter">Indicates whether to use a remoter for loading and storing the bitvol</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Tissue.SetArgb(System.UInt32,System.UInt32[])">
            <summary>
            unconditionally set the argb mappings
            </summary>
            <param name="newRGB">The base color that is colorwashed on to all the visible voxels of the tissue</param>
            <param name="NewARGBLUTLut">Defines the visibility and intensity dependent colors of all the voxels in the tissue</param>
        </member>
        <member name="F:Claron.WIF.Tissue.BvLastConvertedToArray">
            <summary>
            A copy of the bitvol that was last converted to a BV array. Helps optimize
            the conversion, so only bricks that are different need to be converted.
            </summary>
        </member>
        <member name="M:Claron.WIF.Tissue.UpdateBvArrayAsNeeded">
            <summary>
            Updates the bitvol array buffer if BV has changed since the last time the buffer was updated
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Tissue.Lock">
            <summary>
            Locks the tissue in memory and returns a pointer to the header structure.
            If needed, the bitvol array is updated to reflect the bitvol contents.
            </summary>
            <returns></returns>
            <remarks>Should be freed ASAP afterwards</remarks>
        </member>
        <member name="M:Claron.WIF.Tissue.LockBV">
            <summary>
            Locks all the memory buffers and returns a pointer to the bitvol
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Tissue.Unlock">
            <summary>
            Unlocks the memory allocated, allowing it to be managed by the garbage collector
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Tissue.SetXferFunctionRamp(System.Int32,System.Int32,System.Double)">
            <summary>
            Generate Xfer function in RGB color with a ramp opacity function
            </summary>
            <param name="Center">The center of the ramp or tent</param>
            <param name="Width">The width</param>
            <param name="MaxOpacity0to1"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Tissue.XferFunction(System.Int32)">
            <summary>
            Returns the transfer function value for a given voxel value (0-based)
            </summary>
            <param name="VoxelValue"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Tissue.GetXferFunction">
            <summary>
            Returns the transfer function  for shaded
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Tissue.SetXferFunctionTent(System.Int32,System.Int32,System.Double)">
            <summary>
            Generate Xfer function in RGB color with a tent opacity function
            </summary>
            <param name="Center">The center of the tent</param>
            <param name="HalfWidth">The width of one side of the tent</param>
            <param name="MaxOpacity0to1">The maximum opacity at the tent's peak</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Tissue.SetXferFunction(System.UInt32[])">
            <summary>
            Sets the CT#->ARGB transfer function for this tissue based on the base RGB and the
            alpha values in ALUT
            </summary>
            <param name="ALUT">An array of 4096 or more elements, with 8msb specifying the alpha value</param>
        </member>
        <member name="M:Claron.WIF.Tissue.UpdateUids(System.Runtime.Serialization.StreamingContext)">
            <summary>
            The actual referenced data is not stored directly in serialization files, only its UID,
            which needs to be updated just before serializing.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Tissue.GetHashCode">
            <summary>
            Returns the hash code for the Tissue object.
            </summary>
        </member>
        <member name="P:Claron.WIF.Tissue.BaseArgb">
            <summary>
            ARGB 32b color to be applied uniformly to the tissue (in case a preset is not used)
            </summary>
        </member>
        <member name="P:Claron.WIF.Tissue.BaseArgbSlab">
            <summary>
            ARGB 32b color to be applied uniformly to the tissue (in case a preset is not used)
            </summary>
        </member>
        <member name="P:Claron.WIF.Tissue.BaseArgbWasSetByClient">
            <summary>
            Indicates whether any client set the BaseArgb or BaseColor property since
            the object was created (for Collage use in deciding whether to apply its default
            tissue color or not).
            </summary>
        </member>
        <member name="P:Claron.WIF.Tissue.BaseColor">
            <summary>
            Color to be applied uniformly to the tissue (in case a preset is not used) - same as BaseArgb
            but using the Color structure
            </summary>
        </member>
        <member name="P:Claron.WIF.Tissue.GlassFxArgb">
            <summary>
            ARGB 32b color to be applied uniformly to the tissue (if 0, the preset color/opacity is used)
            Note that only at mast 3 simultaneous GlassFX tissues are possible. 
            The first (tissue index 0) must have 0xFFU as BaseARGB, the second 0xFF00U and the third 0xFF0000U
            </summary>
        </member>
        <member name="P:Claron.WIF.Tissue.Name">
            <summary>
            A client-assigned name to the tissue. Changing the name is considered an update.
            </summary>
        </member>
        <member name="P:Claron.WIF.Tissue.IsEditable">
            <summary>
            For client use - indicates whether the user should be allowed to
            edit the tissue.
            </summary>
        </member>
        <member name="T:Claron.WIF.TissueRemoter">
            <summary>
            Represent a remote (server-side) object, owned by a client-side Tissue object, which
            manages a mirror-copy kept on the server, allowing server-side Camera objects
            read-only access to the tissue data-structures and properties without the need for a
            round-trip to the client.
            </summary>
        </member>
        <member name="M:Claron.WIF.DicomStuff.ModalityIsSupported(System.String)">
            <summary>
            Returns true if the given modality is supported by WIF
            </summary>
            <param name="ModalityName">a 2-letter DICOM modality name (see ModalityEnum)</param>
        </member>
        <member name="M:Claron.WIF.DicomStuff.SupportModality(System.String)">
            <summary>
            Sets the specified modality name as supported
            </summary>
            <param name="modality"></param>
        </member>
        <member name="M:Claron.WIF.DicomStuff.ExtractAllHeaderTags(ClearCanvas.Dicom.DicomAttributeCollection)">
            <summary>
            Returns a dictionary mapping names to values for all the DICOM header tags in
            a given DicomAttributeCollection.
            </summary>
            <param name="dac">The DicomAttributeCollection object, usually obtained from a DicomFile object.</param>
            <returns>A new dictionary containing the results.</returns>
        </member>
        <member name="F:Claron.WIF.DicomStuff.InfoTag.Modality">
            <summary>
             Modality string from DICOM, eg, "CT"/"MR"/"NM"/"PT"/"US"/"RTIMAGE"
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.DicomStuff.InfoTag.AcquisitionDateTime">
            <summary>
            Stored in a string format that can be converted to/from .NET Date
            </summary>
        </member>
        <member name="F:Claron.WIF.DicomStuff.InfoTag.PatientPositionInGantry">
            <summary>
            String of 3 letters, eg, "HFP" for head-first supine.
            Useful for finding which direction is down (gravity).
            </summary>
        </member>
        <member name="F:Claron.WIF.DicomStuff.InfoTag.WindowWidthSaved">
            <summary>
            Window width is always saved with a value larger than 0.
            A value of 0 indicates it was not saved.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.DicomStuff.InfoTag.Units">
            <summary>
            modality values measurement units. it can be "HU", "counts", "SUV" etc.
            For known modalities (CT) and when available pet/spect conversions the units will be determined by wif instead of reading them from the dicom header.
            </summary>
        </member>
        <member name="T:Claron.WIF.DicomStuff.ModalityEnum">
            <summary>
            Enumeration of the modalities supported by WIF in ImageU12, listed as their DICOM
            2-letter string.
            </summary>
        </member>
        <member name="P:Claron.WIF.ImageBase.IsPseudoSpacing">
            <summary>
            Get/Set property indicating if the pixel spacing is synthetic
            </summary>
        </member>
        <member name="T:Claron.WIF.ImageU12">
             <summary>
             Represents a 2D image of unsigned 12-bit pixels stored in 16b signed integers (I16).
             This is a typical format for medical images, and the only format currently
             supported by Camera.
             The image values can be accessed as stored pixel values, or as modality
             values (eg, HU for CT, counts for PET), which are linearly mapped from/to stored values
             using a slope and intercept parameters (usually set when the image is loaded, but can be modified).
            
             The pixels are stored in a 1D array, which can be directly accessed by clients for
             maximum access performance.
             </summary>
        </member>
        <member name="F:Claron.WIF.ImageU12.AW_J2K_FORMAT_RAW">
            <summary>
            Constant to specify RAW images.
            </summary>
        </member>
        <member name="F:Claron.WIF.ImageU12.AW_J2K_FORMAT_BMP">
            <summary>
            Constant to specify BMP images.
            </summary>
        </member>
        <member name="F:Claron.WIF.ImageU12.AW_J2K_INTERNAL_MULTITHREADING_OPTION">
            <summary>
            Option for multi-threading.
            </summary>
        </member>
        <member name="F:Claron.WIF.ImageU12.AW_J2K_INTERNAL_ARITHMETIC_OPTION">
            <summary>
            The type of arithmetic to use (fixed or floating point).
            </summary>
        </member>
        <member name="F:Claron.WIF.ImageU12.AW_J2K_INTERNAL_USE_FLOATING_POINT">
            <summary>
            Floating point option.
            </summary>
        </member>
        <member name="F:Claron.WIF.ImageU12.AW_J2K_INTERNAL_USE_FIXED_POINT">
            <summary>
            Fixed point arithmetic option.
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU12.CheckErrorCode(System.Int32,System.String)">
            <summary>
            Checks error code and throws an exception if it is not equal to 0.
            </summary>
            <param name="errorCode">The error code.</param>
            <param name="msg">The message of the exception which will be thrown if error code is not
            equal to 0.</param>
        </member>
        <member name="F:Claron.WIF.ImageU12._Pixels">
            <summary>
            Direct access to the internal pixels array (exercise caution!)
            </summary>
        </member>
        <member name="F:Claron.WIF.ImageU12._PixelsU8">
            <summary>
            Pixels array to store 8bit images to be transfered over the network (exercise caution!)
            </summary>
        </member>
        <member name="F:Claron.WIF.ImageU12._Grid">
            <summary>
             Contains the geometrical/dimensional properties of the image (third dimension is ignored)
            </summary>
        </member>
        <member name="F:Claron.WIF.ImageU12._tiltCorrected">
            <summary>
            Property to get/set whether the slice has been tilt corrected.
            </summary>
        </member>
        <member name="F:Claron.WIF.ImageU12._dimYBeforeTiltCorrection">
            <summary>
            Returns the y-dimension of the image before tilt correction was done. Is equal to -1
            if no tilt correction was done.
            </summary>
        </member>
        <member name="F:Claron.WIF.ImageU12._yShiftForTiltCorrection">
            <summary>
            Returns the shift in the y-direction applied to the slice to do the tilt correction.
            Returns double.NaN if no tilt correction was done.
            </summary>
        </member>
        <member name="F:Claron.WIF.ImageU12._useAwareLibraryForJpeg2000Decompression">
            <summary>
            If set to True then JPEG2000 decompression is done using Aware, Inc. library. Otherwise
            ClearCanvas library is used.
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU12.CountPixelsNotIn12bRange">
            <summary>
            Returns the number of pixels which are not in 12b range.
            </summary>
        </member>
        <member name="F:Claron.WIF.ImageU12._InfoFields">
            <summary>
            The DICOM header informational fields are stored internally in a dictionary indexed by
            their DicomTags value. Different values may be stored as objects of different types.
            This storage format allows:
            1. Using the image for processing with no header information with minimal overhead
            2. Easily keeping backwards compatibility with previous versions
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.InfoGet(Claron.WIF.DicomStuff.InfoTag)">
            <summary>
            General property for accessing informational (usually DICOM) fields
            </summary>
            <param name="Tag">The field's enum (identical to DicomTags constants)</param>
            <returns>The field's value string, or an empty string ("") if none was provided</returns>
        </member>
        <member name="M:Claron.WIF.ImageU12.InfoSet(Claron.WIF.DicomStuff.InfoTag,System.String)">
            <summary>
            General property for accessing informational (usually DICOM) fields
            </summary>
            <param name="Tag">The field's enum (identical to DicomTags constants)</param>
            <param name="NewValue">New value for that field</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.#ctor(Claron.WIF.GridBox)">
            <summary>
            Creates a basic image buffer of the given dimensions
            with no special header information.
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU12.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a basic image buffer of the given dimensions
            with no special header information.
            </summary>
            <param name="DimX">Columns</param>
            <param name="DimY">Rows</param>
        </member>
        <member name="M:Claron.WIF.ImageU12.#ctor(System.Int32,System.Int32,System.Int16[])">
            <summary>
            Creates a new image and copies its pixels from the given array 
            </summary>
            <param name="Width"></param>
            <param name="Height"></param>
            <param name="InitialPixels">Source for pixel values (copied)</param>
        </member>
        <member name="M:Claron.WIF.ImageU12.#ctor(System.Int32,System.Int32,System.Single[])">
            <summary>
            Creates a new image and copies its pixels from the given array 
            </summary>
            <param name="Width"></param>
            <param name="Height"></param>
            <param name="InitialPixels">Source for pixel values (rounded to nearest integer</param>
        </member>
        <member name="M:Claron.WIF.ImageU12.#ctor(ClearCanvas.Dicom.DicomFile,System.Int16[])">
            <summary>
             Extracts header and pixel data from the DICOM object.
            </summary>
            <param name="df">DicomFile object</param>
            <param name="pixelArray">The pixels to use. If Nothing, the pixels are extracted from df</param>
            <remarks>May throw exceptions if data is non-compliant, although the object is still usable</remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.#ctor(ClearCanvas.Dicom.DicomFile,System.Boolean)">
            <summary>
            Extracts header information from the DicomFile object. If initializePixelData is set to true
            then pixel data is also extracted.
            </summary>
            <param name="df">The DicomFile object to get the header (and) pixel pixel data from.</param>
            <param name="initializePixelData">Set to true if pixel data should be loaded also.</param>
        </member>
        <member name="M:Claron.WIF.ImageU12.#ctor(ClearCanvas.Dicom.DicomAttributeCollection,System.Int16[],System.Boolean)">
            <summary>
             Extracts header and pixel data from the DICOM object.
            </summary>
            <param name="dac"></param>
            <param name="pixelArray">The pixels to use. If Nothing, the pixels are extracted from df</param>
            <param name="isPixelsArrayEncodedRgb">if pixelArray is defined, tells if the pixel arrays are IsEncodedRgb</param>
            <remarks>May throw exceptions if data is non-compliant, although the object is still usable</remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.#ctor(ClearCanvas.Dicom.DicomAttributeCollection)">
            <summary>
             Creates an Image with No Pixels, just dicom attributes 
             allows creating a SliceStack "NotForViewing" without triggering a image pixels load
            </summary>
            <param name="dac"></param>
            <remarks>May throw exceptions if data is non-compliant, although the object is still usable</remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.#ctor(ClearCanvas.ImageViewer.StudyManagement.Frame)">
            <summary>
            Extracts header and pixel data from a DICOM image frame
            </summary>
            <param name="frame"></param>
        </member>
        <member name="M:Claron.WIF.ImageU12.#ctor(ClearCanvas.ImageViewer.StudyManagement.Frame,System.Int32)">
            <summary>
            Extracts header from a DICOM image frame and extracts pixel data from 
            a specific color channel of the image frame.
            </summary>
            <param name="frame"></param>
            <param name="colorIndex">Color channel index to extract the pixel data</param>
            <remarks>
            The colorIndex value 0, 1 and 2 corresponds to color channel R G and B, an negative 
            value indicates the the pixel data will derive from all three channels, the parameter
            will be ignored if the DICOM frame is not an color image.
            </remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.#ctor(System.String,System.Boolean)">
            <summary>
            Initializes the new object from the contents of a DICOM image file.
            </summary>
            <param name="filePath"></param>
            <param name="Remote">If true, a remoter object will be used to hold the pixels buffer,
            presumably on a remote server.</param>
            <remarks>May throw exceptions if data is non-compliant, although the object is still usable.
            If the file does not exist, the slice will have 0 width and height.</remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.#ctor(System.String)">
            <summary>
            Initializes the new object from the contents of a DICOM image file.
            </summary>
            <param name="filePath"></param>
            <remarks>On the client. May throw exceptions if data is non-compliant, although the object is still usable.
            If the file does not exist, the slice will have 0 width and height.</remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.LoadRemote(System.String)">
            <summary>
            Sets a remote pixel buffer on a server and initializes it using the contents of a
            DICOM image file.
            </summary>
            <remarks>May throw exceptions if data is non-compliant, although the object is still usable</remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.InitializeDICOM(ClearCanvas.Dicom.DicomFile)">
            <summary>
            Initializes this object from a DicomFile object.
            </summary>
            <param name="df">Dicom File object to initialize from</param>
            <remarks>If the image is CT, the values are shifted as needed and clipped to ensure
            they are withing U12 range. Otherwise, the pixel values remain unchanged.</remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.InitializeDICOM(ClearCanvas.Dicom.DicomFile,System.Boolean)">
            <summary>
            Initializes this ImageU12 with the given DICOM file object.
            </summary>
            <param name="df">The DICOM file object.</param>
            <param name="initializePixelData">If set to true then pixel data from the DICOM file object
            is loaded.</param>
        </member>
        <member name="M:Claron.WIF.ImageU12.OrientationLabelToVector(System.String)">
            <summary>
            Convert a PatientOrientation string to the corresponding unit vector in patient RCS
            </summary>
            <remarks> see  Dicom Part 3, C.7.6.1.1.1 - the characters in the label are in descending
            significance order</remarks>
            <param name="label"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.ImageU12.InternalInitializeDICOM(ClearCanvas.Dicom.DicomAttributeCollection,System.Boolean)">
            <summary>
            Initializes this object from a DicomFile object.
            </summary>
            <param name="dac">DicomAttributeCollection to initialize from</param>
            <param name="usePixelsFromDac">Indicates whether the pixels should be initialized from
            dac, or left unchanged.</param>
            <remarks>If the image is CT, the values are shifted as needed and clipped to ensure
            they are withing U12 range. Otherwise, the pixel values remain unchanged.</remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.SetPixelData(System.UInt16[])">
            <summary>
            Assigns the pixelArray values to the _Pixels array of the needed signed short format.
            </summary>
            <param name="pixelArray"></param>
        </member>
        <member name="M:Claron.WIF.ImageU12.InitFromDicomFrame(ClearCanvas.ImageViewer.StudyManagement.Frame,System.Int32)">
            <summary>
            Initialize from a DICOM image frame
            </summary>
            <param name="frame"></param>
            <param name="colorIndex"></param>
        </member>
        <member name="M:Claron.WIF.ImageU12.ExtractDicomAttributes(ClearCanvas.ImageViewer.StudyManagement.Frame,ClearCanvas.Dicom.DicomAttributeCollection)">
            <summary>
            Extracts attributes from the DICOM frame
            </summary>
            <param name="frame"></param>
            <param name="dac"></param>
        </member>
        <member name="M:Claron.WIF.ImageU12.FlipAroundX(System.Int16[]@)">
            <summary>
            Reverses the rows in the image.
            The mapper to patient is updated to reflect the change.
            </summary>
            <param name="TempBuffer">A temporary buffer to reuse when the operation is performed
            for a large number of images to reduce large object memory heap pressure
            (the typical scenario). Does not need to be allocated by the client.</param>
        </member>
        <member name="M:Claron.WIF.ImageU12.FlipAroundY(System.Int16[]@)">
            <summary>
            Reverses the pixels in each row.
            The mapper to patient is updated to reflect the change.
            </summary>
            <param name="TempBuffer">A temporary buffer to reuse when the operation is performed
            for a large number of images to reduce large object memory heap pressure
            (the typical scenario). Does not need to be allocated by the client.</param>
        </member>
        <member name="M:Claron.WIF.ImageU12.Rotate90Degrees(System.Boolean,System.Int16[])">
            <summary>
            Rotates the image contents (pixels) by 90 degrees, either clockwise or counter-clockwise
            </summary>
            <param name="tmpI16Buffer">A temporary buffer to reuse when the operation is performed
            for a large number of images to reduce large object memory heap pressure
            (the typical scenario). Does not need to be allocated by the client.</param>
            <param name="Clockwise">True -> Clockwise, otherwise CCW </param>
        </member>
        <member name="M:Claron.WIF.ImageU12.ShiftPixelsInYDirection(System.Int32,System.Double)">
            <summary>
            Shifts the pixels in the y-direction by the specified amount.
            </summary>
            <param name="newDimY"></param>
            <param name="yShiftPx">The shift in pixels.</param>
        </member>
        <member name="M:Claron.WIF.ImageU12.shiftZ(System.Int32)">
            <summary>
            Shifts image position in patient scan Z (head-feet direction)
            </summary>
            <param name="shift"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.MaxPixel">
            <summary>
            Returns the pixel value with the highest value.
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU12.MinPixel">
            <summary>
            Returns the pixel value with the smallest value.
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU12.PixelModalityMin">
            <summary>
            Find the min Modality value 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.ImageU12.PixelModalityMax">
            <summary>
            Find the max Modality value 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.ImageU12.FindPixelModalityMinMaxAsNeeded">
            <summary>
            Find the min/max Modality value as needed
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU12.PixelMin2nd">
            <summary>
            Finds the Min stored value, Ignoring the Out of FOV values
            </summary>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.ImageU12.PixelMax2nd">
            <summary>
            Finds the Max stored value, Ignoring the Out of FOV values
            </summary>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.ImageU12.FindPixelMinMax2ndAsNeeded">
            <summary>
            Finds the Min/Max stored value as needed, Ignoring the Out of FOV values
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU12.MinPixelLargerThanOrEqualTo(System.Int16)">
            <summary>
            Returns the pixel value with the smallest value larger than or equal to the given value.
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU12.Finalize">
            <summary>
            Will be called only if lock was called, but unlock wasn't
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.Copy">
            <summary>
            Returns a (deep) copy of this instance. The copy is unlocked.
            </summary>
            <remarks>The copy has a new UID</remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.CopyInfoAndTags(Claron.WIF.ImageU12)">
            <summary>
            Deep copy of the InfoFields dictionary
            </summary>
            <param name="otherImg">The image to copy the info to.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.AddSqrt(Claron.WIF.ImageU12)">
            <summary>
            Blends in another image using the root of the sum of the square values of both images.
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU12.DividePixels(System.Int32)">
            <summary>
            Divides all the pixels by a constant integer factor
            </summary>
            <param name="divisionFactor"></param>
        </member>
        <member name="M:Claron.WIF.ImageU12.Resample(System.Int32,System.Int32)">
            <summary>
            Resamples the image to a higher or lower resolution, ie, same physical extent,
            but different dimensions in X and Y, using a bilinear interpolation.
            Note that usually, to preserve isotropy,
            the new/old dimension ratio should be identical in both directions.
            The last row/column is replicated to preserve the
            ratios and provide sharp images at integer resolution multiples
            (since otherwise they would be (oldDim-1)/(newDim-1)).
            </summary>
            <param name="NewDimX">The new number of pixels in the x-direction.</param>
            <param name="NewDimY">The number of pixels in the y-direction.</param>
        </member>
        <member name="M:Claron.WIF.ImageU12.Resample(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Resamples the image to a higher or lower resolution, ie, same physical extent,
            but different dimensions in X and Y. Note that usually, to preserve isotropy,
            the new/old dimension ratio should be identical in both directions.
            In bilinear interpolation, the last row/column is replicated to preserve the
            ratios and provide sharp images at integer resolution multiples
            (since otherwise they would be (oldDim-1)/(newDim-1)).
            </summary>
            <param name="NewDimX">The new number of pixels in the x-direction.</param>
            <param name="NewDimY">The number of pixels in the y-direction.</param>
            <param name="UseBilinear">If true (default), bilinear resampling interpolation is used.
            Otherwise, a nearest-neighbor interpolation is used.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.Decimate(System.Int32)">
            <summary>
            Reduces the image resolution (and size) by an integer factor
            using averaging. Very efficient.
            </summary>
            <param name="factor">Decimation factor (2 -> half resolution)</param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.ImageU12.SampleAlongVector(Claron.WIF.Vector3,Claron.WIF.Vector3,System.Int32,System.Int16[],System.Int32)">
            <summary>
            Bilinearly samples the pixels along a vector and writes the results to a target
            array. Samples outside this image grid are written as 0.
            Not implemented for remoting (will cause an exception)
            </summary>
            <param name="StartXY">The start sampling location</param>
            <param name="StepXY">The stepping vector</param>
            <param name="SamplesCount">Number of samples</param>
            <param name="TargetPixels">A 1-D array in which to write the samples</param>
            <param name="TargetStartIndex">Index from which to write the samples</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.CombineViaInterpolation(Claron.WIF.ImageU12,Claron.WIF.ImageU12,System.Double,Claron.WIF.ImageU12)">
            <summary>
            Combines two images via interpolation.
            Single threaded since when interpolating a stack of images better speedup is achieved if each thread works on complete images.
            </summary>
            <param name="srcA">The source image A.</param>
            <param name="srcB">The source image B.</param>
            <param name="interpolationWeightForSrcA">The interpolation weight for image A
            (The fraction of A that should be in the final mix).</param>
            <param name="dst">The output image.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.PixelGet(System.Int32,System.Int32)">
            <summary>
            The value of a pixel in the image
            Not as fast as accessing the values array directly using _Pixels, but safer.
            If the coordinate is outside of the image bounds, 0 is returned and Set is ignored.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.PixelSet(System.Int32,System.Int32,System.Int16)">
            <summary>
            The value of a pixel in the image
            Not as fast as accessing the values array directly using _Pixels, but safer.
            If the coordinate is outside of the image bounds, 0 is returned and Set is ignored.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="NewValue">Value of Pixel In Image</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.PixelGet(System.Int32)">
            <summary>
            The stored value of a pixel in the image. If the index is out of range,
            an exception is thrown.
            </summary>
            <param name="Index">Index of Pixel</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.PixelSet(System.Int32,System.Int16)">
            <summary>
            The stored value of a pixel in the image. If the index is out of range,
            an exception is thrown.
            </summary>
            <param name="Index"></param>
            <param name="NewValue">Value of Pixel in Image.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.Gradient2DGet(System.Int32,System.Int32)">
            <summary>
            The value of gradient at a pixel location in the image
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.FindEdges(Claron.WIF.ImageU12@,Claron.WIF.ImageU12@,System.Double[]@,System.Double,System.Double,System.Int16,System.Int32,System.Int32)">
            <summary>
            Finds edges using the Canny edge detector.
            </summary>
            <param name="gradXImage">This image will contain the x-gradient values when the function
            exits.</param>
            <param name="gradYImage">This image will contain the y-gradient values when the function
            exits.</param>
            <param name="gradAnglesDeg">This image will contain the gradient angles when the function
            exits.</param>
            <param name="smoothingRadiusXMm">The smoothing radius to use in the x-direction
            before gradients are found.</param>
            <param name="smoothingRadiusYMm">The smoothing radius to user in the y-direction
            before gradients are found.</param>
            <param name="backgroundStoredValue">Pixels whose stored values are equal to or below this
            value are ignored.</param>
            <param name="percentileT1">Percentile used to calculate the threshold for the gradient
            magnitude above which pixels are considered to be part of an edge if they are
            connected to a strong edge.</param>
            <param name="percentileT2">Percentile used to calculate the threshold for the gradient
            magnitude above which pixels are considered to belong to a strong edge.</param>
            <returns>Returns a image object where edge pixels are marked with the number of pixels in
            that edge. Note that the pixels which are within a distance of smoothingRadiusMm from
            the edge of the image will not contain any edge pixels, this is to prevent false edges
            being generated due to the smoothing.</returns>
        </member>
        <member name="M:Claron.WIF.ImageU12.EdgeImageCalculateEdgePixelCount(System.Collections.Generic.List{System.Int32}@)">
            <summary>
            Takes this image and counts the number of edge pixels in each edge. Edge pixels are assumed
            to have a pixel value > 0, and background pixels to have a pixel value of 0.
            </summary>
            <param name="edgePixelCountsList">The number of pixels in the edges ordered from
            smallest to largest.</param>
        </member>
        <member name="M:Claron.WIF.ImageU12.GradImageX(System.Int16)">
            <summary>
            Returns the x-gradient image. Note that the gradient values on the border pixels are not
            calculated.
            </summary>
            <param name="backgroundStoredValue">Pixels whose stored values are equal to or below this
            value are ignored.</param>
        </member>
        <member name="M:Claron.WIF.ImageU12.GradImageY(System.Int16)">
            <summary>
            Returns the y-gradient image. Note that the gradient values on the border pixels are not
            calculated.
            </summary>
            <param name="backgroundStoredValue">Pixels whose stored values are equal to or below this
            value are ignored.</param>
        </member>
        <member name="M:Claron.WIF.ImageU12.ToBitvol">
            <summary>
            Converts this image into bitvol.
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU12.GradientMagnitudeQ3">
            <summary>
            Returns an image of the gradient magnitude of each pixel in the original
            image in a fixed point (Q3, or 3 binary fraction digits) 12b/pixel representation.
            The gradient is computed using the central difference. Gradients along the outer rim
            of the image are set to the maximum gradient magnitude (0xfff)
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU12.Save(System.String)">
            <summary>
            Save the image to the given path with a new UID.
            Note that the SeriesUID property should be updated if this image is part of a new series.
            </summary>
            <param name="NewPath"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.Save(System.String,System.String,System.String)">
            <summary>
            Save the image to the given path with a new UID, and, optionally, a new patient name.
            Note that the SeriesUID property should be updated if this image is part of a new series.
            </summary>
            <param name="NewPath"></param>
            <param name="NewPatientName"> Default value = null </param>
            <param name="SeriesDescription"> Default value = null </param>
            <remarks>In the current implementation, </remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.Crop(System.Drawing.Rectangle)">
            <summary>
            Crops the image to a sub-rectangle of its grid
            </summary>
            <param name="rect">The region in which the image is cropped. Intersected with
            the current image region before being applied.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.BoundingBox(System.Int16,System.Int16)">
            <summary>
            Computes (efficiently) the bounding box of pixels that are within a thresholding range.
            </summary>
            <param name="ThresholdMin">The minimum value for pixels included in the region</param>
            <param name="ThresholdMax">The maximum value for pixels included in the region</param>
            <returns>The bounding box or null if there are no thresholded pixels.</returns>
        </member>
        <member name="M:Claron.WIF.ImageU12.SubsampleImg(System.Int32,System.Int32)">
            <summary>
            Reduces the size of the image by nearest-neighbor sub-sampling - low quality.
            CopyReducedResolution produces much higher quality results for an integer reduction factor.
            </summary>
            <param name="NewWidth"></param>
            <param name="NewHeight"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.CopyReducedResolution(System.Int32)">
            <summary>
            Returns a reduced-resolution copy of the image. Each pixel in the copy is the
            average of NxN pixels in this image, where N is the resolution reduction factor.
            Changes the grid spacing (note that if this image is part of a slice-stack, the
            stack's grid spacing needs to be changed correspondingly).
            </summary>
            <param name="ResolutionReductionFactor"></param>
            <returns>A new image with reduced resolution</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.CopyDilated">
            <summary>
            Returns a dilated copy of the image, ie, an image where each pixel is the maximum of the original pixel
            and its 4 closest neighbors.
            </summary>
            <returns>A new image with same dimensions, after a dilation operation</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.CopyEroded">
            <summary>
            Returns an eroded copy of the image, ie, an image where each pixel is the minimum of the original pixel
            and its 4 closest neighbors.
            </summary>
            <returns>A new image with same dimensions, after a erosion operation</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.SmoothGaussian(System.Double)">
            <summary>
            Applies Gaussian smoothing filter to the image (using two 1D convolution passes).
            The original image pixels are overwritten (use Copy to preserve them).
            </summary>
            <param name="stdRadius">The standard deviation ("radius") of the Gaussian profile, in pixel units. The
            convolution is actually performed in a region of (4Std+1)*(4Std+1)</param>
        </member>
        <member name="M:Claron.WIF.ImageU12.SmoothGaussianX(System.Double)">
            <summary>
            Smooths the image in the x-direction only.
            </summary>
            <param name="stdRadius">The radius for smoothing.</param>
        </member>
        <member name="M:Claron.WIF.ImageU12.SmoothGaussianY(System.Double)">
            <summary>
            Smooths the image in the y-direction only.
            </summary>
            <param name="stdRadius">The radius for smoothing.</param>
        </member>
        <member name="M:Claron.WIF.ImageU12.SmoothGaussianKernel(System.Double)">
            <summary>
            Returns the Gaussian smoothing kernel for the given radius.
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU12.ConvolveSeparable(System.Double[],System.Double[])">
            <summary>
            Convolves the image with a separable 2D kernel, given its 1D kernel profiles in X and Y.
            The kernels are assumed to be odd-length with the pixel at the center.
            Single threaded for now.
            </summary>
            <param name="kernelX">An odd-length array of the kernel values to be applied in the X pass,
            with the center-indexed value applied to the input/output pixel.</param>
            <param name="kernelY">An odd-length array of the kernel values, with the center-indexed value
            applied to the input/output pixel.</param>
        </member>
        <member name="M:Claron.WIF.ImageU12.ROIStats(System.Drawing.Rectangle,System.Double@,System.Double@)">
            <summary>
            Computes average and STD of the stored pixel values in a rectangle of interest in the image
            </summary>
            <param name="Rect"></param>
            <param name="Average"></param>
            <param name="STD"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.ModalityValue(System.Int16)">
            <summary>
            Returns the input stored value translated to modality value (full integer range).
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU12.ModalityValue(System.Int32,System.Int32)">
            <summary>
            Returns the modality value at a given grid location.
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU12.ModalityValueFloatingPoint(System.Double)">
            <summary>
            Returns the input stored value translated to modality value (full integer range).
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU12.ModalityValue(System.Int16[])">
            <summary>
            Returns the input array translated from pixel to modality value (full integer range).
            Looks only at the bits in the pixel that match the header specified valid bit pattern,
            higher bits are masked out.
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU12.HU(System.Int16)">
            <summary>
            Returns the input pixel value translated from pixels to CT Hounsfield units (clamp to range -1000..3095).
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU12.HU(System.Int16[])">
            <summary>
            Returns the input array translated from pixels to CT Hounsfield units (clamp to range -1000..3095).
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU12.PixelValue(System.Int16)">
            <summary>
            Returns the stored value corresponding to the given Hounsfield Unit (Modality) value
            </summary>
            <param name="HU">The value to convert in Hounsfield Units</param>
        </member>
        <member name="M:Claron.WIF.ImageU12.StoredValue(System.Int16)">
            <summary>
            Returns the stored value corresponding to the given Hounsfield Unit (Modality) value
            </summary>
            <param name="HU">The value to convert in Hounsfield Units</param>
        </member>
        <member name="M:Claron.WIF.ImageU12.StoredValue(System.Double)">
            <summary>
            Returns the stored value corresponding to the given Hounsfield Unit (Modality) value
            </summary>
            <param name="HU">The value to convert in Hounsfield Units</param>
        </member>
        <member name="M:Claron.WIF.ImageU12.RemapPixels_Orig(System.Double,System.Int32)">
            <summary>
            Remaps all the pixels to the given slope and intercept, attempting to keep the
            corresponding modality values as similar as possible (within round-off errors).
            </summary>
            <param name="newSlope">The desired ratio between the modality and pixel values scales
            (ie, larger means modality changes faster)</param>
            <param name="newIntercept">The desired modality value of pixel value 0</param>
        </member>
        <member name="M:Claron.WIF.ImageU12.EnsurePixelRangeCompatibility">
            <summary>
            Ensures that the pixel values are all with the U12 value range.
            If the values are changed, Pixel2ModalitySlope and Pixel2ModalityIntercept
            are adjusted to ensure the modality value returns is the same (or close enough).
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.EnsurePixelRangeCompatibility(System.Boolean)">
            <summary>
            Ensures that the pixel values are all with the U12 value range.
            If the values are changed, Pixel2ModalitySlope and Pixel2ModalityIntercept
            are adjusted to ensure the modality value returns is the same (or close enough).
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.EnsurePixelRangeCompatibilityByShiftingPixelValues(System.Double)">
            <summary>
            Ensures that the pixel values are all within the U12 value range.
            If the values are changed Pixel2ModalityIntercept
            is adjusted to ensure the modality value returns is the same (or close enough).
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU12.Lock">
            <summary>
            Locks the pixels in memory and returns a pointer that can be passed to non-.NET
            functions.
            While it's locked, the image memory cannot be released or moved.
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU12.Unlock">
            <summary>
            Unlocks the pixels (see Lock()).
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU12.LUT12bTo8bRamp(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Returns a 12->8b look-up table with a windowing ramp function.
            </summary>
            <param name="rampBgn">The stored value where the ramp starts</param>
            <param name="rampEnd">The stored value where the ramp ends</param>
            <param name="Inverted">When true, invert: values below the ramp
            are white and above it are black</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.Lut12bTo32bRamp(System.Int32,System.Int32,System.UInt32[],System.Boolean)">
            <summary>
            Updates a given ARGB look-up table with a windowing ramp function.
            </summary>
            <param name="rampBgn">The stored value where the ramp starts</param>
            <param name="rampEnd">The stored value where the ramp ends</param>
            <param name="inoutArgbLut">The LUT to update.</param>
            <param name="Inverted">When true, invert: values below the ramp are white and above it are black</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.Windowed(System.UInt16,System.UInt16,System.Byte[]@)">
            <summary>
            Sets a given array to the windowed version of the image.
            </summary>
            <param name="WC">Window center, n stored value</param>
            <param name="WW">Window width, >=1</param>
            <param name="outImage">An array to hold the output. Can be empty, and will be resized to a larger
            size (only) if needed. The computation is done according to DICOM conventions.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.Windowed(System.Byte[],System.Byte[]@)">
            <summary>
            Fills a given byte image with the values of the image mapped through a 12->8b look-up-table
            </summary>
            <param name="LUT">A look-up table containing entries for all the possible pixel values in the image.</param>
            <param name="outImage">The image to write the output to. Allocated or resized if needed.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.WindowedARGB(System.UInt32[],System.UInt32[]@)">
            <summary>
            Returns a pixel buffer mapped through a 12->32b look-up-table (usually ARGB).
            The output image is (re)allocated automatically as needed.
            </summary>
            <param name="LUT">A look-up table containing entries for all the possible pixel values in the image.</param>
            <param name="outImage">The image to write the output to. Allocated or resized if needed.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.WindowedARGB(System.UInt16,System.UInt16,System.UInt32[]@,System.Boolean)">
            <summary>
            Returns a pixel buffer of the image windowed to an ARGB buffer for display.
            The output image is (re)allocated automatically as needed.
            </summary>
            <param name="WC">Windowing center (stored value</param>
            <param name="WW">Windowind width (stored value)</param>
            <param name="Inverted">Indicates whether the mapping should be through an inverted
            ramp (white to black)</param>
            <param name="outImage">The output image, which will be (re)allocated automatically as needed</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.Abs">
            <summary>
            Sets the image values to their absolute value (in case values are not set to U12).
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.Mult(System.Int16)">
            <summary>
            Multiplies each pixel by the factor. No range checks are performed.
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU12.Mult(System.Double)">
            <summary>
            Multiplies each pixel by the factor. No range checks.
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU12.CreateSubtractedAutoBiasedImage(Claron.WIF.ImageU12,Claron.WIF.ImageU12)">
            <summary>
            Subtract an mask, normalize the result to the full "BitsUsed" and sets the default window level/width
            typically used in DSA (Digital Subtraction Angiography)
            </summary>
            <param name="img1">image to be substracted from</param>
            <param name="other">mask to substract</param>
            <returns>an new image</returns>
        </member>
        <member name="M:Claron.WIF.ImageU12.SubtractAutoBiased(Claron.WIF.ImageU12)">
            <summary>
            Subtract an mask, normalize the result to the full "BitsUsed" and sets the default window level/width
            typically used in DSA (Digital Subtraction Angiography)
            </summary>
            <param name="OtherImage"></param>
        </member>
        <member name="M:Claron.WIF.ImageU12.MaxWith(Claron.WIF.ImageU12)">
            <summary>
            copy pixels from another image that are of higher value than in the current image
            </summary>
            <param name="OtherImage"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.MinWith(Claron.WIF.ImageU12)">
            <summary>
            copy pixels from another image that are of lower value than in the current image
            </summary>
            <param name="OtherImage"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.AverageDifference(Claron.WIF.ImageU12,System.Int16)">
            <summary>
            Returns the average absolute difference between pixels in this and another image
            </summary>
            <param name="OtherImage">The image to reference, must be the same size as this one.</param>
            <param name="ValueThreshold">If a pixel in either image is below the threshold, it is ignored</param>
            <returns>The average absolute difference (or Double.NaN if no pixels above threshold)</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.ClampStoredValues(System.Int16,System.Int16)">
            <summary>
            Clamp each pixel so that it is within the given range of values.
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU12.BitmaskPixels(System.Int16)">
            <summary>
            Preforms an AND logical operation of all pixels with a given mask.
            </summary>
            <param name="Bitmask">The bit pattern to AND the pixels with</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.Threshold(System.Int16,System.Int16)">
            <summary>
            Clear to 0 all pixels that are below the minimum (or above the optional maximum) value
            </summary>
            <param name="MinVal">Stored value below which pixels will be cleared to 0</param>
            <param name="MaxVal">Stored value above which pixels will be cleared to 0</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.Clear">
            <summary>
            Sets all the pixels to the same value
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU12.ErodeMm(System.Double)">
            <summary>
            Performs a sequence of 6-neighbor erosions (min of neighbors) to approximately the radius given
            in mm.
            </summary>
            <param name="radiusMm">The radius by which to erode.  
            Note that erosion is done in index space layers until the radius is reached along the x-Axis. 
            Thus for anisotropic data the effective ratius in y and/or z might be larger or smaller than the given radius.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.DilateMm(System.Double)">
            <summary>
            Performs a sequence of 6-neighbor dilations (max of neighbors) to approximately the radius given
            in mm.
            </summary>
            <param name="radiusMm">The radius by which to dilate.  
            Note that erosion is done in index space layers until the radius is reached along the x-Axis. 
            Thus for anisotropic data the effective ratius in y and/or z might be larger or smaller than the given radius.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.Erode(System.Int32)">
            <summary>
            Performs a sequence of 6-neighbor erosions (min of neighbors). The edges are ignored
            </summary>
            <param name="Count">Number of erosions to perform Default value = 1 </param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.Dilate(System.Int32)">
            <summary>
            Performs a sequence of 6-neighbor dilation (max of neighbors). The edges are ignored
            </summary>
            <param name="Count">Number of erosions to perform. Default value = 1 </param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.CountOfPixelsWithinThreshold(System.Int16,System.Int16)">
            <summary>
            Returns the count of pixels that fall within a given range of (stored) values
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU12.ClearBoundary(System.Int16)">
            <summary>
            Sets all the pixels on the outside boundary (first/last row/column) of the image to 
            a given (stored) value.
            </summary>
            <param name="CleardValue"></param>
        </member>
        <member name="M:Claron.WIF.ImageU12.Show(System.Int32,System.Int32)">
            <summary>
            Pops up a window showing the content of the image (for debugging help).
            </summary>
            <param name="WindowingCenter_Modality">Center of windowing in HU (Modality value)</param>
            <param name="WindowingWidth_Modality"> Windowing width</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.Show(System.Windows.Forms.PictureBox)">
            <summary>
            Shows the image as a bitmap in a picture box, using given windowing mappings.
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU12.Show(Claron.WIF.BitVol@,System.Drawing.Color,System.Boolean,System.UInt16,System.UInt16)">
            <summary>
            This function lets you display a bit mask on the image data.
            </summary>
            <param name="mask"></param>
            <param name="color">color for the corresponding mask</param>
            <param name="splitLines">If set to true, each scan line is repeated twice, with one scan line containing the orig data and the next one containing the mask</param>
            <param name="WindowingCenter_Modality"></param>
            <param name="WindowingWidth_Modality"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.Show(System.Single[]@,System.Drawing.Color,System.Boolean,System.UInt16,System.UInt16)">
            <summary>
            This function lets you display a cost/probability on the image data.
            </summary>
            <param name="costImg">The cost/probability image as F32 with values between 0 - 1.0</param>
            <param name="color">color for the corresponding mask</param>
            <param name="splitLines">If set to true, each scan line is repeated twice, with one scan line containing the orig data and the next one containing the mask</param>
            <param name="WindowingCenter_Modality"></param>
            <param name="WindowingWidth_Modality"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.To32bBitmap(System.Int32,System.Int32)">
            <summary>
            Returns a bitmap object representing the image, windowed to grey levels.
            </summary>
            <param name="WindowingCenter_Modality">The center of the windowing ramp in modality units</param>
            <param name="WindowingWidth_Modality">The width of the windowing ramp</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.ToArgb(System.Int32,System.Int32)">
            <summary>
            Returns an ARGB pixels buffer with image windowed to grey levels.
            </summary>
            <param name="WindowingCenter_Modality">The center of the windowing ramp in modality units</param>
            <param name="WindowingWidth_Modality">The width of the windowing ramp</param>
        </member>
        <member name="M:Claron.WIF.ImageU12.To32bBitmap(Claron.WIF.BitVol@,System.Drawing.Color)">
            <summary>
            Return a bitmap with mask displayed on original image.
            The bitmap needs to be disposed by the caller (suggestion: declare the variable with a Using block)
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU12.To32bBitmap(Claron.WIF.BitVol@,System.Drawing.Color,System.Boolean)">
            <summary>
            Return a bitmap with mask displayed on original image.
            The bitmap needs to be disposed by the caller (suggestion: declare the variable with a Using block)
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU12.To32bBitmap(Claron.WIF.BitVol@,System.Drawing.Color,System.Boolean,System.UInt16)">
            <summary>
            Return a bitmap with mask displayed on original image.
            The bitmap needs to be disposed by the caller (suggestion: declare the variable with a Using block)
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU12.To32bBitmap(Claron.WIF.BitVol@,System.Drawing.Color,System.Boolean,System.UInt16,System.UInt16)">
            <summary>
            Return a bitmap with mask displayed on original image.
            The bitmap needs to be disposed by the caller (suggestion: declare the variable with a Using block)
            </summary>
            <param name="mask"></param>
            <param name="color">set the color for each mask</param>
            <param name="splitLines">If set to true, each scan line is repeated twice, with one scan line containing the orig data and the next one containing the mask</param>
            <param name="WindowingCenter_Modality"></param>
            <param name="WindowingWidth_Modality"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.To32bBitmap(System.Single[]@,System.Drawing.Color)">
            <summary>
            Return a bitmap with mask displayed on original image.
            The bitmap needs to be disposed by the caller (suggestion: declare the variable with a Using block)
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU12.To32bBitmap(System.Single[]@,System.Drawing.Color,System.Boolean)">
            <summary>
            Return a bitmap with mask displayed on original image.
            The bitmap needs to be disposed by the caller (suggestion: declare the variable with a Using block)
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU12.To32bBitmap(System.Single[]@,System.Drawing.Color,System.Boolean,System.UInt16)">
            <summary>
            Return a bitmap with mask displayed on original image.
            The bitmap needs to be disposed by the caller (suggestion: declare the variable with a Using block)
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU12.To32bBitmap(System.Single[]@,System.Drawing.Color,System.Boolean,System.UInt16,System.UInt16)">
            <summary>
            Return a bitmap with probability/cost displayed on original image
            The bitmap needs to be disposed by the caller (suggestion: declare the variable with a Using block)
            </summary>
            <param name="costImg">The cost/probability image as F32 with values between 0 - 1.0</param>
            <param name="color">set the base color for each mask</param>
            <param name="splitLines">If set to true, each scan line is repeated twice, with one scan line containing the orig data and the next one containing the mask</param>
            <param name="WindowingCenter_Modality"></param>
            <param name="WindowingWidth_Modality"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.Dump(System.String,Claron.WIF.SliceStack)">
            <summary>
            Dump image to a temporary file
            </summary>
            <param name="imageType"></param>
            <param name="SS"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12.Filtered(Claron.WIF.ImageU12.FilterTypeEnum,System.Int32)">
            <summary>
            Returns a filtered version of this image.
            </summary>
            <param name="FilterType">The type of filter to apply</param>
            <param name="FilterSizePixels">The side, in pixel units, of the square neighborhood to be
            used as input for each output pixel. Needs to be odd to ensure symmetry.</param>
        </member>
        <member name="M:Claron.WIF.ImageU12.Filter(Claron.WIF.ImageU12@,Claron.WIF.ImageU12@,Claron.WIF.ImageU12.FilterTypeEnum,System.Int32)">
            <summary>
            Applies a filter to the this image and outputs the result as a new image.
            </summary>
            <param name="tempImg">Temporary image to be used during computation with the same
            dimensions as this image. </param>
            <param name="outImg">The output image to write the filtered pixels in.
            Must have the same dimensions as this image</param>
            <param name="filterStyle">The type of filter to apply</param>
            <param name="FilterSizePixels">The side, in pixel units, of the square neighborhood to be
            used as input for each output pixel. Needs to be odd to ensure symmetry.</param>
        </member>
        <member name="M:Claron.WIF.ImageU12.MedianFilterThread(System.Int32,System.Int32,System.Object,System.Exception@)">
            <summary>
            Median filter based on an histogram of the pixels inside the kernel. 
            The histogram is initialized when we process the first pixel and then updated when we move to the next pixel in the image
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU12.PixelNoiseAdd(System.Double)">
            <summary>
            Adds to all pixels the values from a random variable with a Gaussian distribution of the given standard deviation.  
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU12.PixelOffsetAdd(System.Double)">
            <summary>
            Adds to all pixels a given offset.  
            </summary>
        </member>
        <member name="P:Claron.WIF.ImageU12.DicomAttributes">
            <summary>
            The DICOM attributes loaded from the original dicom file.
            </summary>
        </member>
        <member name="P:Claron.WIF.ImageU12.LoadedFilePath">
            <summary>
            Returns the loaded file path of the image.
            </summary>
        </member>
        <member name="P:Claron.WIF.ImageU12.UseAwareLibraryForJpeg2000Decompression">
            <summary>
            If set to True then JPEG2000 decompression is done using Aware, Inc. library. Otherwise
            ClearCanvas library is used.
            </summary>
        </member>
        <member name="P:Claron.WIF.ImageU12.AllPixels12b">
            <summary>
            Returns true iff all the pixels are valid U12 values (ie, in the range 0..4095)
            </summary>
        </member>
        <member name="P:Claron.WIF.ImageU12.InfoFields">
            <summary>
            The collection of all informational fields
            </summary>
            <returns>A copy of the internal representation of the informational fields</returns>
            <value>A fields dictionary to be assigned directly (no copying!)</value>
        </member>
        <member name="P:Claron.WIF.ImageU12.AcquisitionDateTime">
            <summary>
            A safe way to access Info(InfoTag.AcquisitionDateTime). Looks after the case
            where the string is not a valid DateTime representation.
            </summary>
        </member>
        <member name="P:Claron.WIF.ImageU12.ContentDateTime">
            <summary>
            A safe way to access Info(InfoTag.ContentDateTime). Looks after the case
            where the string is not a valid DateTime representation.
            </summary>
        </member>
        <member name="P:Claron.WIF.ImageU12.Stored2ModalitySlope">
            <summary>
            The ratio between the modality and stored pixel values scales (ie, modality / stored - larger means modality changes faster).
            </summary>
        </member>
        <member name="P:Claron.WIF.ImageU12.Stored2ModalityIntercept">
            <summary>
            The modality value of stored pixel value 0
            </summary>
        </member>
        <member name="P:Claron.WIF.ImageU12.ToPatientScan">
            <summary>
            Mapper from slice RCS to patient scan
            </summary>
        </member>
        <member name="P:Claron.WIF.ImageU12.SpacingMM">
            <summary>
            The spacing between samples. The third (Z) element is slice thickness.
            </summary>
        </member>
        <member name="P:Claron.WIF.ImageU12.SliceThickness">
            <summary>
            Slice thickness, usually set by the DICOM header.
            </summary>
        </member>
        <member name="P:Claron.WIF.ImageU12.IsEncodedRgb">
            <summary>
            RGB data (for CAD overlay) when extracted from a DICOM file, is encoded thus:
              8 LSB: intensity. 8 MSB: dominant pixel color 0-grey, 1-blue, 2-green, 3-red
            </summary>
        </member>
        <member name="P:Claron.WIF.ImageU12.MinIsWhite">
            <summary>
            If true, the minimum pixel value is intended to be displayed as white after
            all VOI gray scale transformations have been performed
            </summary>
        </member>
        <member name="P:Claron.WIF.ImageU12.Width">
            <summary>
            The number of pixels in each row (X direction)
            </summary>
        </member>
        <member name="P:Claron.WIF.ImageU12.DimX">
            <summary>
            The number of pixels in each row (X direction)
            </summary>
        </member>
        <member name="P:Claron.WIF.ImageU12.Height">
            <summary>
            The number of rows(Y direction)
            </summary>
        </member>
        <member name="P:Claron.WIF.ImageU12.DimY">
            <summary>
            The number of rows(Y direction)
            </summary>
        </member>
        <member name="P:Claron.WIF.ImageU12.DimXY">
            <summary>
            The number of pixels in the image buffer (width*height)
            </summary>
        </member>
        <member name="P:Claron.WIF.ImageU12.Pixels">
            <summary>
            The Pixels buffer: a copy is returned (get), or the internal buffer values are set from a given buffers (set)
            </summary>
        </member>
        <member name="P:Claron.WIF.ImageU12.PixelsSetToActualValue">
            <summary>
            When false, indicates that the pixels were set to a temporary value, eg,
            to provide a dark context during incremental background loading, in which case
            the pixel values should be ignored.
            </summary>
        </member>
        <member name="P:Claron.WIF.ImageU12.PixelsInModalityValue">
            <summary>
            Returns a copy of the pixel values, translated to modality values (eg, HU in case of CT)
            </summary>
        </member>
        <member name="T:Claron.WIF.ImageU12Remoter">
            <summary>
            Represent a remote (server-side) object, owned by a client-side ImageU12 object.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12Remoter.LoadFromDicomFile(System.String)">
            <summary>
            Loads the image from a file (on the server)
            </summary>
            <param name="filePath"></param>
            <returns>An ImageU12 object with all its properties other than _pixels set according
            to the DICOM contents</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12Remoter.PixelModalityMin">
            <summary>
            Finds the Min modality value
            </summary>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.ImageU12Remoter.PixelModalityMax">
            <summary>
            Finds the Max modality value
            </summary>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.ImageU12Remoter.PixelMin2nd">
            <summary>
            Finds the Min stored value, Ignoring the Out of FOV values
            </summary>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.ImageU12Remoter.PixelMax2nd">
            <summary>
            Finds the Max stored value, Ignoring the Out of FOV values
            </summary>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.ImageU12Remoter.PixelGet(System.Int32)">
            <summary>
            The value of a pixel in the image
            </summary>
            <param name="Index">Index of Pixel</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageU12Remoter.PixelSet(System.Int32,System.Int16)">
            <summary>
            The value of a pixel in the image
            </summary>
            <param name="Index">Index of Pixel</param>
            <param name="NewValue">The value of a pixel in the image</param>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.ImageArgb">
            <summary>
            Represents a ready-to-display image of ARGB (Alpha, Red, Green, Blue 8b channels) pixels.
            The image is not expected to be spatially positioned in a PatientScan RCS. It is usually
            formed by "screen capture" of a viewport output or by loading a DICOM SC file.
            </summary>
        </member>
        <member name="F:Claron.WIF.ImageArgb._InfoFields">
            <summary>
            The DICOM header informational fields are stored internally in a dictionary indexed by
            their DicomTags value. Different values may be stored as objects of different types.
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageArgb.InfoGet(Claron.WIF.DicomStuff.InfoTag)">
            <summary>
            General property for accessing informational (usually DICOM) fields
            </summary>
            <param name="Tag">The field's enum (identical to DicomTags constants)</param>
            <returns>The field's value string, or an empty string ("") if none was provided</returns>
        </member>
        <member name="M:Claron.WIF.ImageArgb.InfoSet(Claron.WIF.DicomStuff.InfoTag,System.String)">
            <summary>
            General property for accessing informational (usually DICOM) fields
            </summary>
            <param name="Tag">The field's enum (identical to DicomTags constants)</param>
            <param name="NewValue">New value for that field</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageArgb.#ctor(ClearCanvas.Dicom.DicomFile,System.UInt32[])">
            <summary>
             Extracts header and pixel data from the DICOM object.
            </summary>
            <param name="df"></param>
            <param name="pixelArray">The pixels to use. If Nothing, the pixels are extracted from df</param>
            <remarks>May throw exceptions if data is non-compliant, although the object is still usable</remarks>
        </member>
        <member name="M:Claron.WIF.ImageArgb.#ctor(ClearCanvas.Dicom.DicomAttributeCollection,System.UInt32[])">
            <summary>
             Extracts header and pixel data from the DICOM object.
            </summary>
            <param name="dac"></param>
            <param name="pixelArray">The pixels to use. If Nothing, the pixels are extracted from df</param>
            <remarks>May throw exceptions if data is non-compliant, although the object is still usable</remarks>
        </member>
        <member name="M:Claron.WIF.ImageArgb.#ctor(System.String,System.Boolean)">
            <summary>
            Initializes the new object from the contents of a DICOM image file.
            </summary>
            <param name="filePath"></param>
            <param name="Remote">If true, a remoter object will be used to hold the pixels buffer,
            presumably on a remote server.</param>
            <remarks>May throw exceptions if data is non-compliant, although the object is still usable.
            If the file does not exist, the slice will have 0 width and height.</remarks>
        </member>
        <member name="M:Claron.WIF.ImageArgb.#ctor(System.String)">
            <summary>
            Initializes the new object from the contents of a DICOM image file.
            </summary>
            <param name="filePath"></param>
            <remarks>May throw exceptions if data is non-compliant, although the object is still usable.
            If the file does not exist, the slice will have 0 width and height.</remarks>
        </member>
        <member name="M:Claron.WIF.ImageArgb.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a basic image buffer of the given dimensions
            with no special header information.
            </summary>
            <param name="DimX">Columns</param>
            <param name="DimY">Rows</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageArgb.#ctor(Claron.WIF.ImageU12,System.Int32,System.Int32)">
            <summary>
            Initializes the new object from an ImageU12 mapped through windowing (using stored values).
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageArgb.InitializeDICOM(ClearCanvas.Dicom.DicomAttributeCollection,System.UInt32[])">
            <summary>
            Initializes this object from a DicomFile object.
            </summary>
            <param name="dac">DicomAttributeCollection object to initialize from</param>
            <param name="pixelArray">The ARGB pixels to use. If Nothing (the default), the pixels are extracted from df</param>
        </member>
        <member name="M:Claron.WIF.ImageArgb.Show(System.Int32,System.Drawing.Drawing2D.InterpolationMode,System.String)">
            <summary>
            Saved the output image in a temporary file in PNG format, then displays the file using the default
            OS image viewer for that format.
            </summary>
            <param name="ZoomFactor"></param>
            <param name="ZoomInterpMode"></param>
            <param name="ImageID"></param>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.ImageArgb.PixelsProcessor">
            <summary>
            pixel preprocessor handler: provide a delegate if pre-processing is desired
            </summary>
        </member>
        <member name="P:Claron.WIF.ImageArgb.Pixels">
            <summary>
            Direct access to the internal ARGB pixels array (exercise caution!) when
            </summary>
        </member>
        <member name="P:Claron.WIF.ImageArgb.Dims">
            <summary>
            The dimensions of the frames in the image
            </summary>
        </member>
        <member name="P:Claron.WIF.ImageArgb.InfoFields">
            <summary>
            The collection of all informational fields
            </summary>
            <returns>A copy of the internal representation of the informational fields</returns>
            <value>A fields dictionary to be assigned directly (no copying!)</value>
        </member>
        <member name="T:Claron.WIF.ImageArgbRemoter">
            <summary>
            Represent a remote (server-side) object, owned by a client-side ImageU12 object.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageArgbRemoter.LoadFromDicomFile(System.String)">
            <summary>
            Loads the image from a file (on the server)
            </summary>
            <param name="filePath"></param>
            <returns>An ImageArgb object with all its properties other than _pixels set according
            to the DICOM contents</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageArgbRemoter.PixelGet(System.Int32)">
            <summary>
            The value of a pixel in the image
            </summary>
            <param name="Index">Index of Pixel</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageArgbRemoter.PixelSet(System.Int32,System.Int32)">
            <summary>
            The value of a pixel in the image
            </summary>
            <param name="Index">Index of Pixel</param>
            <param name="NewValue">The value of a pixel in the image</param>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.ImageU8">
            <summary>
            Represents a 2D image of unsigned 8-bit (Byte) pixels, usually a grey-level image as
            displayed on the screen or a single channel in an ARGB image. It does no have a spacial
            position in any RCS.
            The pixels are stored in a 1D array, which can be directly accessed by clients for
            maximum access performance.
            </summary>
        </member>
        <member name="F:Claron.WIF.ImageU8._Pixels">
            <summary>
            Pixels array
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU8.#ctor(System.UInt32[],System.Int32,System.Int32,Claron.WIF.ImageU8.ChannelEnum)">
            <summary>
            Creates a new image from an ARGB buffer (such as the one generated at the output
            of Camera objects.
            </summary>
            <param name="Argb">The input buffer, with size at least DimX*DimY</param>
            <param name="DimX">Width of each row</param>
            <param name="DimY">Number of rows</param>
            <param name="channel"></param>
        </member>
        <member name="M:Claron.WIF.ImageU8.#ctor(System.Drawing.Bitmap,Claron.WIF.ImageU8.ChannelEnum)">
            <summary>
            Creates a new image from one or more channels of a Bitmap
            </summary>
            <param name="bmArgb">Bitmap in Argb format</param>
            <param name="channel"></param>
        </member>
        <member name="M:Claron.WIF.ImageU8.Show(System.Int32[])">
            <summary>
            Pops up a window showing the content of the image (for debugging help).
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU8.Decimated(System.Int32)">
            <summary>
            Returns an image with at a reduced resolution by an integer factor
            using averaging.
            </summary>
            <param name="factor">Decimation factor (2 -> half resolution)</param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.ImageU8.DifferenceImage(Claron.WIF.ImageU8)">
            <summary>
            Returns the absolute difference between this image and another one with the same dimensions.
            </summary>
            <param name="OtherImage"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.ImageU8.Eroded">
            <summary>
            returns a 6-neighbor eroded (local minimum) version of this image
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageU8.Dilated">
            <summary>
            returns a 6-neighbor dilated (local maximum) version of this image
            </summary>
        </member>
        <member name="F:Claron.WIF.ImageU8.ChannelEnum.WeightedAverage">
            <summary>
            Combines the channels with different weights based on human perception of brightness.
            </summary>
        </member>
        <member name="T:Claron.WIF.Image2D">
            <summary>
            Class for 2D images.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Image2D._nx">
            <summary>
            The number of pixels in the x-direction.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Image2D._ny">
            <summary>
            The number of pixels in the y-direction.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Image2D._data">
            <summary>
            The pixel data.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Image2D._sx">
            <summary>
            The pixel spacing in the x-direction (in mm).
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Image2D._sy">
            <summary>
            The pixel spacing in the y-direction (in mm).
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Image2D._origin">
            <summary>
            The location of pixel (0, 0) in physical space.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Image2D._xaxis">
            <summary>
            The orientation of the x-axis.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Image2D._yaxis">
            <summary>
            The orientation of the y-axis
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Image2D._i2p">
            <summary>
            Matrix to convert from image space to physical space.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Image2D._p2i">
            <summary>
            Matrix to convert from physical space to image space.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Image2D.#ctor(System.Int32,System.Int32,System.Double,System.Double,System.Double[],System.Double[],System.Double[])">
            <summary>
            Creates a new 2D image.
            </summary>
            <param name="nx">The number of pixels in the x-direction.</param>
            <param name="ny">The number of pixels in the y-direction.</param>
            <param name="dx">The spacing of pixels in the x-direction.</param>
            <param name="dy">The spacing of pixels in the y-direction.</param>
            <param name="origin">The location of pixel (0, 0) in the physical
            space.</param>
            <param name="xaxis">The direction of the x-axis.</param>
            <param name="yaxis">The direction of the y-axis.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Image2D.#ctor(Claron.WIF.ImageU12)">
            <summary>
            Initializes a new Image2D object from a ImageU12 object.
            </summary>
            <param name="img">The ImageU12 object to initialize from.</param>
            <remarks>Note that the origin is initialized to (0, 0), the x-axis is initialized to
            (1, 0), and the y-axis is initialized to (0, 1).</remarks>
        </member>
        <member name="M:Claron.WIF.Image2D.Clone">
            <summary>
            Returns a copy of the image.
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Image2D.Initialize(System.Int32,System.Int32,System.Double,System.Double,System.Double[],System.Double[],System.Double[])">
            <summary>
            Initializes the 2D image.
            </summary>
            <param name="nx">The number of pixels in the x-direction.</param>
            <param name="ny">The number of pixels in the y-direction.</param>
            <param name="dx">The spacing of pixels in the x-direction.</param>
            <param name="dy">The spacing of pixels in the y-direction.</param>
            <param name="origin">The location of pixel (0, 0) in the physical
            space.</param>
            <param name="xaxis">The direction of the x-axis.</param>
            <param name="yaxis">The direction of the y-axis.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Image2D.ImageToPhysical(System.Double@,System.Double@)">
            <summary>
            Converts from image space to physical space (coordinate variables are
            passed in by reference).
            </summary>
            <param name="x">The x-coordinate value in image space.</param>
            <param name="y">The y-coordinate value in image space.</param>
        </member>
        <member name="M:Claron.WIF.Image2D.PhysicalToImage(System.Double@,System.Double@)">
            <summary>
            Converts from physical space to image space (coordinate variables are
            passed in by reference).
            </summary>
            <param name="x">The x-coordinate value in physical space.</param>
            <param name="y">The y-coordinate value in physical space.</param>  
        </member>
        <member name="M:Claron.WIF.Image2D.ZeroMe">
            <summary>
            Sets all pixel values to 0.
            </summary>
        </member>
        <member name="M:Claron.WIF.Image2D.GetPixelValue(System.Int32,System.Int32)">
            <summary>
            Gets a pixel value.
            </summary>
            <param name="x">The x-coordinate.</param>
            <param name="y">The y-coordinate.</param>
            <returns>The pixel value at the specified location.</returns>
        </member>
        <member name="M:Claron.WIF.Image2D.SetPixelValue(System.Int32,System.Int32,System.Int16)">
            <summary>
            Sets a pixel value.
            </summary>
            <param name="x">The x-coordinate.</param>
            <param name="y">The y-coordinate.</param>
            <param name="val">The new pixel value.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Image2D.InterpolateNN(System.Double,System.Double)">
            <summary>
            Returns pixel value at specified location in image space using nearest
            neighbor interpolation.
            </summary>
            <param name="x">The x-coordinate of the pixel in image space.</param>
            <param name="y">The y-coordinate of the pixel in image space.</param>
            <returns>The nearest neighbor pixel value.</returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Image2D.InterpolateLinear(System.Double,System.Double)">
            <summary>
            Returns the pixel value at the specified location in image space using
            bilinear interpolation.
            </summary>
            <param name="x">The x-coordinate of the pixel in image space.</param>
            <param name="y">The y-coordinate of the pixel in image space.</param>
            <returns>The bi-linearly interpolated pixel value.</returns>
        </member>
        <member name="M:Claron.WIF.Image2D.ResampleImage(System.Int32,System.Int32)">
            <summary>
            Resamples the image to a new size.
            </summary>
            <param name="nx">The number of pixels in the x-direction.</param>
            <param name="ny">The number of pixels in the y-direction.</param>
            <returns>The resampled image.</returns>
        </member>
        <member name="M:Claron.WIF.Image2D.Threshold(System.Int16,System.Int16,System.Int16)">
            <summary>
            Thresholds the image at the given value. Any pixel above or equal to thresh is set equal to
            above and everything else is set equal to below.
            </summary>
        </member>
        <member name="M:Claron.WIF.Image2D.Normalize(System.Int16,System.Int16)">
            <summary>
            Normalizes (scales) the pixel values so that all pixel values lie between minVal and maxVal.
            </summary>
            <param name="newMinVal">The minimum pixel value.</param>
            <param name="newMaxVal">The maximum pixel value</param>
        </member>
        <member name="M:Claron.WIF.Image2D.ComputeGradientImageX">
            <summary>
            Calculates the x-component of the gradient image.
            </summary>
        </member>
        <member name="M:Claron.WIF.Image2D.ComputeSecondDerivativeImageX">
            <summary>
            Calculates the second derivative in the x-direction.
            </summary>
        </member>
        <member name="M:Claron.WIF.Image2D.ComputeGradientImageY">
            <summary>
            Calculates the y-component of the gradient image.
            </summary>
        </member>
        <member name="M:Claron.WIF.Image2D.ComputeSecondDerivativeImageY">
            <summary>
            Calculates the second derivative in the y-direction.
            </summary>
        </member>
        <member name="M:Claron.WIF.Image2D.ComputeGradientMagnitudeImage">
            <summary>
            Calculates the gradient magnitude image of this image.
            </summary>
        </member>
        <member name="M:Claron.WIF.Image2D.ComputeGradientMagnitudeImage(System.Double,System.Double)">
            <summary>
            Calculates the gradient magnitude image of this image while suppressing
            gradients which do not make an angle to the x-axis (in pixel space) within the specified
            range.
            </summary>
            <param name="minAngleRad">The minimum angle to make with the x-axis.</param>
            <param name="maxAngleRad">The maximum angle to make with the x-axis.</param>
        </member>
        <member name="M:Claron.WIF.Image2D.ComputeGradientMagnitudeImage(System.Double,System.Double,System.Double[][],Claron.WIF.Array2D{System.Double}@,Claron.WIF.Array2D{System.Double}@)">
            <summary>
            Calculates the gradient magnitude image of this image while suppressing
            gradients which do not make an angle to the x-axis (in pixel space) within the specified
            range, or which do not have magnitudes within the specified range.
            </summary>
            <param name="magMin">The minimum magnitude.</param>
            <param name="magMax">The maximum magnitude.</param>
            <param name="angleRangesRad">An array of arrays storing the angle ranges.</param>
            <param name="mags">Returns the magnitudes in this array.</param>
            <param name="anglesRad">Returns the gradient angles in this array.</param>
        </member>
        <member name="M:Claron.WIF.Image2D.ComputeAngleImage(System.Double,System.Double,System.Double[][],Claron.WIF.Array2D{System.Double}@,Claron.WIF.Array2D{System.Double}@)">
            <summary>
            Calculates the angle image (in degrees) of this image while suppressing
            gradients which do not make an angle to the x-axis (in pixel space) within the specified
            range, or which do not have magnitudes within the specified range.
            </summary>
            <param name="magMin">The minimum magnitude.</param>
            <param name="magMax">The maximum magnitude.</param>
            <param name="angleRangesRad">An array of arrays storing the angle ranges.</param>
            <param name="mags">Returns the magnitudes in this array.</param>
            <param name="anglesRad">Returns the gradient angles in this array.</param>
        </member>
        <member name="M:Claron.WIF.Image2D.RemoveNoiseMedian(System.Int32,System.Int32)">
            <summary>
            Removes noise using median filtering.
            </summary>
            <param name="hw">The half window width for the median filter.</param>
            <param name="hh">The half window height for the median filter.</param>
        </member>
        <member name="M:Claron.WIF.Image2D.BlurImage(System.Double)">
            <summary>
            Blurs the given image using a Gaussian blurring kernel.
            </summary>
            <param name="sigma">The blurring radius.</param>
        </member>
        <member name="M:Claron.WIF.Image2D.BlurImageXThreadSub(System.Object)">
            <summary>
            Blurs the image in the x-direction.
            </summary>
        </member>
        <member name="M:Claron.WIF.Image2D.BlurImageYThreadSub(System.Object)">
            <summary>
            Blurs the image in the y-direction.
            </summary>
        </member>
        <member name="P:Claron.WIF.Image2D.PixelData">
            <summary>
            Returns the pixel data.
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Image2D.NX">
            <summary>
            The number of pixels in the x-direction.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Image2D.NY">
            <summary>
            The number of pixels in the y-direction.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Image2D.SX">
            <summary>
            Returns the pixel size in the x-direction.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Image2D.SY">
            <summary>
            Returns the pixel size in the y-direction.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Image2D.Origin">
            <summary>
            Returns the location of pixel (0, 0) in physical coordinates.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Image2D.XAxis">
            <summary>
            Returns the direction of the x-axis.
            </summary>
        </member>
        <member name="P:Claron.WIF.Image2D.YAxis">
            <summary>
            Returns the direction of the y-axis.
            </summary>
        </member>
        <member name="P:Claron.WIF.Image2D.MinPixelValue">
            <summary>
            Property to get the minimum pixel value in the image.
            </summary>
        </member>
        <member name="P:Claron.WIF.Image2D.MaxPixelValue">
            <summary>
            Property to get the maximum pixel value in the image.
            </summary>
        </member>
        <member name="P:Claron.WIF.Image2D.P2I">
            <summary>
            The physical->image 3 x 3 coordinate transformation matrix.
            </summary>
        </member>
        <member name="P:Claron.WIF.Image2D.MaxAbsoluteValue">
            <summary>
            Returns the maximum absolute value.
            </summary>
        </member>
        <member name="T:Claron.WIF.Image2D.BlurImageThreadParams">
            <summary>
            The blur image thread parameters.
            </summary>
        </member>
        <member name="F:Claron.WIF.Image2D.BlurImageThreadParams._oValues">
            <summary>
            The original image values.
            </summary>
        </member>
        <member name="F:Claron.WIF.Image2D.BlurImageThreadParams._bValues">
            <summary>
            The blurred image values.
            </summary>
        </member>
        <member name="F:Claron.WIF.Image2D.BlurImageThreadParams._ijMin">
            <summary>
            The minimum i- or y-coordinate assigned to this thread.
            </summary>
        </member>
        <member name="F:Claron.WIF.Image2D.BlurImageThreadParams._ijMax">
            <summary>
            The maximum i- or y-coordinates assigned to this thread.
            </summary>
        </member>
        <member name="F:Claron.WIF.Image2D.BlurImageThreadParams._gk">
            <summary>
            The blurring kernel.
            </summary>
        </member>
        <member name="T:Claron.WIF.Image2DTransformer">
            <summary>
            Class to transform a 2D image. If no transformation is specified then the
            image is re-sampled into the image space of the output image.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Image2DTransformer._input">
            <summary>
            The input image.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Image2DTransformer._output">
            <summary>
            The output image.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Image2DTransformer._transformation">
            <summary>
            The transform.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.Image2DTransformer._interpolationType">
            <summary>
            The interpolation type.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Image2DTransformer.#ctor(Claron.WIF.Image2D,Claron.WIF.Image2D,Claron.WIF.Image2DTransformer.InterpolationModeEnum,Claron.WIF.ITransformation2D)">
            <summary>
            Creates the resampler.
            </summary>
            <param name="input">The input image.</param>
            <param name="output">The output image.</param>
            <param name="interpolationType">The interpolation type.</param>
            <param name="transformation">The transformation to apply.  Default value = null </param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Image2DTransformer.UpdateOutputImage">
            <summary>
            Updates the output image.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Image2DTransformer.UpdateOutputImageUsingLinearInterpolation">
            <summary>
            Updates the output image using linear interpolation.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.Image2DTransformer.UpdateOutputImageUsingNearestNeighborInterpolation">
            <summary>
            Updates the output image using nearest neighbor interpolation.
            </summary>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Image2DTransformer.Input">
            <summary>
            Returns the input image.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Image2DTransformer.Output">
            <summary>
            Returns the output image.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Image2DTransformer.Transformation">
            <summary>
            Returns the transformation.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Image2DTransformer.InterpolationType">
            <summary>
            Returns the interpolation type.
            </summary>
            <value></value>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.Image2DTransformer.InterpolationModeEnum">
            <summary>
            Enum for the interpolation mode.
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.BitmapToImage2DConverter">
            <summary>
            Class for converting a Bitmap to an Image2D.
            </summary>
        </member>
        <member name="F:Claron.WIF.BitmapToImage2DConverter._input">
            <summary>
            The input bitmap.
            </summary>
        </member>
        <member name="F:Claron.WIF.BitmapToImage2DConverter._output">
            <summary>
            The output image.
            </summary>
        </member>
        <member name="F:Claron.WIF.BitmapToImage2DConverter._min">
            <summary>
            The minimum pixel value.
            </summary>
        </member>
        <member name="F:Claron.WIF.BitmapToImage2DConverter._max">
            <summary>
            The maximum pixel value.
            </summary>
        </member>
        <member name="M:Claron.WIF.BitmapToImage2DConverter.#ctor(System.Drawing.Bitmap,System.Byte,System.Byte)">
            <summary>
            Creates the converter.
            </summary>
            <param name="input">The input image.</param>
            <param name="min">The minimum pixel value.</param>
            <param name="max">The maximum pixel value.</param>
            <remarks>Values outside the minimum and maximum pixel values are
            set to 0 in the output image.</remarks>
        </member>
        <member name="M:Claron.WIF.BitmapToImage2DConverter.UpdateOutputImage">
            <summary>
            Updates the output image.
            </summary>
        </member>
        <member name="P:Claron.WIF.BitmapToImage2DConverter.Output">
            <summary>
            Property to get the output image.
            </summary>
        </member>
        <member name="T:Claron.WIF.Image2DToBitmapConverter">
            <summary>
            Class to convert an image 2D into a bitmap.
            </summary>
            <remarks>The output bitmap has the same image dimensions size as the
            input image.</remarks>
        </member>
        <member name="F:Claron.WIF.Image2DToBitmapConverter._input">
            <summary>
            The input image.
            </summary>
        </member>
        <member name="F:Claron.WIF.Image2DToBitmapConverter._output">
            <summary>
            The output bitmap.
            </summary>
        </member>
        <member name="F:Claron.WIF.Image2DToBitmapConverter._min">
            <summary>
            The minimum pixel value.
            </summary>
        </member>
        <member name="F:Claron.WIF.Image2DToBitmapConverter._max">
            <summary>
            The maximum pixel value.
            </summary>
        </member>
        <member name="M:Claron.WIF.Image2DToBitmapConverter.#ctor(Claron.WIF.Image2D,System.Double,System.Double)">
            <summary>
            Creates the converter.
            </summary>
            <param name="input">The input image.</param>
            <param name="min">The minimum pixel value.</param>
            <param name="max">The maximum pixel value.</param>
            <remarks>Values outside the minimum and maximum pixel values are
            set to 0 in the output image.</remarks>
        </member>
        <member name="M:Claron.WIF.Image2DToBitmapConverter.UpdateOutputBitmap">
            <summary>
            Updates the output bitmap.
            </summary>
            <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.Image2DToBitmapConverter.Output">
            <summary>
            Returns the output bitmap.
            </summary>
        </member>
        <member name="M:Claron.WIF.ImageProcessing2D.ResampleBilinearArgb(System.UInt32[],System.Drawing.Size,System.UInt32[]@,System.Drawing.Size,Claron.WIF.Vector2,Claron.WIF.Vector2)">
            <summary>
            Resamples a 2D ARGB image on a new grid using bilinear interpolation without rotation.
            Highly optimized for maximum performance, but may run much more slowly in multithreaded debug mode.
            </summary>
            <param name="inArgb">The input image array, 1D</param>
            <param name="inDims">The dimensions of the input image array</param>
            <param name="outArgb">The output image array to be modified. Will be allocated or dimensioned if necessary.</param>
            <param name="outDims">The dimensions of the output image array</param>
            <param name="OriginInInput">The index coordinates in the input of the first output sample. May be negative.</param>
            <param name="SpacingInInput">The distances, in index units, between output samples in the
            input grid.</param>
        </member>
        <member name="M:Claron.WIF.ImageProcessing2D.ResampleByte(System.Byte[],System.Drawing.Size,System.Byte[]@,System.Drawing.Size,Claron.WIF.Vector2,Claron.WIF.Vector2,System.Boolean)">
            <summary>
            Resamples a byte image on a new grid without rotation.
            Highly optimized for maximum performance.
            </summary>
            <param name="inPixels">The input image array, 1D</param>
            <param name="inDims">The dimensions of the input image array</param>
            <param name="outPixels">The output image array to be modified. Will be allocated or dimensioned if necessary.</param>
            <param name="outDims">The dimensions of the output image array</param>
            <param name="OriginInInput">The index coordinates in the input of the first output sample. May be negative.</param>
            <param name="SpacingInInput">The distances, in index units, between output samples in the input grid.</param>
            <param name="UseBilinear">determins if bilinear (true) or nearest-neighbor (false) is used</param>
        </member>
        <member name="M:Claron.WIF.ImageProcessing2D.ResampleByte(System.Byte[],System.Drawing.Size,System.Byte[]@,System.Drawing.Size)">
            <summary>
            Resamples a byte image on a new grid without rotation to fill an output image, using bilinear
            interpolation.
            Highly optimized for maximum performance.
            </summary>
            <param name="inPixels">The input image array, 1D</param>
            <param name="inDims">The dimensions of the input image array</param>
            <param name="outPixels">The output image array to be modified. Will be allocated or dimensioned if necessary.</param>
            <param name="outDims">The dimensions of the output image array</param>
        </member>
        <member name="M:Claron.WIF.ImageProcessing2D.ResampleI16(System.Int16[],System.Drawing.Size,System.Int16[]@,System.Drawing.Size,Claron.WIF.Vector2,Claron.WIF.Vector2)">
            <summary>
            Resamples a 16b image on a new grid without rotation.
            Highly optimized for maximum performance, but may run more slowly in debug mode.
            </summary>
            <param name="inPixels">The input image array, 1D</param>
            <param name="inDims">The dimensions of the input image array</param>
            <param name="outPixels">The output image array to be modified. Will be allocated or dimensioned if necessary.</param>
            <param name="outDims">The dimensions of the output image array</param>
            <param name="OriginInInput">The index coordinates in the input of the first output sample. May be negative.</param>
            <param name="SpacingInInput">The distances, in index units, between output samples in the input grid.</param>
        </member>
        <member name="M:Claron.WIF.ImageProcessing2D.ResampleI16(System.Int16[],System.Drawing.Size,System.Int16[]@,System.Drawing.Size,Claron.WIF.Vector2,Claron.WIF.Vector2,System.Boolean)">
            <summary>
            Resamples a 16b image on a new grid without rotation.
            Highly optimized for maximum performance, but may run more slowly in multithreaded debug mode.
            </summary>
            <param name="inPixels">The input image array, 1D</param>
            <param name="inDims">The dimensions of the input image array</param>
            <param name="outPixels">The output image array to be modified. Will be allocated or dimensioned if necessary.</param>
            <param name="outDims">The dimensions of the output image array</param>
            <param name="OriginInInput">The index coordinates in the input of the first output sample. May be negative.</param>
            <param name="SpacingInInput">The distances, in index units, between output samples in the
            <param name="UseBilinear">If true (default), bilinear resampling interpolation is used.
            Otherwise, a nearest-neighbor interpolation is used.</param>
            input grid.</param>
        </member>
        <member name="M:Claron.WIF.ImageProcessing2D.ResampleIx(System.Object,System.Drawing.Size,System.Object@,System.Drawing.Size,Claron.WIF.Vector2,Claron.WIF.Vector2,System.Boolean)">
            <summary>
            Image resampling function for both I16 and byte images
            </summary>
            <param name="inPixels"></param>
            <param name="inDims"></param>
            <param name="outPixels"></param>
            <param name="outDims"></param>
            <param name="OriginInInput"></param>
            <param name="SpacingInInput"></param>
            <param name="UseBilinear"></param>
        </member>
        <member name="M:Claron.WIF.ImageProcessing2D.ArgbAlphaBlendArgb(System.UInt32[],System.UInt32[],Claron.WIF.IndexRun[],System.Double,Claron.WIF.ImageProcessing2D.AlphaBlendingAttenuation)">
            <summary>
            alpha-blend one source camera  over destination
            dst = src * alpha + dst * (1 - alpha) 
            </summary>
            <param name="overArgb">overlay camera - source</param>
            <param name="underArgb">underlay - destination</param>
            <param name="WithinRuns">apply region</param>
            <param name="blendingFactor">overlay camera transparency - between 0 and 1</param>
            <param name="attenuationType">adjust the blending factor based on the overaly's color/alpha values</param>
        </member>
        <member name="M:Claron.WIF.ImageProcessing2D.ArgbOverArgb(System.UInt32[],System.UInt32[],System.UInt32[],System.Int32,System.Int32)">
            <summary>
            An ARGB (color) buffer is composited over an "under" Argb using its alpha (A) channel
            to determine how much of the back buffer color will show up
            </summary>
            <param name="UnderArgb">The "under" buffer being composited into</param>
            <param name="OverArgb">The "over" buffer</param>
            <param name="outArgb">The results buffer, may be one of the input ones.
            Must be pre-allocated at an appropriate size.</param>
            <param name="StartIndex">The index of the first pixel in the buffer to composite</param>
            <param name="EndIndex">The index of the last pixel in the buffer to composite</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageProcessing2D.ArgbOverArgb(System.UInt32[],System.UInt32[],System.UInt32[],Claron.WIF.IndexRun[])">
            <summary>
            An ARGB (color) buffer is composited over an "under" Argb using its alpha (A) channel
            to determine how much of the back buffer color will show up
            </summary>
            <param name="UnderArgb">The "under" buffer being composited into</param>
            <param name="OverArgb">The "over" buffer</param>
            <param name="outArgb">The results buffer, may be one of the input ones.
            Must be pre-allocated at an appropriate size.</param>
            <param name="WithinRuns">An array of index runs in which the compositing should take place</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.ImageProcessing2D.TraceAroundThresholdedRegion``1(``0[],System.Int32,System.Int32,``0,``0,System.Drawing.Point)">
            <summary>
            Traces a closed contour (8-neighbors) next to (outside) an 8-connected region in the image
            containing values between low and high thresholds. The contour's last point is a neighbor
            of the first (ie, the first is not repeated). It is traced clockwise if the region is inside
            the trace and counter-clockwise if the region is a hole in the region .
            </summary>
            <param name="pixels">The image buffer in which to trace</param>
            <param name="DimX">The image width (# columns)</param>
            <param name="DimY">The image height (# rows)</param>
            <param name="ThresholdLow">Minimum value for pixels inside the contour</param>
            <param name="ThresholdHigh">Maximum value for pixels inside the contour</param>
            <param name="StartPoint">A point from which to start tracing. Should be outside
            of the threshold range (or an exception will be thrown). If it doesn't have an immediate 4-neighbor inside, the buffer
            will be scanned until such neighbor is found before tracing starts.</param>
            <returns>A list of contour points traced clockwise around and outside the region.
            When tracing fails, null is returned.</returns>
        </member>
        <member name="M:Claron.WIF.ImageProcessing2D.FindMaximalTopToBottomPath(System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Using a dynamic programming technique, very efficiently (fixed computation per pixel) 
            finds a top to bottom path (one integer X value per Y row) that has the maximum 
            the value sum.
            Each float image pixel typically represents the likelihood that the desired path goes through
            it using local attributes (value, gradient direction and strength, symmetry, etc.),
            and this function then computes the globally optimum results.
            </summary>
            <param name="pixels">The "local likelihood" image in which to find the path</param>
            <param name="DimX">The image width (# columns)</param>
            <param name="DimY">The image height (# rows)</param>
            <param name="MaxAllowedSidewaysStepsRowToRow">Specifies how much sideways movement is allowed,
            restricting the path angle. 0 -> vertical only, 1 -> 45 degrees, 2 ->  63 degrees, etc.</param>
            <returns>A list of contour points traced from Y=0 to Y=DimY-1.</returns>
        </member>
        <member name="M:Claron.WIF.ImageProcessing2D.FindMaximalLeftToRightPath(System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Using a dynamic programming technique, very efficiently (fixed computation per pixel) 
            finds a left to right path (one integer Y value per X column) that has the maximum 
            the value sum.
            Each float image pixel typically represents the likelihood that the desired path goes through
            it using local attributes (value, gradient direction and strength, symmetry, etc.),
            and this function then computes the globally optimum results.
            </summary>
            <param name="pixels">The "local likelihood" image in which to find the path</param>
            <param name="DimX">The image width (# columns)</param>
            <param name="DimY">The image height (# rows)</param>
            <param name="MaxAllowedSidewaysSteps">Specifies how much sideways movement of the traced line
            is allowed up-down as it moves from one column to the next, restricting the path angle. 
            0 -> horizontal only, 1 -> 45 degrees, 2 ->  63 degrees, etc.</param>
            <returns>A list of contour points traced from X=0 to X=DimX-1.</returns>
        </member>
        <member name="T:Claron.WIF.ImageProcessing2D.ResampleBilinearDataPerThread">
            <summary>
            General parameters to the resampling
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.VolI32">
            <summary>
            volume of I32 voxels stored in 16^3 bricks each containing 64 4^3 cubes
            </summary>
            <remarks>a common assumption across many functions it that the padding is already set to 0000,
            hence any function changing that should do so only internally
            and restore the clear padding state at the end</remarks>
        </member>
        <member name="F:Claron.WIF.VolI32._brickOffsetDeltaX">
            <summary>
            Index offset to the next brick in the bit volume.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.VolI32._numBricksX">
            <summary>
            The number of bricks in the x-direction.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.VolI32._numBricksPaddedX">
            <summary>
            The number of bricks in the x-direction including padding bricks.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.VolI32._numBricksY">
            <summary>
            The number of bricks in the y-direction.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.VolI32._numBricksPaddedY">
            <summary>
            The number of bricks in the y-direction including padding bricks.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.VolI32._numBricksZ">
            <summary>
            The number of bricks in the z-direction.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.VolI32._numBricksPaddedZ">
            <summary>
            The number of bricks in the z-direction including padding bricks.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.VolI32._brickOffsetDeltaY">
            <summary>
            The number of bricks in the x-direction (including padding bricks).
            Equal to the offset needed to move to the next y-position in the bit
            volume.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.VolI32._brickOffsetDeltaZ">
            <summary>
            The number of bricks in the x-y plane of voxels (including padding
            bricks). Equal to the offset needed to move to the next z-position
            in the bit volume.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.VolI32._brickOffset000">
            <summary>
            Offset to the first real brick (i.e. not a padding brick) in the bit
            volume.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.VolI32._brickOffsetLastInsideIdx">
            <summary>
            Offset to the last real brick (i.e. not a padding brick) in the bit
            volume.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.VolI32._brickOffsetLastPaddedIdx">
            <summary>
            Offset to the last brick (which is a padding brick) in the bit volume.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.VolI32.DeriveUtilityFields">
            <summary>
            Sets the utility fields from the base fields
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.VolI32.SetVoxelsAtPlaneMask(System.Int32,Claron.WIF.BitVol,Claron.WIF.BitVol.AxisEnum,System.Int32)">
             <summary>
            
             </summary>
             <param name="newVoxedValue"></param>
             <param name="planeBitVol"></param>
             <param name="axis"></param>
             <param name="axisValue">Default value = 0</param>
             <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.VolI32.Clear">
            <summary>
            clears inside and padding
            </summary>
        </member>
        <member name="M:Claron.WIF.VolI32.GradientMagnitudeAtMask(Claron.WIF.SliceStack,Claron.WIF.BitVol)">
            <summary>
            compute gradient of given CT value function for all pixels where mask = 1
            </summary>
            <param name="ss"></param>
            <param name="mask">The bitVol constraining where the gradient are computed.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.VolI32.GradientMagnitudeAtMask(Claron.WIF.SliceStack,Claron.WIF.BitVol,Claron.WIF.BitVol,System.Int16)">
            <summary>
            compute gradient of given CT value function for all pixels where mask = 1
            </summary>
            <param name="ss"></param>
            <param name="gradientWantedHereMask">The bitVol constraining where the gradient are computed.</param>
            <param name="calciMask"></param>
            <param name="calciRemapValueCt"></param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.VolI32.StdDevAtMask(Claron.WIF.SliceStack,Claron.WIF.BitVol)">
            <summary>
            Compute Std of the Dev CT values in the neighborhood for all voxels where mask = 1
            </summary>
            <param name="SliceStack"></param>
            <param name="mask">The bitVol constraining where the standard deviation are computed.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.VolI32.SigmoidAtMask(Claron.WIF.BitVol,System.Double,System.Double,System.Double)">
            <summary>
            Compute Std of the Dev CT values in the neighborhood for all voxels where mask = 1
            </summary>
            <param name="mask">The bitVol constraining where the sigmoids are computed.</param>
            <param name="xShift">The x value that will be shifted to x=0, and y=0.5 on the standard sigmoid curve.</param>
            <param name="xOffset">The x offset from xShift that will be mapped to 90 %on the maximum range.</param>
            <param name="yScale">The max value the sigmoid function maps to.</param>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.VolI32.Serialize(Claron.WIF.VolI32@,System.String)">
             <summary>
            
             </summary>
             <param name="vol"></param>
             <param name="filePath">Default value = "serializedVolI32.dat"</param>
             <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.VolI32.DebugPrint(System.String,Claron.WIF.Vector3_I32,System.Int32)">
             <summary>
            
             </summary>
             <param name="label"></param>
             <param name="posCenter"></param>
             <param name="borderWidth">Default value = 0</param>
             <remarks></remarks>
        </member>
        <member name="P:Claron.WIF.VolI32.Grid">
            <summary>
            The grid box defining the dimensions, spacing and position (in PatientScan RCS) of the
            Bitvol samples. Set is by value.
            </summary>
        </member>
        <member name="F:Claron.WIF.VolI32.Cube._voxels">
            <summary> the voxel array for this cube </summary>
        </member>
        <member name="M:Claron.WIF.VolI32.Cube.CopyFrom(Claron.WIF.VolI32.Cube)">
            <summary>
            deep copy  in case of non-zero data, reference only copy otherwise
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.VolI32.Cube.EnsureCubeIsUnique">
            <summary>
            New allocated memory only if currently shared, call this before writing to with iter.voxel = newVal.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.VolI32.Cube.CloneSmart">
            <summary>
            deep copy clone in case of non-zero data, reference only clone otherwise
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.VolI32.Brick.CopyFrom(Claron.WIF.VolI32.Brick)">
            <summary>
            deep copy  in case of non-zero data, referece only copy otherwise
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.VolI32.Brick.EnsureBrickIsUnique">
            <summary>
            New allocated memory only if currently shared, call this before writing to with iter.voxel = newVal.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.VolI32.Brick.CloneSmart">
            <summary>
            deep copy clone in case of non-zero data, referece only clone otherwise
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.VolI32.Iter.GoToFirstNonZeroVoxel(System.Int32,System.Int32)">
             <summary>
            
             </summary>
             <param name="startOffset">Default value = 0</param>
             <param name="stepSize">Default value = 1</param>
             <returns></returns>
             <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.VolI32.Iter.GoToNextNonZeroVoxel(System.Int32)">
             <summary>
            
             </summary>
             <param name="stepSize">Default value = 1</param>
             <returns></returns>
             <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.VolI32.Iter.MoveToMinInside26NborAnyDistance">
            <summary>
            Moves to the minimum valued 26 nbor, just considering voxel values, not distances to them.
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.VolI32.Iter.MoveToMinInside26NborMaxGradient">
            <summary>
            Moves to the 26nbor with the largest value decrease per distance unit.
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.VolI32.Iter.MoveToMinInside8NborMaxGradientXZ">
            <summary>
            Moves to the 8nbor with the largest value decrease per distance unit in the XZ plane.
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.VolI32.Iter.GoToNextZSliceVoxel">
            <summary>
            assumes it currently is at desired Z slice
            </summary>
            <remarks>z slice = a clice with the z-axis as normal</remarks>
        </member>
        <member name="T:Claron.WIF.VolI32.CubePropertyPrinter">
            <summary>
            for debugging support, type 'new VolI32.CubePropertyPrinter(iter)' in debugger to see the 64 voxels in a few properties
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:Claron.WIF.VolI64">
            <summary>
            volume of I64 voxels stored in 16^3 bricks each containing 64 4^3 cubes
            </summary>
            <remarks>a common assumption accross many functions it that the padding is already set to 0000,
            hence any function changeing that should do so only internally
            and restore the clear padding state at the end</remarks>
        </member>
        <member name="M:Claron.WIF.VolI64.Clear">
            <summary>
            clears inside and padding
            </summary>
        </member>
        <member name="M:Claron.WIF.VolI64.Serialize(Claron.WIF.VolI64@,System.String)">
             <summary>
            
             </summary>
             <param name="vol"></param>
             <param name="fileNameNoPath">Default value = "serializedVolI64.dat"</param>
             <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.VolI64.Deserialize(Claron.WIF.VolI64@,System.String)">
             <summary>
            
             </summary>
             <param name="vol"></param>
             <param name="fileNameNoPath">Default value = "serializedVolI64.dat"</param>
             <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.VolI64.DebugPrint(System.String,Claron.WIF.Vector3_I32,System.Int32)">
             <summary>
            
             </summary>
             <param name="label"></param>
             <param name="posCenter"></param>
             <param name="borderWidth">Default value = 0</param>
             <remarks></remarks>
        </member>
        <member name="F:Claron.WIF.VolI64.Cube._voxels">
            <summary> the voxel array for this cube </summary>
        </member>
        <member name="M:Claron.WIF.VolI64.Cube.CopyFrom(Claron.WIF.VolI64.Cube)">
            <summary>
            deep copy  in case of non-zero data, referece only copy otherwise
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.VolI64.Cube.CloneUnshare">
            <summary>
            deep copy clone only if currently shared, call this before writing to with iter.voxel = newVal
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.VolI64.Cube.CloneSmart">
            <summary>
            deep copy clone in case of non-zero data, referece only clone otherwise
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.VolI64.Brick.CopyFrom(Claron.WIF.VolI64.Brick)">
            <summary>
            deep copy  in case of non-zero data, referece only copy otherwise
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.VolI64.Brick.CloneUnshare">
            <summary>
            deep copy clone only if currently shared, call this before writing to with iter.voxel = newVal
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.VolI64.Brick.CloneSmart">
            <summary>
            deep copy clone in case of non-zero data, referece only clone otherwise
            </summary>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.#ctor(Claron.WIF.BitVol,Claron.WIF.BitVol)">
            <summary>
            Mesh creation from a BitVol that is assumed to be a height field alond the z-direction, 
            i.e. only one voxel turned on per z-beam.
            </summary>
            <param name="heightFieldBv">The height field input as BitVol.</param>
            <param name="voiBv">The limit of the region in which the height field may be valid.</param>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.LoadVsTsFromAsciiVtkFile(System.String,System.Collections.Generic.List{Claron.WIF.Vector3}@,Claron.WIF.Vector3_I32[]@,Claron.WIF.Vector3[]@)">
            <summary>
            Utility function to read in a mesh in VTK format. 
            Intended as example code only and tested only for limited data.
            </summary>
            <param name="filePath">The path and name of the VTK file</param>
            <param name="vs">The list of Vector3 locations extracted from the file</param>
            <param name="ts">The array of index triplets into the vs list that each form a triangle.</param>
            <param name="ns"></param>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.LoadFromStlFile(System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Initializes the mesh from a *.stl file. 
            Note that this is only example code based on a single STL file, 
            there is on guarantee that this will work for all STL files.
            </summary>
            <param name="filePath"></param>
            <param name="correctNormals"></param>
            <param name="reverseTriangleVertexOrdering"></param>
            <param name="removeDuplicateVertices"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.SaveToStlFile(System.String,System.Boolean)">
            <summary>
            Converts the mesh to a *.stl file. 
            Note that this is only example code based on a single STL file, 
            there is on guarantee that this will work for all STL files.
            </summary>
            <param name="filePath"></param>
            <param name="reverseTriangleVertexOrdering"></param>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.UpdateVerticesAndTriangles(System.Collections.Generic.IEnumerable{Claron.WIF.Vector3},System.Collections.Generic.IEnumerable{Claron.WIF.Vector3_I32})">
            <summary>
            Convert simple Surface lists of Vector3 vertices
            and Vector3_I32 triangles to the WingEdgedMesh lists of Vertices,
            Edges and Triangles with all cross references
            </summary>
            <param name="vertices"></param>
            <param name="triangles"></param>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.ToSurface(System.Collections.Generic.List{Claron.WIF.Vector3}@,System.Collections.Generic.List{Claron.WIF.Vector3_I32}@)">
            <summary>
            Convert WingEdgedMesh to simple Surface lists of Vector3 vertices
            and Vector3_I32 triangles
            </summary>
            <param name="vs"></param>
            <param name="ts"></param>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.InitAvgEdge">
            <summary>
            Compute average squared length of edges of the mesh
            </summary>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.GetSharpEdges(System.Double)">
            <summary>
            Find all edges with angle > PI/5, order them from biggest absolute valie to smallest
            </summary>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.SmoothSharpEdges">
            <summary>
            Find all edges with absolute value of angle between adjacent triangles 
            more than PI/5;
            First, try to collapse all adjacent angles with big opposite angles
            Second, try smooth remaining sharp edges by shift 
            </summary>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.SmoothAreaAfterEdit(System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Vertex},System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Vertex})">
            <summary>
            Smooth the area, not moving vertices from vsTargetCurve
            </summary>
            <param name="vsArea"></param>
            <param name="vsTargetCurve"></param>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.SmoothSharpEdgesAfterEdit(System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Vertex},System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Vertex})">
            <summary>
            Smooth only edges from the area, not moving vertices from vsTargetCurve
            </summary>
            <param name="vsArea"></param>
            <param name="vsTargetCurve"></param>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.SmoothStickingVertices(System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Vertex},System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Vertex})">
            <summary>
            Smooth only vertices from the area, not moving vertices from vsTargetCurve
            </summary>
            <param name="vsArea"></param>
            <param name="vsTargetCurve"></param>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.RotateTriangleAroundEdgeToPlane(Claron.WIF.WingedEdgeMesh.Triangle,Claron.WIF.WingedEdgeMesh.Edge,Claron.WIF.Vector3,System.Double,System.Double)">
            <summary>
            Rotate triangle around one of its edges so, that angle between its normal and
            normal to certain plain will reach given value.
            </summary>
            <param name="t"></param>
            <param name="e"></param>
            <param name="planeN"></param>
            <param name="alpha"></param>
            <param name="distContourVertToPlane"></param>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.SmoothSharpEdgeByShift(Claron.WIF.WingedEdgeMesh.Edge,System.Double)">
            <summary>
            Find center of edge centerEdge
            Find 2 opposite vertices of the edge, find their center of mass centerOppEdge
            Find center of mass between points centerEdge and centerOppEdge - "center"
            Shift by small steps(1/10 of the final value) ends of the edge and opposite vertices
            towards the "center", measuring angles of all participating edges.
            At the iteration step, where the maximum of angles of participating edges is growing and
            bigger than angle of edge at the initial position - stop iterations
            </summary>
            <param name="sE"></param>
            <param name="sharpEdgeLimit"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.SmoothSharpEdgeByShiftRestricted(Claron.WIF.WingedEdgeMesh.Edge,System.Double,System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Vertex})">
            <summary>
            The same as previous, but vertices from vsFrozen are not allowed to move
            Separate interface for performance reasons.
            </summary>
            <param name="sE"></param>
            <param name="sharpEdgeLimit"></param>
            <param name="vsFrozen"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.FlipDiagonalsInArea(System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Edge})">
            <summary>
            Find all edges from es opposite to obtuse angle.
            Replace it by the second diagonal in rectangle formed by 2 triangles
            adjacent to this edge.
            </summary>
            <param name="es"></param>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.FlipDiagonalsIfNeeded">
            <summary>
            Flip edge opposite to obtuse angle.
            Replace it by the second diagonal in rectangle formed by 2 triangles
            adjacent to this edge.
            </summary>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.FlipDiagonals(System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Edge})">
            <summary>
            Flip all diagonals from list esToFlip.
            If one of the vertices of the edge is tetrahedron, collapse tetrahedron
            If after edge flipped the max angle in 2 new triangles exceeds the max
            angle in existing triangles - don't flip it.
            </summary>
            <param name="esToFlip"></param>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.Regularize">
            <summary>
            Regularize length of edges, straighten spatial angles in vertices
            </summary>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.ReplaceVertexByTriangle(Claron.WIF.WingedEdgeMesh.Vertex)">
            <summary>
            Replace the multi-edges(>7) vertex by triangle,
            distributing all adjacent vertices of this vertex between
            3 new vertices
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.NormalizeNEdgesPerVertex">
            <summary>
            Collapse short edges, split long edges.
            Short edges are found as opposed to small angles in triangles
            Long edges are found as opposed to big angles in triangles
            </summary>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.CollapseShortEdges(System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Edge},System.Boolean)">
            <summary>
            Find all edges with squared length shorter than _avgEdgeLenSquared / 4,
            i.e. length shorter than "average length"/2
            Collapse all such edges by replacing pair of their vertices by one vertex,
            placed in the middle of the edge, collapsing 2 adjacent triangles,
            merging edges, forming these triangles and updating all dependent references.
            Before proceeding each edge from the list of short edges, test its length
            immediately before collapsing, as its length could have been changed as a 
            result of previous collapsing operations.
            If vertex with only 3 adjacent edges appears as a result of collapsing 
            operation - replace the tetrahedron formed by these edges with the base 
            triangle of tetrahedron.
            </summary>
            <param name="es"></param>
            <param name="allList"></param>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.CollapseEdges(System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Edge},System.Int32)">
            <summary>
            Collapse edges from list es - merge 2 vertices and update references
            Edges which vertices are connected to more than 2 common vertices - special case:
            it is neck of the surface, they are not collapsed
            </summary>
            <param name="es"></param>
            <param name="maxNEdges"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.CollapseEdge(Claron.WIF.WingedEdgeMesh.Edge,System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Edge}@)">
            <summary>
            Collapse edge into vertex, updates all references
            </summary>
            <param name="e"></param> edge to be removed
            <param name="removedEs"></param> all removed edges
            <returns></returns> Remaining vertex 
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.VerticesConnected(Claron.WIF.WingedEdgeMesh.Edge)">
            <summary>
            Find all vertices which are connected by edges to both vertices of e
            2 such vertices - opposite vertices of adjacent triangles.
            Sometimes it could be triangular neck of the surface - in this case
            edge should not be collapsed
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.CollapseTetrahedron(Claron.WIF.WingedEdgeMesh.Vertex)">
            <summary>
            In case vertex has only 3 edges it is the vertex of tetrahedron.
            Collapse it by removing 3 side faces of tetrahedron, this vertex,
            3 edges and replacing references to faces and edges by the new ones
            </summary>
            <param name="v"></param>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.RemoveHangingTriangle(System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Vertex})">
            <summary>
            Remove all vertices, edges, and triangle of hanging triangle not
            connected to other vertices
            </summary>
            <param name="vsTri"></param>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.IsMeshConsistentEdgesUnique(System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Vertex})">
            <summary>
            Test for debugging
            </summary>
            <param name="vs"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.IsConsistentEdgesOrder(Claron.WIF.WingedEdgeMesh.Vertex)">
            <summary>
            Test for debugging: test if sequence of edges and vertices
            adjacent to vertex is consistent
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.SplitLongEdges(System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Edge})">
            <summary>
            Find all edges with squared length longer than _avgEdgeLenSquared * 4,
            i.e. length longer than Sqrt(4) * "average length".
            Split all such edges by adding new vertex in the middle of the edge,
            remove the edge and 2 adjacent triangles, add 4 new triangles, 4 new edges
            and update all corresponding references
            </summary>
            <param name="es"></param>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.Subdivide3Edges(Claron.WIF.WingedEdgeMesh.Triangle,System.Int32[])">
            <summary>
            Instead of triangle add 4 smaller triangles built on              /\
            original vertices and added centers of each edge                 /__\
            </summary>                                                      /\  /\
            <param name="t"></param>                                       /__\/__\
            <param name="addedVsIdx"></param>  
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.DissectTriangle(Claron.WIF.WingedEdgeMesh.Triangle,System.Int32[])">
            <summary>
            Subdivide one edge of triangle
            </summary>
            <param name="t"></param>
            <param name="addedVsIdx"></param>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.FindEdgeWithVs(System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Edge},Claron.WIF.WingedEdgeMesh.Vertex,Claron.WIF.WingedEdgeMesh.Vertex)">
            <summary>
            For list of Edge-s "es" find edge with vertices v0 and v1.
            If not found return null
            </summary>
            <param name="es"></param>
            <param name="v0"></param>
            <param name="v1"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.TriangleAdd(Claron.WIF.Vector3,Claron.WIF.Vector3,Claron.WIF.Vector3,Claron.WIF.WingedEdgeMesh.Triangle)">
            <summary>
            Add the triangle formed by 3 vertices given by their coordinates to the mesh, 
            vertices assumed to be in clockwise order
            Optionally overwrite "Tolerance" property before using this function
            See http://en.wikipedia.org/wiki/Polygon_mesh#Winged-edge_meshes for a picture 
            of the data structure. Some of the comments in the function refer to this picture.
            </summary>
            <param name="v0"></param>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="nborTriangle">A nboring triangle to make adjacency search a local operation.
            This parameter is optional, if null is given global search is used.</param>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.TriangleAdd(System.Int32,System.Int32,System.Int32)">
            <summary>
            Add the triangle formed by 3 indices into vertices array, previously filled 
            vertices assumed to be in clockwise order
            See http://en.wikipedia.org/wiki/Polygon_mesh#Winged-edge_meshes for a picture 
            of the data structure. Some of the comments in the function refer to this picture.
            </summary>
            <param name="vIdx0"></param>
            <param name="vIdx1"></param>
            <param name="vIdx2"></param>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.ComputeDistVerticesToPlane(Claron.WIF.SpaceMapperSimilarity,Claron.WIF.Vector3,System.Double@,System.Double@)">
            <summary>
            Computes distances for each vertex from the given plane 
            and saves it in field DistToPlane of vertex
            For vertices in vicinity of plane( |dist| smaller than 0.01mm )
            fakes distance so that it would be bigger than 0.01mm 
            without actually moving vertex.
            </summary>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.ComputeNormals">
            <summary>
            Computes all normals based on the mesh geometry, not any corresponding SliceStack intensities
            </summary>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.VerticesDistanceToPlaneClear">
            <summary>
            Computes all normals based on the mesh geometry, not any corresponding SliceStack intensities
            </summary>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.NearestVertex(Claron.WIF.Vector3)">
            <summary>
            For v in patient coordinates find the nearest Vertex of the mesh
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.PrepareContourByCostMapOnMesh(Claron.WIF.Vector3[],System.Collections.Generic.List{Claron.WIF.Vector3}@,System.Collections.Generic.List{System.Int32}@,System.Double)">
            <summary>
            Find the best path build from the edges of the surface connecting start and end points,
            defined as nearest points to start and end of targetPoints list.
            Subdivide path into few segments if needed
            </summary>
            <param name="targetContour"></param>
            <param name="targetPoints"></param>
            <param name="targetPointsIdx"></param>
            <param name="samplingRatioEditingCurve"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.FindBestRouteOnSurface(Claron.WIF.WingedEdgeMesh.Vertex,Claron.WIF.WingedEdgeMesh.Vertex,Claron.WIF.Curve,System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Vertex})">
            <summary>
            Implements Dijkstra algorithm of search of the least cost route 
            on the graph
            Algorithm is the same as in function Surface.FindBestRouteOnSurface(),
            uses _mesh structure instead of _vertices of the Surface class
            </summary>
            <param name="bgnVertex"></param>
            <param name="endVertex"></param>
            <param name="curveToSnap"></param>
            <param name="VerticesToIgnoreList">Indices of the vertices on the surface that should be ignored, 
            i.e. those that were part of an optimal path of an earlier section of the user curve.</param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.ResurfaceToSnapToTargetContour(System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Vertex},Claron.WIF.Curve,Claron.WIF.SliceStack,System.Collections.Generic.List{Claron.WIF.Surface.vertexShift}@,System.Int32@)">
            <summary>
            Given user drawn target curve and Dijkstra path on surface
            connecting nearest to the bgn of target curve vertex with 
            nearest to the end of target curve vertex, define area to be edited
            discard all vertices existing in this area, and then rebuild surface
            to close the emerged hole smoothly.
            </summary>
            <param name="dijkstraPath"></param>
            <param name="targetCurve"></param>
            <param name="ss"></param>
            <param name="shiftsVs"></param>
            <param name="nSpecial"></param>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.BuildContourFromHalfContourAndTargetVs(System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Vertex},System.Collections.Generic.List{System.Int32},Claron.WIF.Vector3[],System.Boolean)">
            <summary>
            After boundary contour of edited area is defined and user drawn target curve 
            vertices are added build closed contour of hole to be closed.
            Use part of contour between 2 vertices nearest to bgn and end vertex of 
            target curve and vertices on target curve. Add triangles along target curve so, 
            that curvature in orthogonal direction is equal to curvature of target curve.
            </summary>
            <param name="halfContour"></param>
            <param name="targetVsIdx"></param>
            <param name="targetNs"></param>
            <param name="halfContourDistPositive"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.CorrectSurfaceOnConnection(System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Vertex},Claron.WIF.WingedEdgeMesh.Vertex,Claron.WIF.WingedEdgeMesh.Vertex)">
            <summary>
            For connection between target curve and contour, which could be significantly not in Vp,
            correct the direction of the surface. The normals to the surface are interpolated between
            normal to surface in the target first point in Vp and partial normal in 
            corresponding nearest vertex on contour
            </summary>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.IsNearContourBorder(Claron.WIF.Vector3,Claron.WIF.Vector3[])">
            <summary>
            True if the point is within 5mm of the contour border
            </summary>
            <param name="posPr"></param>
            <param name="contour"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.IsNearContourCenter(Claron.WIF.Vector3,Claron.WIF.Vector3[])">
            <summary>
            Tests if the mouse is in the central spot of one of the contours of the Tissue
            </summary>
            <param name="posPr">candidate point (in patient RCS)</param>
            <param name="contour">candidate point (in patient RCS)</param>
            <returns>true if near; false otherwise</returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.CutSurfaceIfInsideContour(Claron.WIF.Vector3,Claron.WIF.Vector3[])">
            <summary>
            Cut surface on one side of the Viewing Plane
            First, define, on what side the total sum of distances of vertices is bigger,
            Then, move all the vertices laying on the other side so that they 
            </summary>
            <param name="clickPos"></param>
            <param name="contour"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.FindInvolvedVertices(System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Vertex},Claron.WIF.Vector3[])">
            <summary>
            Find set of all vertices around Dijkstra contourOnMesh 
            and 
            </summary>
            <param name="countourOnMesh"></param>
            <param name="targetPoints"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.FindEditRoi(System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Vertex},Claron.WIF.Curve)">
            <summary>
            Find the area on the surface that is to be replaced by new 
            surface during one editing operation
            </summary>
            <param name="dijkstraPath"></param>
            <param name="targetCurve"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.FindAllVerticesAroundPathOnSurface(System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Vertex},Claron.WIF.Curve)">
            <summary>
            
            </summary>
            <param name="pathOnSurface"></param>
            <param name="targetCurve"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.FindContourOfEditedArea(System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Vertex},Claron.WIF.Curve,System.Collections.Generic.List{Claron.WIF.Surface.vertexShift}@,System.Int32@)">
            <summary>
            Find one or multiple contours of the involvedVs area.
            In case few contours exist, connect them by series of added vertices
            </summary>
            <param name="involvedVs"></param>
            <param name="targetCurve"></param> used to define distance to the target 
            for different vertices
            <param name="shiftsVs"></param>
            <param name="nSpecial"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.ComputeEdgeLengthAlongTargetCurve(Claron.WIF.Curve@,System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Vertex},Claron.WIF.WingedEdgeMesh.Vertex@,Claron.WIF.WingedEdgeMesh.Vertex@)">
            <summary>
            1. Connect ends of the target curve to the nearest vertices on the contour
            2. Smooth target curve not to allow abrupt changes of curvature
            3. Restrict edge len by the minimum of the propagated edges len from contour vertices 
            4. Propagate edge len forth and back along the target curve not to allow more than 
              _propagationEdgeLenGrade change from edge to edge
            </summary>
            <param name="targetCurve"></param>
            <param name="contour"></param>
            <param name="vBgn"></param>
            <param name="vEnd"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.RestrictEdgeLenByPropagatedFromContour(System.Double[]@,System.Double[],System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Vertex},Claron.WIF.Vector3[])">
            <summary>
            Restrict edge len by the minimum of the propagated edges len from all vertices 
            on the contour. Assume that on the surface contour all vertices have the same 
            avg length equal to Sqrt(_avgEdgeLenSquared). 
            Later should be replaced by real edge length value in each vertex, and the limit 
            for edge len on curve is equal to min of propagated lengths from all contour vertices 
            </summary>
            <param name="edgeLenCurve"></param>
            <param name="lenAlongCurve"></param>
            <param name="surfaceContour"></param>
            <param name="newContour"></param>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.FindVerticesPositionsOnTargetCurve(Claron.WIF.Curve,System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Vertex},Claron.WIF.WingedEdgeMesh.Vertex@,Claron.WIF.WingedEdgeMesh.Vertex@)">
            <summary>
            Using function of edge length per point on target curve, build the array of vertices, 
            so that distances between them would not differ by more than _propagationEdgeLenGrade
            for two neighbor edges
            </summary>
            <param name="targetCurve"></param>
            <param name="contour"></param>
            <param name="vBgn"></param>
            <param name="vEnd"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.ComputeTargetVs(Claron.WIF.Vector3[],Claron.WIF.WingedEdgeMesh.Vertex,Claron.WIF.WingedEdgeMesh.Vertex,System.Double[])">
            <summary>
            Compute Vector3 positions of vertices on the target curve
            </summary>
            <param name="targetContour"></param>
            <param name="vBgn"></param>
            <param name="vEnd"></param>
            <param name="edgeLenCurve"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.StraightenAreaForEdit(System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Vertex},Claron.WIF.Vector3[])">
            <summary>
            Straighten area around the found path on the mesh.
            </summary>
            <param name="countourOnMesh"></param>
            <param name="targetPoints"></param>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.VerticesPathOnPlane(Claron.WIF.WingedEdgeMesh.Vertex,Claron.WIF.WingedEdgeMesh.Vertex)">
            <summary>
            Find the sequence of vertices of mesh, connecting vBgn and vEnd
            and nearest to contour of mesh on the plane defined by Viewport,
            on which the editing operation is defined.
            </summary>
            <param name="vBgn"></param>
            <param name="vEnd"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.BuildSurfaceOnContour(System.Collections.Generic.List{System.Int32},System.Int32)">
            <summary>
            Continue closing sharpest angles on the contour until the number of remaining 
            vertices becomes 3 - then add last triangle.
            In case the amount of added vertices exceeds set limit - stop process and 
            stub the remaining hole by auxiliary structure in order to get consistent mesh.
            </summary>
            <param name="contourIdx"></param>
            <param name="maxAddedVs"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.PlugHole(System.Collections.Generic.List{System.Int32})">
            <summary>
            Auxiliary function used to stop the process of surface generating on the contour
            in case the amount of added vertices exceeds reasonable restriction.
            Adds one vertex in the center of mass of all vertices on the contour, and build 
            all triangles with one vertex in this new vertex, and two others - consequent
            vertices on the contour.
            </summary>
            <param name="contourIdx"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.CloseSharpestCornerOnContour(System.Collections.Generic.List{System.Int32})">
            <summary>
            Iteration of re-surfacing algorithm:
            finds the sharpest angle on the contour and closes it by one edge or fan of 
            edges with separating vertices. All new vertices and new generated triangles
            are added to the mesh lists. The list of contourVsIdx is updated.
            The sharpest edge is defined in respect to its projection on the plane,
            tangential to the surface at the current vertex.
            The estimation of the normal to this plane is made by weighting the partial normals 
            to the surface, computed in neighboring vertices. This partial normals are
            computed considering only the existing faces adjacent to the vertex.
            </summary>
            <param name="contourVsIdx"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.EstimateSurfaceNormalsOnContourVertices(System.Collections.Generic.List{System.Int32})">
            <summary>
            For each vertex on the current contour estimate the normal to the part of the surface
            already existing in this vertex.
            1. Compute partial normals 
            2. Smooth them with sliding window kernel 1/k, k=4
            3. Sample the rest of the contour vertices and consider normals in them with weight 
            inversely proportional to the distance of this vertex to the current
            </summary>
            <param name="contourVsIdx"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.EstimateSurfaceNormalsOnTargetVertices(System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Vertex},System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Vertex},Claron.WIF.Vector3[],Claron.WIF.Vector3,Claron.WIF.WingedEdgeMesh.Vertex,Claron.WIF.WingedEdgeMesh.Vertex)">
            <summary>
            
            </summary>
            <param name="targetVs"></param>
            <param name="contour"></param>
            <param name="contoutNs"></param>
            <param name="generalSurfaceN"></param>
            <param name="vBgn"></param>
            <param name="vEnd"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.VertexNborRad(Claron.WIF.WingedEdgeMesh.Vertex,System.Double)">
            <summary>
            Computes list of all neighbor vertices of centralV with distance
            not bigger than rad from centralV
            </summary>
            <param name="centralV"></param>
            <param name="rad"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.DilateArea(System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Vertex})">
            <summary>
            Add to the list of vertices all vertices which are adjacent 
            to the vertices of input list
            </summary>
            <param name="vertices"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.BoundaryVertices(System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Vertex})">
            <summary>
            All vertices adjacent to the vertices of the input list, 
            which don't belong to the input list
            </summary>
            <param name="vertices"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.RemoveObsoleteVertices(System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Vertex})">
            <summary>
            Remove from the list vertices, which were previously removed from the 
            general list _Vs as a result of collapsing operations
            </summary>
            <param name="vs"></param>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.StraightenArea(System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Vertex},System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Vertex})">
            <summary>
            Assuming that movingVs form continuous spot on the mesh(built as neighborhood
            of certain radius around central vertex), and frozenVs is its boundary, replace 
            each vertex in iterations by weighted sum of its neighbors average and its own
            position.
            Play with n of iterations and weight.
            </summary>
            <param name="movingVs"></param>
            <param name="frozenVs"></param>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.SmoothAreaCurvature(System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Vertex},System.Int32)">
            <summary>
            Estimate the average curvature in vertex.
            Replace each vertex from movingVs by weighted sum of its position and average of
            its adjacent vertices. Weight is defined in each vertex so that it the new position
            of the vertex gives the best approximation of estimation of curvature to the computed 
            average value.
            </summary>
            <param name="areaVs"></param>
            <param name="nIter"></param>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.IdsRelabel">
            <summary>
            Re-labels all vertices according to their postion in the list. 
            Call this if predictable labels are needed.
            </summary>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.DemoMeshUmbrella">
            <summary>
            Simple mirrored umbrella shape. 
            triangles are in a right handed coordinate system, clockwise vertices, normals pointing outwards
            </summary>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.PlaneContours(Claron.WIF.SpaceMapperSimilarity,Claron.WIF.Vector3)">
            <summary>
            Contour of the surface in the plane defined by Pat2Vr rotation matrix
            and the point in plane FocusPosPr. Uses _mesh structure
            </summary>
            <param name="Pat2Vr"></param>
            <param name="FocusPosPr"></param>
            <returns></returns>
            <remarks> Function cannot be called multi-threaded </remarks> 
        </member>
        <member name="P:Claron.WIF.WingedEdgeMesh.Tolerance">
            <summary>
            Precision used during mash generation: vertices closer than Tolerance
            will be merged
            </summary>
        </member>
        <member name="P:Claron.WIF.WingedEdgeMesh.Volume">
            <summary>
            Returns the volume of the surface (in the RCS its vertices are specified),
            assuming it is closed and non self-intersecting.
            Very fast and efficient.
            </summary>
            <remarks>The volume is calculated by summing, for each triangle in the mesh, the product
            (1/6)(z0+z1+z2) [ x0(y2-y1) + x1(y0-y2) + x2(y1-y0) ], which is the signed volume
            of the pyramid formed between the three vertices and the origin.
            The sign is positive or negative according to a sort of right-hand rule.</remarks>
        </member>
        <member name="F:Claron.WIF.WingedEdgeMesh.Vertex.V">
            <summary> Vertex coordinates </summary>
        </member>
        <member name="F:Claron.WIF.WingedEdgeMesh.Vertex.Es">
            <summary> The list of edges adjacent to this vertex in clockwise order</summary>
        </member>
        <member name="F:Claron.WIF.WingedEdgeMesh.Vertex._normal">
            <summary> Vertex normal </summary>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.Vertex.NormalCompute">
            <summary>
            The normal at this vertex is the average normal of all incident triangles weighted by the angle of each triangle at this vertex.
            </summary>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.Vertex.Flatness">
            <summary>
            The "flatness" at this vertex is the average normal deviation from the vertex normal of all incident triangles weighted by the angle of each triangle at this vertex.
            Assumes the normal was already computed.
            </summary>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.Vertex.AngleAtEdgeProjected(Claron.WIF.WingedEdgeMesh.Edge,Claron.WIF.WingedEdgeMesh.Edge)">
            <summary>
            The angle in radians between the edge at the given index and the next one in clockwise order.
            Measured in projection onto the plane given by the vertex normal.
            Assumes the normal is already computed.
            </summary>
            <param name="ePrev">the edge before eNext.</param>
            <param name="eNext">the edge after ePrev.</param>
            <returns>The angle in radians [0, 2pi]</returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.Vertex.AngleAtEdgeLocal(System.Int32)">
            <summary>
            The angle in radians between the edge at the given index and the next one in clockwise order.
            Measured in the plane given by the the two edges.
            Assumes the normal is already computed.
            </summary>
            <param name="edgeI"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.Vertex.SumAdjacentAngles">
            <summary>
            Compute Sum of all adjacent angles 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.Vertex.Gradient(Claron.WIF.SliceStack)">
            <summary>
            Computes gradient of ss in point this vertex (vector V)
            </summary>
            <param name="ss"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.Vertex.TriangleFanContourEdges">
            <summary>
            The list of edges on the contour of the triangle fan around this vertex.
            Added to list is clockwise order and oriented aligned with that order.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.Vertex.TriangleFanContourVertices">
            <summary>
            The list of vertices on the contour of the triangle fan around this vertex.
            Added to list is clockwise order.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.Vertex.NborVerticesWithinMmEuclidean(System.Double)">
            <summary>
            Computes the patch of nbor vertices within the given Euclidean radiusMm as discovered in a geodesic region grow.
            Assumes we start with all Vertex.DistToPlane values set to 0, 
            will terminate with all distances inside the patch set to the Eucledian distance.
            </summary>
            <param name="nborDistMaxMm"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.Vertex.NborVerticesWithinMmGeodesic(System.Double)">
            <summary>
            Computes the patch of nbor vertices within the given Geodesic radiusMm.
            Assumes we start with all Vertex.DistToPlane values set to 0,
            will terminate with all distances inside the patch set to the Geodesic distance.
            The distance is a piecewise linear approximation by summation of edge lengths.
            </summary>
            <param name="nborDistMaxMm"></param>
            <returns></returns>
        </member>
        <member name="F:Claron.WIF.WingedEdgeMesh.Edge.Vs">
            <summary> The 2 vertices forming this edge in arbitrary order, v0 is considered back, v1 - front </summary>
        </member>
        <member name="F:Claron.WIF.WingedEdgeMesh.Edge.Ts">
            <summary> The 2 triangles adjacent to this edge in order: left, right </summary>
        </member>
        <member name="F:Claron.WIF.WingedEdgeMesh.Edge.Es">
            <summary> The 4 edges adjacent to this edge in order: back CW, back CCW, front CCW, front CW [CW - clockwise, CCW - counter clockwise] </summary>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.Edge.OtherV(Claron.WIF.WingedEdgeMesh.Vertex)">
            <summary>
            Opposite vertex of this edge
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.Edge.OtherT(Claron.WIF.WingedEdgeMesh.Triangle)">
            <summary>
            The other triangle adjacent to this edge
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.Edge.TrianglesNextIntersecting(System.Collections.Generic.List{Claron.WIF.WingedEdgeMesh.Triangle},Claron.WIF.WingedEdgeMesh.Vertex)">
            <summary>
            Next step of contour intersection mesh with plane
            </summary>
            <param name="prevIntersectingT"></param>
            <param name="vInPlane"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.Edge.EdgeBgnAtV(Claron.WIF.WingedEdgeMesh.Vertex)">
            <summary>
            Returns an edge derived from the current edge: 
            Identical if the current already has the given vertex as starting vertex, 
            flipped otherwise
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.Edge.EdgeEndAtV(Claron.WIF.WingedEdgeMesh.Vertex)">
            <summary>
            Returns an edge derived from the current edge: 
            Identical if the current already has the given vertex as starting vertex, 
            flipped otherwise
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.Edge.EdgeOppositeDirection">
            <summary>
            Returns an edge derived from the current edge: 
            Identical if the current already has the given vertex as starting vertex, 
            flipped otherwise
            </summary>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.Edge.Replace(Claron.WIF.WingedEdgeMesh.Vertex,Claron.WIF.WingedEdgeMesh.Vertex)">
            <summary>
            In array of Vs replace element equal to v0 by v1
            Used in collapse edge operation
            </summary>
            <param name="v0"></param>
            <param name="v1"></param>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.Edge.Angle">
            <summary>
            The angle, in radians, between the two adjacent triangles
            </summary>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.Edge.Replace(Claron.WIF.WingedEdgeMesh.Triangle,Claron.WIF.WingedEdgeMesh.Triangle)">
            <summary>
            In array of Ts replace element equal to t0 by t1
            Used in collapse edge operation
            </summary>
            <param name="t0"></param>
            <param name="t1"></param>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.Edge.Replace(Claron.WIF.WingedEdgeMesh.Edge,Claron.WIF.WingedEdgeMesh.Edge)">
            <summary>
            In array of Es if element equal to t0 exist replace it by t1
            Used in collapse edge operation
            </summary>
            <param name="edgeToRemove"></param>
            <param name="edgeToStay"></param>
        </member>
        <member name="F:Claron.WIF.WingedEdgeMesh.Triangle.Es">
            <summary> The 3 edges adjacent to this triangle in CW order [CW - clockwise] of a right handed coordinate system, 
            i.e. along fingers of curled right hand, with the thumb coming going into the plane away from the observer.</summary>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.Triangle.Vertices">
            <summary>
            Returns the list of vertices of this triangle in clockwise order, 
            starting with the vertex shared by edge 0 and edge 2, thus e0 will go from v0 to v1
            </summary>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.Triangle.CorrectCW(Claron.WIF.WingedEdgeMesh.Vertex,Claron.WIF.WingedEdgeMesh.Vertex,Claron.WIF.WingedEdgeMesh.Vertex)">
            <summary>
            True, if (v0, v1, v2) sequence is CW in this triangle,
            false otherwise
            </summary>
            <param name="v0"></param>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.Triangle.Angles">
            <summary>
            Returns abs values of angles in opposite to building edges vertices
            </summary>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.Triangle.AngleMaxDotProduct">
            <summary>
            The dot-product of the smallest angle in the triangle.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.Triangle.Replace(Claron.WIF.WingedEdgeMesh.Edge,Claron.WIF.WingedEdgeMesh.Edge)">
            <summary>
            In array of Es replace element equal to e0 by e1
            Used in collapse edge operation
            </summary>
            <param name="e0"></param>
            <param name="e1"></param>
        </member>
        <member name="T:Claron.WIF.WingedEdgeMesh.CoreData">
            <summary>
            Most minimal data representation of a WindedEdgeMesh, without connectivity and normals and Distances.
            </summary>
        </member>
        <member name="T:Claron.WIF.WingedEdgeMesh.VertexHierarchy">
            <summary>
            A hierarchical collection of vertices, grouped by mutual closeness, hierachical maintained center of mass and max radius
            </summary>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.VertexHierarchy.Item.ChildSetA(Claron.WIF.WingedEdgeMesh.VertexHierarchy.Item)">
            <summary>
            Adds a new child.
            Assumes this is a leaf node.
            Will turn this into an interior group node, having the former this and the new item both as children
            </summary>
            <param name="child">The child to add</param>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.VertexHierarchy.Item.ChildSetB(Claron.WIF.WingedEdgeMesh.VertexHierarchy.Item)">
            <summary>
            Adds a new child.
            Assumes this is a group node with ChildA != null.
            Assumes this is a group node with ChildB == null.
            </summary>
            <param name="child">The child to add</param>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.VertexHierarchy.Item.ParentChainUpdate">
            <summary>
            Updates the parent and recursively its parent chain to the root.
            Assumes ChildA is non-null, ChildB may or may not be null.
            </summary>
        </member>
        <member name="M:Claron.WIF.WingedEdgeMesh.VertexHierarchy.Item.TreeId">
            <summary>
            Depth-order traversal of the tree creating a vertexId tring along the way
            </summary>
            <returns></returns>
        </member>
        <member name="T:Claron.WIF.WingedEdgeMesh.ImageContours">
            <summary>
            All contours of the intersection of an original SliceStack image and the surface.
            </summary>
        </member>
        <member name="F:Claron.WIF.WingedEdgeMesh.ImageContours.Contours">
            <summary>
            The list of contours (typically one) on the intersection for this slice
            </summary>
        </member>
        <member name="F:Claron.WIF.WingedEdgeMesh.ImageContours._contourLargest">
            <summary>The contour in the original slice with the largest long axis.</summary>
        </member>
        <member name="P:Claron.WIF.WingedEdgeMesh.ImageContours.LargestContour">
            <summary>The contour in the original slice with the largest long axis.</summary>
        </member>
        <member name="T:Claron.WIF.WingedEdgeMesh.ImageContours.Axis">
            <summary>
            A line segment representing an axis of the intersection in the Patient RCS
            </summary>
        </member>
        <member name="T:Claron.WIF.WingedEdgeMesh.ImageContours.SingleContour">
            <summary>
            A single contour of a surface-plane intersection and the corresponding major and minor axis (length and width) in Pr (Patient RCS)
            </summary>
        </member>
        <member name="P:Claron.WIF.VisibleSurface.IsFilled">
            <summary>
            Fill the Surface (represented with the polyline PolyLineNameRoot) on a slab view
            </summary>
        </member>
        <member name="P:Claron.WIF.VisibleSurface.PolylineThickness">
            <summary>
            The width of the pen used to draw the polyline PolyLineNameRoot on a slab view
            </summary>
        </member>
    </members>
</doc>
